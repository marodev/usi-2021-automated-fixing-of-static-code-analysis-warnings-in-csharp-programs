Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Core
    #1 Path: D:\a\1\s\src\Core\Address.cs, Line: 348, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #2 Path: D:\a\1\s\src\Core\Address.cs, Line: 415, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\src\Core\Address.cs, Line: 607, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: D:\a\1\s\src\Core\Address.cs, Line: 637, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #5 Path: D:\a\1\s\src\Core\Assemblers\Emitter.cs, Line: 133, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #6 Path: D:\a\1\s\src\Core\BackwalkOperation.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #7 Path: D:\a\1\s\src\Core\BackwalkOperation.cs, Line: 136, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #8 Path: D:\a\1\s\src\Core\BackwalkOperation.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #9 Path: D:\a\1\s\src\Core\BackwalkOperation.cs, Line: 87, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\src\Core\BitRange.cs, Line: 167, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #11 Path: D:\a\1\s\src\Core\BitRange.cs, Line: 74, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #12 Path: D:\a\1\s\src\Core\CLanguage\CDirectiveLexer.cs, Line: 214, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\src\Core\CLanguage\CDirectiveLexer.cs, Line: 217, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: D:\a\1\s\src\Core\CLanguage\CDirectiveLexer.cs, Line: 260, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #15 Path: D:\a\1\s\src\Core\CLanguage\CDirectiveLexer.cs, Line: 268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #16 Path: D:\a\1\s\src\Core\CLanguage\CDirectiveLexer.cs, Line: 270, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\src\Core\CLanguage\CLexer.cs, Line: 782, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #18 Path: D:\a\1\s\src\Core\CLanguage\CParser.cs, Line: 119, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #19 Path: D:\a\1\s\src\Core\CLanguage\CParser.cs, Line: 126, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #20 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 131, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #21 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 277, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #22 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 278, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #23 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 477, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #24 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 663, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 678, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 693, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 720, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 737, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 765, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 818, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 830, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #32 Path: D:\a\1\s\src\Core\CLanguage\CSyntax.cs, Line: 884, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #33 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 307, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #34 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 316, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 319, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #36 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 325, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 330, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 336, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #39 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 344, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #40 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 351, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #41 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 356, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 363, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #43 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 377, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #44 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 382, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #45 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 388, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #46 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 424, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #47 Path: D:\a\1\s\src\Core\CLanguage\NamedDataTypeExtractor.cs, Line: 488, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\src\Core\Configuration\PlatformDefinition.cs, Line: 118, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #49 Path: D:\a\1\s\src\Core\Configuration\PlatformDefinition.cs, Line: 70, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: D:\a\1\s\src\Core\Configuration\RekoConfigurationService.cs, Line: 373, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #51 Path: D:\a\1\s\src\Core\Configuration\RekoConfigurationService.cs, Line: 409, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #52 Path: D:\a\1\s\src\Core\Configuration\RekoConfigurationService.cs, Line: 429, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #53 Path: D:\a\1\s\src\Core\Configuration\RekoConfigurationService.cs, Line: 447, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #54 Path: D:\a\1\s\src\Core\Dfa\DfaBuilder.cs, Line: 130, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #55 Path: D:\a\1\s\src\Core\Expressions\Constant.cs, Line: 177, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #56 Path: D:\a\1\s\src\Core\Expressions\Constant.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #57 Path: D:\a\1\s\src\Core\Expressions\Constant.cs, Line: 345, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #58 Path: D:\a\1\s\src\Core\Expressions\Expression.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #59 Path: D:\a\1\s\src\Core\Expressions\ExpressionMatcher.cs, Line: 476, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #60 Path: D:\a\1\s\src\Core\Expressions\ExpressionTypeAscenderBase.cs, Line: 91, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #61 Path: D:\a\1\s\src\Core\FieldAttribute.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #62 Path: D:\a\1\s\src\Core\Frame.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #63 Path: D:\a\1\s\src\Core\Frame.cs, Line: 195, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #64 Path: D:\a\1\s\src\Core\FrameApplicationBuilder.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #65 Path: D:\a\1\s\src\Core\FrameApplicationBuilder.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #66 Path: D:\a\1\s\src\Core\FrameApplicationBuilder.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #67 Path: D:\a\1\s\src\Core\ImageLoader.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #68 Path: D:\a\1\s\src\Core\ImageMap.cs, Line: 122, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #69 Path: D:\a\1\s\src\Core\ImageMap.cs, Line: 196, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #70 Path: D:\a\1\s\src\Core\ImageMap.cs, Line: 373, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #71 Path: D:\a\1\s\src\Core\ImageSegment.cs, Line: 216, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #72 Path: D:\a\1\s\src\Core\ImageSymbol.cs, Line: 197, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #73 Path: D:\a\1\s\src\Core\ImportReference.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #74 Path: D:\a\1\s\src\Core\ImportReference.cs, Line: 184, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #75 Path: D:\a\1\s\src\Core\IntrinsicProcedure.cs, Line: 109, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #76 Path: D:\a\1\s\src\Core\Lib\DiGraph.cs, Line: 249, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #77 Path: D:\a\1\s\src\Core\Lib\DirectedGraphImpl.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: D:\a\1\s\src\Core\Lib\Float16.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #79 Path: D:\a\1\s\src\Core\Lib\Float80.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #80 Path: D:\a\1\s\src\Core\Lib\Float96.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: D:\a\1\s\src\Core\Lib\IntervalTree.cs, Line: 1422, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #82 Path: D:\a\1\s\src\Core\Lib\IntervalTree.cs, Line: 1454, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #83 Path: D:\a\1\s\src\Core\Lib\IntervalTree.cs, Line: 428, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #84 Path: D:\a\1\s\src\Core\Lib\IntervalTree.cs, Line: 435, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #85 Path: D:\a\1\s\src\Core\Lib\IntervalTree.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #86 Path: D:\a\1\s\src\Core\Lib\LinqAlgorithms.cs, Line: 118, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #87 Path: D:\a\1\s\src\Core\Lib\LinqAlgorithms.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #88 Path: D:\a\1\s\src\Core\Lib\SuffixArray.cs, Line: 435, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #89 Path: D:\a\1\s\src\Core\Lib\UbjsonReader.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #90 Path: D:\a\1\s\src\Core\Memory\ByteMemoryArea.cs, Line: 259, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #91 Path: D:\a\1\s\src\Core\Memory\ByteMemoryArea.cs, Line: 288, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #92 Path: D:\a\1\s\src\Core\Memory\ByteMemoryArea.cs, Line: 310, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #93 Path: D:\a\1\s\src\Core\Memory\ByteMemoryArea.cs, Line: 338, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #94 Path: D:\a\1\s\src\Core\Memory\ByteMemoryArea.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #95 Path: D:\a\1\s\src\Core\Memory\EndianImageReader.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #96 Path: D:\a\1\s\src\Core\Memory\Word16MemoryArea.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #97 Path: D:\a\1\s\src\Core\NamingPolicy.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #98 Path: D:\a\1\s\src\Core\Operators\IAddOperator.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #99 Path: D:\a\1\s\src\Core\Operators\ShlOperator.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\src\Core\Output\CodeFormatter.cs, Line: 173, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #101 Path: D:\a\1\s\src\Core\Output\CodeFormatter.cs, Line: 947, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #102 Path: D:\a\1\s\src\Core\Output\CodeFormatter.cs, Line: 949, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #103 Path: D:\a\1\s\src\Core\Output\JsonWriter.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\src\Core\Output\JsonWriter.cs, Line: 65, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs, Line: 17, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #106 Path: D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs, Line: 212, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #107 Path: D:\a\1\s\src\Core\Pascal\PascalLexer.cs, Line: 340, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\src\Core\Pascal\PascalParser.cs, Line: 578, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #109 Path: D:\a\1\s\src\Core\Pascal\PascalParser.cs, Line: 586, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #110 Path: D:\a\1\s\src\Core\Pascal\PascalParser.cs, Line: 591, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #111 Path: D:\a\1\s\src\Core\Pascal\PascalSyntax.cs, Line: 683, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #112 Path: D:\a\1\s\src\Core\Pascal\Token.cs, Line: 37, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #113 Path: D:\a\1\s\src\Core\Pascal\Token.cs, Line: 39, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #114 Path: D:\a\1\s\src\Core\Platform.cs, Line: 361, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #115 Path: D:\a\1\s\src\Core\Platform.cs, Line: 409, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #116 Path: D:\a\1\s\src\Core\Platform.cs, Line: 560, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #117 Path: D:\a\1\s\src\Core\Platform.cs, Line: 640, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #118 Path: D:\a\1\s\src\Core\Procedure.cs, Line: 159, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #119 Path: D:\a\1\s\src\Core\Program.cs, Line: 415, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #120 Path: D:\a\1\s\src\Core\Program.cs, Line: 422, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #121 Path: D:\a\1\s\src\Core\Program.cs, Line: 429, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #122 Path: D:\a\1\s\src\Core\Rational.cs, Line: 122, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #123 Path: D:\a\1\s\src\Core\Rtl\RtlCluster.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #124 Path: D:\a\1\s\src\Core\SegmentMap.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #125 Path: D:\a\1\s\src\Core\Serialization\ArgumentDeserializer.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #126 Path: D:\a\1\s\src\Core\Serialization\ArrayType_v1.cs, Line: 46, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #127 Path: D:\a\1\s\src\Core\Serialization\Json\JsonWriter.cs, Line: 98, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #128 Path: D:\a\1\s\src\Core\Serialization\ProjectLoader.cs, Line: 177, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #129 Path: D:\a\1\s\src\Core\Serialization\ProjectLoader.cs, Line: 182, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #130 Path: D:\a\1\s\src\Core\Serialization\ProjectLoader.cs, Line: 207, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #131 Path: D:\a\1\s\src\Core\Serialization\ProjectLoader.cs, Line: 212, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #132 Path: D:\a\1\s\src\Core\Serialization\ProjectLoader.cs, Line: 519, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #133 Path: D:\a\1\s\src\Core\Serialization\ProjectLoader.cs, Line: 863, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #134 Path: D:\a\1\s\src\Core\Serialization\ProjectSaver.cs, Line: 245, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #135 Path: D:\a\1\s\src\Core\Serialization\SerializedTypedef.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #136 Path: D:\a\1\s\src\Core\Services\ITypeLibraryLoaderService.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #137 Path: D:\a\1\s\src\Core\Storage.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #138 Path: D:\a\1\s\src\Core\Storage.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #139 Path: D:\a\1\s\src\Core\Storage.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 102, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #141 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #142 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 121, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #143 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 127, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #144 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 133, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #145 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 147, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #146 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 156, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #147 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 161, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #148 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 205, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #149 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #150 Path: D:\a\1\s\src\Core\TypedDataDumper.cs, Line: 96, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #151 Path: D:\a\1\s\src\Core\TypedServiceProvider.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #152 Path: D:\a\1\s\src\Core\TypeLibraryDeserializer.cs, Line: 149, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #153 Path: D:\a\1\s\src\Core\Types\DataType.cs, Line: 119, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #154 Path: D:\a\1\s\src\Core\Types\DataTypeComparer.cs, Line: 216, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #155 Path: D:\a\1\s\src\Core\Types\TypeStore.cs, Line: 82, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #156 Path: D:\a\1\s\src\Core\Types\Unifier.cs, Line: 619, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #157 Path: D:\a\1\s\src\Core\Types\UnionType.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Decompiler
    #158 Path: D:\a\1\s\src\Decompiler\Analysis\CallApplicationBuilder.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #159 Path: D:\a\1\s\src\Decompiler\Analysis\ConditionCodeEliminator.cs, Line: 574, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #160 Path: D:\a\1\s\src\Decompiler\Analysis\ConstDivisionImplementedByMultiplication.cs, Line: 152, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #161 Path: D:\a\1\s\src\Decompiler\Analysis\DataFlowAnalysis.cs, Line: 302, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #162 Path: D:\a\1\s\src\Decompiler\Analysis\DataFlowAnalysis.cs, Line: 525, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #163 Path: D:\a\1\s\src\Decompiler\Analysis\DataFlowAnalysis.cs, Line: 87, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #164 Path: D:\a\1\s\src\Decompiler\Analysis\SsaIdentifierCollection.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #165 Path: D:\a\1\s\src\Decompiler\Analysis\SsaMutator.cs, Line: 82, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #166 Path: D:\a\1\s\src\Decompiler\Analysis\SsaState.cs, Line: 194, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #167 Path: D:\a\1\s\src\Decompiler\Analysis\SsaState.cs, Line: 205, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #168 Path: D:\a\1\s\src\Decompiler\Analysis\SsaState.cs, Line: 247, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #169 Path: D:\a\1\s\src\Decompiler\Analysis\SsaState.cs, Line: 268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\src\Decompiler\Analysis\SsaState.cs, Line: 281, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #171 Path: D:\a\1\s\src\Decompiler\Analysis\SsaTransform.cs, Line: 866, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #172 Path: D:\a\1\s\src\Decompiler\Analysis\StackPointerBackpropagator.cs, Line: 199, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #173 Path: D:\a\1\s\src\Decompiler\Decompiler.cs, Line: 608, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #174 Path: D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs, Line: 571, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #175 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 372, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #176 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 382, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #177 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 403, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #178 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 411, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #179 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 425, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #180 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 434, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #181 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 442, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #182 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 453, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #183 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 460, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #184 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 864, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #185 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 895, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #186 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 905, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #187 Path: D:\a\1\s\src\Decompiler\Loading\DccSignatureLoader.cs, Line: 913, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #188 Path: D:\a\1\s\src\Decompiler\Loading\Loader.cs, Line: 417, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #189 Path: D:\a\1\s\src\Decompiler\Loading\Loader.cs, Line: 429, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #190 Path: D:\a\1\s\src\Decompiler\Loading\Loader.cs, Line: 441, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #191 Path: D:\a\1\s\src\Decompiler\Loading\Loader.cs, Line: 472, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #192 Path: D:\a\1\s\src\Decompiler\Loading\UnpackingService.cs, Line: 109, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #193 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #194 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #195 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 154, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #196 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #197 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #199 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 387, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #200 Path: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs, Line: 428, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #201 Path: D:\a\1\s\src\Decompiler\Scanning\BackwardSlicer.cs, Line: 732, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #202 Path: D:\a\1\s\src\Decompiler\Scanning\BackwardSlicer.cs, Line: 732, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\src\Decompiler\Scanning\BlockCloner.cs, Line: 107, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #204 Path: D:\a\1\s\src\Decompiler\Scanning\BlockWorkitem.cs, Line: 1284, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #205 Path: D:\a\1\s\src\Decompiler\Scanning\BlockWorkitem.cs, Line: 929, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #206 Path: D:\a\1\s\src\Decompiler\Scanning\BlockWorkitem.cs, Line: 935, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #207 Path: D:\a\1\s\src\Decompiler\Scanning\BlockWorkitem.cs, Line: 938, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #208 Path: D:\a\1\s\src\Decompiler\Scanning\HeuristicDisassembler.cs, Line: 191, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #209 Path: D:\a\1\s\src\Decompiler\Scanning\ImageSymbolWorkItem.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #210 Path: D:\a\1\s\src\Decompiler\Scanning\RegexpBuilder.cs, Line: 852, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #211 Path: D:\a\1\s\src\Decompiler\Scanning\RtlBlock.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #212 Path: D:\a\1\s\src\Decompiler\Scanning\Scanner.cs, Line: 440, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #213 Path: D:\a\1\s\src\Decompiler\Scanning\ScannerInLinq.cs, Line: 319, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #214 Path: D:\a\1\s\src\Decompiler\Scanning\ScannerInLinq.cs, Line: 512, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #215 Path: D:\a\1\s\src\Decompiler\Scanning\ScannerInLinq.cs, Line: 514, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #216 Path: D:\a\1\s\src\Decompiler\Scanning\ScannerInLinq.cs, Line: 540, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #217 Path: D:\a\1\s\src\Decompiler\Scanning\ScannerInLinq.cs, Line: 579, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #218 Path: D:\a\1\s\src\Decompiler\Scanning\ShingledScanner.cs, Line: 671, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #219 Path: D:\a\1\s\src\Decompiler\Scanning\VarargsFormatScanner.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #220 Path: D:\a\1\s\src\Decompiler\Scanning\VarargsFormatScanner.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #221 Path: D:\a\1\s\src\Decompiler\Scanning\VectorBuilder.cs, Line: 258, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #222 Path: D:\a\1\s\src\Decompiler\Structure\StructureAnalysis.cs, Line: 1276, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #223 Path: D:\a\1\s\src\Decompiler\Structure\StructureAnalysis.cs, Line: 1382, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #224 Path: D:\a\1\s\src\Decompiler\Structure\StructureAnalysis.cs, Line: 556, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #225 Path: D:\a\1\s\src\Decompiler\Structure\StructureAnalysis.cs, Line: 937, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #226 Path: D:\a\1\s\src\Decompiler\Structure\StructureAnalysis.cs, Line: 978, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #227 Path: D:\a\1\s\src\Decompiler\Typing\ArrayExpressionMatcher.cs, Line: 114, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #228 Path: D:\a\1\s\src\Decompiler\Typing\ConstantPointerAnalysis.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #229 Path: D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs, Line: 120, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #230 Path: D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs, Line: 422, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #231 Path: D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs, Line: 428, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #232 Path: D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs, Line: 801, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #233 Path: D:\a\1\s\src\Decompiler\Typing\TraitCollector.cs, Line: 118, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #234 Path: D:\a\1\s\src\Decompiler\Typing\TraitCollector.cs, Line: 578, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #235 Path: D:\a\1\s\src\Decompiler\Typing\TraitCollector.cs, Line: 647, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #236 Path: D:\a\1\s\src\Decompiler\Typing\TraitCollector.cs, Line: 87, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #237 Path: D:\a\1\s\src\Decompiler\Typing\TypeTransformer.cs, Line: 235, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: PowerPC
    #238 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcArchitecture.cs, Line: 295, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #239 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcCallingConvention.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #240 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstruction.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #241 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #242 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #243 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 126, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #244 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 133, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #245 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 142, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #246 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 147, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #247 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #248 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #249 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #250 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #251 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #252 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcInstructionComparer.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #253 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Alu.cs, Line: 617, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #254 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Alu.cs, Line: 689, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #255 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Alu.cs, Line: 715, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #256 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #257 Path: D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Mem.cs, Line: 453, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: M68k
    #258 Path: D:\a\1\s\src\Arch\M68k\AddressOperand.cs, Line: 48, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #259 Path: D:\a\1\s\src\Arch\M68k\Assembler\Lexer.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #260 Path: D:\a\1\s\src\Arch\M68k\Assembler\Lexer.cs, Line: 297, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #261 Path: D:\a\1\s\src\Arch\M68k\Assembler\Lexer.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #262 Path: D:\a\1\s\src\Arch\M68k\Assembler\Lexer.cs, Line: 319, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: D:\a\1\s\src\Arch\M68k\Assembler\Lexer.cs, Line: 322, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #264 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #265 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #266 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 120, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #268 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #270 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 141, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #271 Path: D:\a\1\s\src\Arch\M68k\Assembler\M68kAssembler.cs, Line: 148, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #272 Path: D:\a\1\s\src\Arch\M68k\M68kArchitecture.cs, Line: 109, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #273 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 1419, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #274 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 1457, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #275 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 1489, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #276 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 1725, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #277 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #278 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2417, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #279 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2421, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #280 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2428, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #281 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2432, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #282 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2440, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #283 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2444, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #284 Path: D:\a\1\s\src\Arch\M68k\M68kDisassembler.cs, Line: 2449, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #285 Path: D:\a\1\s\src\Arch\M68k\M68kInstruction.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #286 Path: D:\a\1\s\src\Arch\M68k\M68kInstruction.cs, Line: 58, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #287 Path: D:\a\1\s\src\Arch\M68k\OperandFormatDecoder.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #288 Path: D:\a\1\s\src\Arch\M68k\OperandFormatDecoder.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #289 Path: D:\a\1\s\src\Arch\M68k\Rewriter.Alu.cs, Line: 237, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #290 Path: D:\a\1\s\src\Arch\M68k\Rewriter.Alu.cs, Line: 548, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\src\Arch\M68k\Rewriter.Alu.cs, Line: 554, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Arm
    #292 Path: D:\a\1\s\src\Arch\Arm\AArch32\Arm32CallingConvention.cs, Line: 98, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #293 Path: D:\a\1\s\src\Arch\Arm\AArch32\ArmRewriter.cs, Line: 960, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #294 Path: D:\a\1\s\src\Arch\Arm\AArch64\A64Rewriter.cs, Line: 360, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Sparc
    #295 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 102, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #296 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #298 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #300 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #301 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #302 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #303 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #304 Path: D:\a\1\s\src\Arch\Sparc\SparcInstructionComparer.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #305 Path: D:\a\1\s\src\Arch\Sparc\SparcRewriter.cs, Line: 298, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #306 Path: D:\a\1\s\src\Arch\Sparc\SparcRewriter.cs, Line: 324, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: X86
    #307 Path: D:\a\1\s\src\Arch\X86\Assembler\ModRmBuilder.cs, Line: 228, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #308 Path: D:\a\1\s\src\Arch\X86\Assembler\OperandParser.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #309 Path: D:\a\1\s\src\Arch\X86\Assembler\OperandParser.cs, Line: 74, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #310 Path: D:\a\1\s\src\Arch\X86\Assembler\OperandParser.cs, Line: 82, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #311 Path: D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs, Line: 1234, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #312 Path: D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs, Line: 1252, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #313 Path: D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs, Line: 1270, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #314 Path: D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs, Line: 583, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #315 Path: D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs, Line: 957, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #316 Path: D:\a\1\s\src\Arch\X86\Assembler\X86TextAssembler.cs, Line: 140, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #317 Path: D:\a\1\s\src\Arch\X86\Assembler\X86TextAssembler.cs, Line: 203, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #318 Path: D:\a\1\s\src\Arch\X86\Assembler\X86TextAssembler.cs, Line: 205, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #319 Path: D:\a\1\s\src\Arch\X86\OperandRewriter.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #320 Path: D:\a\1\s\src\Arch\X86\X86Disassembler.cs, Line: 384, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #321 Path: D:\a\1\s\src\Arch\X86\X86Disassembler.cs, Line: 555, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #322 Path: D:\a\1\s\src\Arch\X86\X86Emulator.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #323 Path: D:\a\1\s\src\Arch\X86\X86InstructionComparer.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #324 Path: D:\a\1\s\src\Arch\X86\X86ProcessorArchitecture.cs, Line: 229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #325 Path: D:\a\1\s\src\Arch\X86\X86Rewriter.Alu.cs, Line: 548, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #326 Path: D:\a\1\s\src\Arch\X86\X86Rewriter.Alu.cs, Line: 677, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #327 Path: D:\a\1\s\src\Arch\X86\X86Rewriter.cs, Line: 651, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Z80
    #328 Path: D:\a\1\s\src\Arch\Z80\MemoryOperand.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #329 Path: D:\a\1\s\src\Arch\Z80\MemoryOperand.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #330 Path: D:\a\1\s\src\Arch\Z80\Z80InstructionComparer.cs, Line: 134, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #331 Path: D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs, Line: 529, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Mos6502
    #332 Path: D:\a\1\s\src\Arch\Mos6502\Mos65816Rewriter.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Pdp11
    #333 Path: D:\a\1\s\src\Arch\Pdp11\AddressOperand.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #334 Path: D:\a\1\s\src\Arch\Pdp11\Assembler\Lexer.cs, Line: 264, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #335 Path: D:\a\1\s\src\Arch\Pdp11\Assembler\Lexer.cs, Line: 271, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #336 Path: D:\a\1\s\src\Arch\Pdp11\Assembler\Pdp11Assembler.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #337 Path: D:\a\1\s\src\Arch\Pdp11\MemoryOperand.cs, Line: 86, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #338 Path: D:\a\1\s\src\Arch\Pdp11\MemoryOperand.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #339 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #340 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #341 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 120, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #342 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #343 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #344 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #345 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #346 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #347 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11InstructionComparer.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #348 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11Rewriter.Alu.cs, Line: 317, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #349 Path: D:\a\1\s\src\Arch\Pdp11\Pdp11Rewriter.Alu.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Mips
    #350 Path: D:\a\1\s\src\Arch\Mips\Mips16eRewriter.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #351 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #352 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #353 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #354 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #355 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #356 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #357 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #358 Path: D:\a\1\s\src\Arch\Mips\MipsInstructionComparer.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #359 Path: D:\a\1\s\src\Arch\Mips\MipsProcessorArchitecture.cs, Line: 272, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #360 Path: D:\a\1\s\src\Arch\Mips\MipsProcessorArchitecture.cs, Line: 282, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #361 Path: D:\a\1\s\src\Arch\Mips\MipsProcessorArchitecture.cs, Line: 293, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #362 Path: D:\a\1\s\src\Arch\Mips\MipsProcessorArchitecture.cs, Line: 304, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #363 Path: D:\a\1\s\src\Arch\Mips\MipsRewriter.cs, Line: 384, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #364 Path: D:\a\1\s\src\Arch\Mips\MipsRewriter.cs, Line: 470, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #365 Path: D:\a\1\s\src\Arch\Mips\MipsRewriter.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Vax
    #366 Path: D:\a\1\s\src\Arch\Vax\VaxInstructionComparer.cs, Line: 54, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #367 Path: D:\a\1\s\src\Arch\Vax\VaxInstructionComparer.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Xtensa
    #368 Path: D:\a\1\s\src\Arch\Xtensa\XtensaRewriter.Control.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #369 Path: D:\a\1\s\src\Arch\Xtensa\XtensaRewriter.Control.cs, Line: 177, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #370 Path: D:\a\1\s\src\Arch\Xtensa\XtensaRewriter.Control.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Avr
    #371 Path: D:\a\1\s\src\Arch\Avr\Avr8Architecture.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #372 Path: D:\a\1\s\src\Arch\Avr\Avr8Rewriter.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #373 Path: D:\a\1\s\src\Arch\Avr\Avr8Rewriter.cs, Line: 260, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: RiscV
    #374 Path: D:\a\1\s\src\Arch\RiscV\RiscVCallingConvention.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #375 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstruction.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #376 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstruction.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #377 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #378 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #379 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 54, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #380 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #381 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #382 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 89, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #383 Path: D:\a\1\s\src\Arch\RiscV\RiscVInstructionComparer.cs, Line: 97, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: SuperH
    #384 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #385 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #386 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #387 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 62, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #388 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 63, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #389 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 65, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #390 Path: D:\a\1\s\src\Arch\SuperH\MemoryOperand.cs, Line: 66, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #391 Path: D:\a\1\s\src\Arch\SuperH\SuperHRewriter.cs, Line: 75, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tlcs
    #392 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Disassembler.cs, Line: 417, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #393 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Disassembler.cs, Line: 426, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #394 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Disassembler.cs, Line: 509, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #395 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Disassembler.cs, Line: 536, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #396 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90InstructionComparer.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #397 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90InstructionComparer.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #398 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90InstructionComparer.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #399 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90InstructionComparer.cs, Line: 126, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #400 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90InstructionComparer.cs, Line: 134, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #401 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90InstructionComparer.cs, Line: 97, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #402 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Rewriter.Control.cs, Line: 96, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #403 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Rewriter.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #404 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs90\Tlcs90Rewriter.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #405 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #406 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 125, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 133, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #410 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 146, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #411 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 54, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #412 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #413 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #414 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 78, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #415 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900InstructionComparer.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #416 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900Rewriter.Control.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #417 Path: D:\a\1\s\src\Arch\Tlcs\Tlcs900\Tlcs900Rewriter.cs, Line: 75, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Alpha
    #418 Path: D:\a\1\s\src\Arch\Alpha\AlphaRewriter.cs, Line: 281, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #419 Path: D:\a\1\s\src\Arch\Alpha\AlphaRewriter.cs, Line: 74, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: AmigaOS
    #420 Path: D:\a\1\s\src\Environments\AmigaOS\AmigaOSPlatform.cs, Line: 235, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #421 Path: D:\a\1\s\src\Environments\AmigaOS\FuncsFileParser.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: C64
    #422 Path: D:\a\1\s\src\Environments\C64\C64BasicRewriter.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #423 Path: D:\a\1\s\src\Environments\C64\C64BasicRewriter.cs, Line: 191, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #424 Path: D:\a\1\s\src\Environments\C64\C64Platform.cs, Line: 96, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: ZX81
    #425 Path: D:\a\1\s\src\Environments\ZX81\ZX81Environment.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: MacOS
    #426 Path: D:\a\1\s\src\Environments\MacOS\Classic\ConstantEvaluator.cs, Line: 102, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #427 Path: D:\a\1\s\src\Environments\MacOS\Classic\ConstantEvaluator.cs, Line: 110, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #428 Path: D:\a\1\s\src\Environments\MacOS\Classic\InlineCodeInterpreter.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #429 Path: D:\a\1\s\src\Environments\MacOS\Classic\InlineCodeInterpreter.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #430 Path: D:\a\1\s\src\Environments\MacOS\Classic\MacOSClassic.cs, Line: 120, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #431 Path: D:\a\1\s\src\Environments\MacOS\Classic\ResourceFork.cs, Line: 276, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #432 Path: D:\a\1\s\src\Environments\MacOS\Classic\ResourceFork.cs, Line: 279, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #433 Path: D:\a\1\s\src\Environments\MacOS\Classic\ResourceFork.cs, Line: 280, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #434 Path: D:\a\1\s\src\Environments\MacOS\Classic\ResourceFork.cs, Line: 281, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Msdos
    #435 Path: D:\a\1\s\src\Environments\Msdos\Msdos386Platform.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #436 Path: D:\a\1\s\src\Environments\Msdos\MsdosPlatform.cs, Line: 155, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #437 Path: D:\a\1\s\src\Environments\Msdos\StartupFinder.cs, Line: 260, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: RiscOS
    #438 Path: D:\a\1\s\src\Environments\RiscOS\RiscOSPlatform.cs, Line: 106, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Ps3
    #439 Path: D:\a\1\s\src\Environments\Ps3\Ps3Platform.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: SysV
    #440 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\ArchSpecificFactory.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #441 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\ArmCallingConvention.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #442 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\MipsCallingConvention.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #443 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\MipsCallingConvention.cs, Line: 72, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #444 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\MipsCallingConvention.cs, Line: 93, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #445 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\PowerPcCallingConvention.cs, Line: 110, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #446 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\PowerPcCallingConvention.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #447 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\SparcCallingConvention.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #448 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\SuperHCallingConvention.cs, Line: 102, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #449 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\X86_64CallingConvention.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #450 Path: D:\a\1\s\src\Environments\SysV\ArchSpecific\X86_64CallingConvention.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #451 Path: D:\a\1\s\src\Environments\SysV\GccMangledNameParser.cs, Line: 152, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #452 Path: D:\a\1\s\src\Environments\SysV\GccMangledNameParser.cs, Line: 156, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #453 Path: D:\a\1\s\src\Environments\SysV\GccMangledNameParser.cs, Line: 393, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #454 Path: D:\a\1\s\src\Environments\SysV\SysVPlatform.cs, Line: 172, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #455 Path: D:\a\1\s\src\Environments\SysV\SysVPlatform.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Cpm
    #456 Path: D:\a\1\s\src\Environments\Cpm\CpmPlatform.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: AmigaOS.Design
    #457 Path: D:\a\1\s\src\Environments\AmigaOS.Design\AmigaOSPropertiesInteractor.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Windows
    #458 Path: D:\a\1\s\src\Environments\Windows\Arch\MipsCallingConvention.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #459 Path: D:\a\1\s\src\Environments\Windows\Arch\MipsCallingConvention.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #460 Path: D:\a\1\s\src\Environments\Windows\Arch\X86_64CallingConvention.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #461 Path: D:\a\1\s\src\Environments\Windows\Arch\X86_64CallingConvention.cs, Line: 88, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #462 Path: D:\a\1\s\src\Environments\Windows\BorlandMangledNamedParser.cs, Line: 251, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #463 Path: D:\a\1\s\src\Environments\Windows\ModuleDefinitionLoader.cs, Line: 68, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #464 Path: D:\a\1\s\src\Environments\Windows\MsMangledNameParser.cs, Line: 282, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #465 Path: D:\a\1\s\src\Environments\Windows\SignatureGuesser.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #466 Path: D:\a\1\s\src\Environments\Windows\SignatureGuesser.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #467 Path: D:\a\1\s\src\Environments\Windows\Win_x86_64_Platform.cs, Line: 140, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #468 Path: D:\a\1\s\src\Environments\Windows\Win16Platform.cs, Line: 106, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #469 Path: D:\a\1\s\src\Environments\Windows\Win16Platform.cs, Line: 128, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #470 Path: D:\a\1\s\src\Environments\Windows\Win32M68kPlatform.cs, Line: 72, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #471 Path: D:\a\1\s\src\Environments\Windows\Win32MipsPlatform.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #472 Path: D:\a\1\s\src\Environments\Windows\Win32Platform.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #473 Path: D:\a\1\s\src\Environments\Windows\Win32Platform.cs, Line: 193, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #474 Path: D:\a\1\s\src\Environments\Windows\Win32PpcPlatform.cs, Line: 105, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #475 Path: D:\a\1\s\src\Environments\Windows\Win32ThumbPlatform.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Trs80
    #476 Path: D:\a\1\s\src\Environments\Trs80\Trs80Platform.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: hunktool
    #477 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 140, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #478 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 186, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #479 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 191, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #480 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 198, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #481 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 203, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #482 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 215, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #483 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 232, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #484 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 250, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #485 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 264, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #486 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 269, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #487 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 272, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #488 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #489 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #490 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 374, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #491 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 376, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #492 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 381, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #493 Path: D:\a\1\s\src\tools\hunktool\HunkShow.cs, Line: 390, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #494 Path: D:\a\1\s\src\tools\hunktool\SignatureGenerator.cs, Line: 159, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: BinHex
    #495 Path: D:\a\1\s\src\ImageLoaders\BinHex\BinHexDecoder.cs, Line: 167, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #496 Path: D:\a\1\s\src\ImageLoaders\BinHex\Cpt\CompactProArchive.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #497 Path: D:\a\1\s\src\ImageLoaders\BinHex\Cpt\CompactProArchive.cs, Line: 120, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #498 Path: D:\a\1\s\src\ImageLoaders\BinHex\Cpt\CompactProArchive.cs, Line: 280, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #499 Path: D:\a\1\s\src\ImageLoaders\BinHex\Cpt\CompactProArchive.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #500 Path: D:\a\1\s\src\ImageLoaders\BinHex\Cpt\CompactProArchive.cs, Line: 95, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #501 Path: D:\a\1\s\src\ImageLoaders\BinHex\Cpt\CptCompressor.cs, Line: 296, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Elf
    #502 Path: D:\a\1\s\src\ImageLoaders\Elf\DynamicSectionRenderer.cs, Line: 100, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #503 Path: D:\a\1\s\src\ImageLoaders\Elf\DynamicSectionRenderer.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #504 Path: D:\a\1\s\src\ImageLoaders\Elf\DynamicSectionRenderer.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #505 Path: D:\a\1\s\src\ImageLoaders\Elf\DynamicSectionRenderer.cs, Line: 200, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #506 Path: D:\a\1\s\src\ImageLoaders\Elf\DynamicSectionRenderer.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #507 Path: D:\a\1\s\src\ImageLoaders\Elf\DynamicSectionRenderer.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #508 Path: D:\a\1\s\src\ImageLoaders\Elf\ElfLoader.cs, Line: 400, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #509 Path: D:\a\1\s\src\ImageLoaders\Elf\ElfLoader.cs, Line: 667, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #510 Path: D:\a\1\s\src\ImageLoaders\Elf\ElfLoader32.cs, Line: 124, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #511 Path: D:\a\1\s\src\ImageLoaders\Elf\ElfLoader32.cs, Line: 326, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #512 Path: D:\a\1\s\src\ImageLoaders\Elf\Relocators\SparcRelocator.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #513 Path: D:\a\1\s\src\ImageLoaders\Elf\Relocators\x86Relocator.cs, Line: 134, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: MachO
    #514 Path: D:\a\1\s\src\ImageLoaders\MachO\Parser.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #515 Path: D:\a\1\s\src\ImageLoaders\MachO\Parser.cs, Line: 395, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #516 Path: D:\a\1\s\src\ImageLoaders\MachO\Parser.cs, Line: 465, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Hunk
    #517 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 154, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #518 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 225, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #519 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 371, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #520 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 380, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #521 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 381, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #522 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 391, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #523 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 411, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #524 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 420, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #525 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 421, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #526 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 429, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #527 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 456, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #528 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 466, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #529 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 474, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #530 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 498, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #531 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 506, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #532 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 516, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #533 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 572, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #534 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 581, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #535 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 586, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #536 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 725, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #537 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 746, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #538 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 750, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #539 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 759, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #540 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 798, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #541 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkFileParser.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #542 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkLoader.cs, Line: 167, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #543 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkRelocator.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #544 Path: D:\a\1\s\src\ImageLoaders\Hunk\HunkRelocator.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #545 Path: D:\a\1\s\src\ImageLoaders\Hunk\Hunks.cs, Line: 91, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: MzExe
    #546 Path: D:\a\1\s\src\ImageLoaders\MzExe\CodeView\CodeViewLoader.cs, Line: 130, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #547 Path: D:\a\1\s\src\ImageLoaders\MzExe\CodeView\CodeViewLoader.cs, Line: 164, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #548 Path: D:\a\1\s\src\ImageLoaders\MzExe\MsdosImageLoader.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #549 Path: D:\a\1\s\src\ImageLoaders\MzExe\NeImageLoader.cs, Line: 531, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #550 Path: D:\a\1\s\src\ImageLoaders\MzExe\NeImageLoader.cs, Line: 766, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #551 Path: D:\a\1\s\src\ImageLoaders\MzExe\NeImageLoader.cs, Line: 823, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #552 Path: D:\a\1\s\src\ImageLoaders\MzExe\NeImageLoader.cs, Line: 830, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #553 Path: D:\a\1\s\src\ImageLoaders\MzExe\Pe\ResourceLoader.cs, Line: 205, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #554 Path: D:\a\1\s\src\ImageLoaders\MzExe\PeImageLoader.cs, Line: 204, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #555 Path: D:\a\1\s\src\ImageLoaders\MzExe\PeImageLoader.cs, Line: 225, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #556 Path: D:\a\1\s\src\ImageLoaders\MzExe\PeImageLoader.cs, Line: 249, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #557 Path: D:\a\1\s\src\ImageLoaders\MzExe\PeImageLoader.cs, Line: 269, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #558 Path: D:\a\1\s\src\ImageLoaders\MzExe\PeImageLoader.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #559 Path: D:\a\1\s\src\ImageLoaders\MzExe\PeImageLoader.cs, Line: 367, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #560 Path: D:\a\1\s\src\ImageLoaders\MzExe\PkLiteUnpacker.cs, Line: 63, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #561 Path: D:\a\1\s\src\ImageLoaders\MzExe\PkLiteUnpacker.cs, Line: 68, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Dol
    #562 Path: D:\a\1\s\src\ImageLoaders\Dol\DolLoader.cs, Line: 128, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #563 Path: D:\a\1\s\src\ImageLoaders\Dol\DolLoader.cs, Line: 144, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: LLVM
    #564 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 152, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #565 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 170, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #566 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 174, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #567 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 190, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #568 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 401, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #569 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 72, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #570 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMInstructionTranslator.cs, Line: 93, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #571 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMLexer.cs, Line: 403, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #572 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMParser.cs, Line: 846, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #573 Path: D:\a\1\s\src\ImageLoaders\Llvm\LLVMSyntax.cs, Line: 308, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #574 Path: D:\a\1\s\src\ImageLoaders\Llvm\ProgramBuilder.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #575 Path: D:\a\1\s\src\ImageLoaders\Llvm\ProgramBuilder.cs, Line: 192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #576 Path: D:\a\1\s\src\ImageLoaders\Llvm\TypeTranslator.cs, Line: 65, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: UnitTests
    #577 Path: D:\a\1\s\src\UnitTests\Analysis\DataFlowAnalysisTests2.cs, Line: 86, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #578 Path: D:\a\1\s\src\UnitTests\Analysis\IndirectCallRewriterTests.cs, Line: 152, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #579 Path: D:\a\1\s\src\UnitTests\Analysis\SsaLivenessTests.cs, Line: 58, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #580 Path: D:\a\1\s\src\UnitTests\Analysis\SsaTransformTests.cs, Line: 1778, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #581 Path: D:\a\1\s\src\UnitTests\Analysis\SsaTransformTests.cs, Line: 3316, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #582 Path: D:\a\1\s\src\UnitTests\Analysis\TrashedRegisterFinderTests.cs, Line: 157, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #583 Path: D:\a\1\s\src\UnitTests\Analysis\TrashedRegisterFinderTests.cs, Line: 96, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #584 Path: D:\a\1\s\src\UnitTests\Analysis\ValuePropagationTests.cs, Line: 100, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #585 Path: D:\a\1\s\src\UnitTests\Arch\ArchTestBase.cs, Line: 136, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #586 Path: D:\a\1\s\src\UnitTests\Arch\ArchTestBase.cs, Line: 142, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #587 Path: D:\a\1\s\src\UnitTests\Arch\ArchTestBase.cs, Line: 169, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #588 Path: D:\a\1\s\src\UnitTests\Arch\Arm\A32DisassemblerTests.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #589 Path: D:\a\1\s\src\UnitTests\Arch\RewriterTestBase.cs, Line: 107, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #590 Path: D:\a\1\s\src\UnitTests\Arch\RewriterTestBase.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #591 Path: D:\a\1\s\src\UnitTests\Arch\Sparc\SparcRewriterTests.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #592 Path: D:\a\1\s\src\UnitTests\Arch\X86\X86DisassemblerTests.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #593 Path: D:\a\1\s\src\UnitTests\Arch\X86\X86InstructionComparer.Tests.cs, Line: 41, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #594 Path: D:\a\1\s\src\UnitTests\Arch\X86\X86InstructionComparer.Tests.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #595 Path: D:\a\1\s\src\UnitTests\Core\Lib\SuffixArrayTests.cs, Line: 72, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #596 Path: D:\a\1\s\src\UnitTests\Core\Lib\SuffixArrayTests.cs, Line: 73, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #597 Path: D:\a\1\s\src\UnitTests\Environments\SysV\GccMangledNameParserTests.cs, Line: 121, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #598 Path: D:\a\1\s\src\UnitTests\FileUnitTester.cs, Line: 102, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #599 Path: D:\a\1\s\src\UnitTests\FileUnitTester.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #600 Path: D:\a\1\s\src\UnitTests\FileUnitTester.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #601 Path: D:\a\1\s\src\UnitTests\FileUnitTester.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #602 Path: D:\a\1\s\src\UnitTests\FileUnitTester.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #603 Path: D:\a\1\s\src\UnitTests\ImageLoaders\MzExe\PeImageLoaderTests.cs, Line: 340, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #604 Path: D:\a\1\s\src\UnitTests\ImageLoaders\MzExe\PeImageLoaderTests.cs, Line: 373, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #605 Path: D:\a\1\s\src\UnitTests\Mocks\FakeArchitecture.cs, Line: 138, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #606 Path: D:\a\1\s\src\UnitTests\Mocks\FakeDecompilerEventListener.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #607 Path: D:\a\1\s\src\UnitTests\Mocks\FakePlatform.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #608 Path: D:\a\1\s\src\UnitTests\Mocks\ProcedureBuilder.cs, Line: 252, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #609 Path: D:\a\1\s\src\UnitTests\Scanning\GlobalDataWorkItemTests.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #610 Path: D:\a\1\s\src\UnitTests\Scanning\ValueSetEvaluatorTests.cs, Line: 121, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #611 Path: D:\a\1\s\src\UnitTests\Structure\StructureAnalysisTests.cs, Line: 59, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #612 Path: D:\a\1\s\src\UnitTests\TestSerializedTypeRenderer.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #613 Path: D:\a\1\s\src\UnitTests\Typing\Trait.cs, Line: 100, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #614 Path: D:\a\1\s\src\UnitTests\Typing\Trait.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #615 Path: D:\a\1\s\src\UnitTests\Typing\Trait.cs, Line: 198, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #616 Path: D:\a\1\s\src\UnitTests\Typing\Trait.cs, Line: 277, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #617 Path: D:\a\1\s\src\UnitTests\Typing\Trait.cs, Line: 293, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #618 Path: D:\a\1\s\src\UnitTests\Typing\Trait.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: CmdLine
    #619 Path: D:\a\1\s\src\Drivers\CmdLine\CmdLineDriver.cs, Line: 240, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #620 Path: D:\a\1\s\src\Drivers\CmdLine\CmdLineDriver.cs, Line: 249, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: i8051
    #621 Path: D:\a\1\s\src\Arch\i8051\i8051Rewriter.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Gui
    #622 Path: D:\a\1\s\src\Gui\AddressNavigator.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #623 Path: D:\a\1\s\src\Gui\Forms\CallHierarchyInteractor.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #624 Path: D:\a\1\s\src\Gui\Forms\MainFormInteractor.cs, Line: 361, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #625 Path: D:\a\1\s\src\Gui\Forms\MainFormInteractor.cs, Line: 377, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #626 Path: D:\a\1\s\src\Gui\Forms\MainFormInteractor.cs, Line: 380, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #627 Path: D:\a\1\s\src\Gui\Forms\MainFormInteractor.cs, Line: 397, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #628 Path: D:\a\1\s\src\Gui\Forms\MainFormInteractor.cs, Line: 689, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #629 Path: D:\a\1\s\src\Gui\Forms\MainFormInteractor.cs, Line: 887, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #630 Path: D:\a\1\s\src\Gui\Forms\ScannedPageInteractor.cs, Line: 147, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #631 Path: D:\a\1\s\src\Gui\Forms\ScannedPageInteractor.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #632 Path: D:\a\1\s\src\Gui\Forms\TextEncodingInteractor.cs, Line: 39, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #633 Path: D:\a\1\s\src\Gui\SearchService.cs, Line: 41, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #634 Path: D:\a\1\s\src\Gui\TreeNodeDesignerHost.cs, Line: 174, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: WindowsForms
    #635 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\CallGraphPane.cs, Line: 47, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #636 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\CfgBlockNode.cs, Line: 111, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #637 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\CfgBlockNode.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #638 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\CfgBlockNode.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #639 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\CodeViewInteractor.cs, Line: 298, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #640 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\CodeViewInteractor.cs, Line: 370, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #641 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\CommandMenuItem.cs, Line: 79, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #642 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\MemoryControl.cs, Line: 688, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #643 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\MemoryControl.cs, Line: 736, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #644 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\MixedCodeDataModel.SpanGenerator.cs, Line: 248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #645 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\TextPointer.cs, Line: 48, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #646 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\TextView.cs, Line: 257, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #647 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Controls\TextView.cs, Line: 268, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #648 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\DisassemblyViewInteractor.cs, Line: 124, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #649 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\AboutDialog.cs, Line: 37, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #650 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\AboutDialog.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #651 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\AddressPromptDialog.Designer.cs, Line: 104, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #652 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\ArchiveBrowserService.cs, Line: 103, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #653 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\DecompilerMenus.cs, Line: 544, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #654 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\DecompilerMenus.cs, Line: 561, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #655 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\DecompilerMenus.cs, Line: 572, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #656 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\Forms\DiagnosticsInteractor.cs, Line: 220, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #657 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\ImageSegmentPane.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #658 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\ResourceEditorService.cs, Line: 58, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #659 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\TabControlHost.cs, Line: 69, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #660 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\UiPreferenceService.cs, Line: 195, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #661 Path: D:\a\1\s\src\UserInterfaces\WindowsForms\WindowsFormsDialogFactory.cs, Line: 85, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Xbox
    #662 Path: D:\a\1\s\src\Environments\Xbox\Xbox360Platform.cs, Line: 145, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: MicrochipPIC
    #663 Path: D:\a\1\s\src\Arch\Microchip\Common\PICRegisters.cs, Line: 674, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #664 Path: D:\a\1\s\src\Arch\Microchip\Common\PICRegisters.cs, Line: 689, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #665 Path: D:\a\1\s\src\Arch\Microchip\Common\PICRegisters.cs, Line: 702, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: Microchip.Utils
    #666 Path: D:\a\1\s\src\Libraries\Microchip\Utils\PICPartsInfo.cs, Line: 154, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #667 Path: D:\a\1\s\src\Libraries\Microchip\Utils\PICPartsInfo.cs, Line: 161, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #668 Path: D:\a\1\s\src\Libraries\Microchip\Utils\XMLHelpers.cs, Line: 90, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: genPICdb
    #669 Path: D:\a\1\s\src\tools\genPICdb\Program.cs, Line: 151, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #670 Path: D:\a\1\s\src\tools\genPICdb\Program.cs, Line: 300, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #671 Path: D:\a\1\s\src\tools\genPICdb\Program.cs, Line: 479, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: PowerPC.Design
    #672 Path: D:\a\1\s\src\Arch\PowerPC.Design\PowerPCSettingsInteractor.cs, Line: 56, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: MSP430
    #673 Path: D:\a\1\s\src\Arch\MSP430\Msp430InstructionComparer.cs, Line: 50, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #674 Path: D:\a\1\s\src\Arch\MSP430\Msp430InstructionComparer.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #675 Path: D:\a\1\s\src\Arch\MSP430\Registers.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: OS2
    #676 Path: D:\a\1\s\src\Environments\OS2\OS2Platform16.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Qualcomm
    #677 Path: D:\a\1\s\src\Arch\Qualcomm\HexagonRewriter.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Snes
    #678 Path: D:\a\1\s\src\Environments\Snes\SnesParser.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #679 Path: D:\a\1\s\src\Environments\Snes\SnesParser.cs, Line: 219, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #680 Path: D:\a\1\s\src\Environments\Snes\SnesParser.cs, Line: 684, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: WebAssembly
    #681 Path: D:\a\1\s\src\ImageLoaders\WebAssembly\WasmDisassembler.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #682 Path: D:\a\1\s\src\ImageLoaders\WebAssembly\WasmEvaluator.cs, Line: 254, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: WindowsItp
    #683 Path: D:\a\1\s\src\WindowsItp\TreeViewDialog.cs, Line: 144, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R9: 503
R8: 120
R4: 27
R2: 10
R7: 9
R6: 7
R5: 5
R3: 2

--- Summary ---
Fixed ReSharper issues: 673
Fixed SonarQube issues: 41
Total fixed issues: 683

Finished in: 48 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Core\Expressions\ExpressionTypeAscenderBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core.Operators;
using Reko.Core.Types;
using System;
using System.Linq;

namespace Reko.Core.Expressions
{
    /// <summary>
    /// Collect type information by pulling type information from
    /// the leaves of expression trees to their roots.
    /// </summary>
    /// <remarks>
    ///    root
    ///   /  \ 
    /// leaf  leaf
    /// </remarks>
    public abstract class ExpressionTypeAscenderBase : ExpressionVisitor<DataType>
    {
        private readonly IPlatform platform;
        private readonly TypeFactory factory;
        private readonly StructureType globalFields;

        public ExpressionTypeAscenderBase(Program program, TypeFactory factory)
        {
            this.platform = program.Platform;
            this.globalFields = program.GlobalFields;
            this.factory = factory;
        }

        protected abstract DataType RecordDataType(DataType dt, Expression exp);
        protected abstract DataType EnsureDataType(DataType dt, Expression exp);

        public DataType VisitAddress(Address addr)
        {
            var c = addr.ToConstant();
            c.DataType = PrimitiveType.Create(Domain.Pointer, addr.DataType.BitSize);
            var dt = ExistingGlobalField(c) ?? addr.DataType;
            return RecordDataType(dt, addr);
        }

        public DataType VisitApplication(Application appl)
        {
            foreach (var a in appl.Arguments)
            {
                RecordDataType(a.Accept(this), a);
            }
            RecordDataType(appl.Procedure.Accept(this), appl.Procedure);
            var dt = RecordApplicationReturnType(appl.Procedure, appl);
            return dt;
        }

        private DataType RecordApplicationReturnType(Expression pfn, Application appl)
        {
            var dt = RecordDataType(appl.DataType, appl);
            if (pfn is ProcedureConstant pc && 
                pc.Procedure.Signature.ParametersValid)
            {
                dt = RecordDataType(pc.Procedure.Signature.ReturnValue!.DataType, appl);
            }
            return dt;
        }
        public DataType VisitArrayAccess(ArrayAccess acc)
        {
            acc.Array.Accept(this);
            acc.Index.Accept(this);
            return RecordDataType(acc.DataType, acc);
        }

        private Exception NYI(Expression e)
        {
            return new NotImplementedException(string.Format("Not implemented: {0}", e));
        }

        public DataType VisitBinaryExpression(BinaryExpression binExp)
        {
            DataType dtLeft = binExp.Left.Accept(this);
            DataType dtRight = binExp.Right.Accept(this);
            DataType dt;
            if (binExp.Operator == Operator.IAdd)
            {
                var dtField = GetPossibleFieldType(dtLeft, dtRight, binExp.Right);
                if (dtField != null)
                {
                    dt = dtField;
                }
                else
                { 
                    dt = PullSumDataType(dtLeft, dtRight);
                }
            }
            else if (binExp.Operator == Operator.ISub)
            {
                dt = PullDiffDataType(dtLeft, dtRight);
            }
            else if (binExp.Operator == Operator.And || 
                binExp.Operator == Operator.Or)
            {
                dt = PrimitiveType.CreateWord(dtLeft.BitSize).MaskDomain(Domain.Boolean | Domain.Integer | Domain.Character);
            }
            else if (
                binExp.Operator == Operator.IMul ||
                binExp.Operator == Operator.Shl ||
                binExp.Operator == Operator.IMod)
            {
                dt = PrimitiveType.CreateWord(binExp.DataType.BitSize).MaskDomain(Domain.Integer);
            }
            else if (
                binExp.Operator == Operator.SMul ||
                binExp.Operator == Operator.SDiv)
            {
                dt = PrimitiveType.CreateWord(binExp.DataType.BitSize).MaskDomain(Domain.SignedInt);
            }
            else if (
                binExp.Operator == Operator.UMul ||
                binExp.Operator == Operator.UDiv)
            {
                dt = PrimitiveType.CreateWord(binExp.DataType.BitSize).MaskDomain(Domain.UnsignedInt);
            }
            else if (binExp.Operator is ConditionalOperator ||
                binExp.Operator is CorOperator ||
                binExp.Operator is CandOperator)
            {
                dt = PrimitiveType.Bool;
            }
            else if (
                binExp.Operator == Operator.FAdd ||
                binExp.Operator == Operator.FSub ||
                binExp.Operator == Operator.FMul ||
                binExp.Operator == Operator.FDiv)
            {
                dt = PrimitiveType.Create(Domain.Real, binExp.DataType.BitSize);
            }
            else if (binExp.Operator == Operator.Shr)
            {
                dt = PrimitiveType.Create(Domain.UnsignedInt, dtLeft.BitSize);
            }
            else if (binExp.Operator == Operator.Sar)
            {
                dt = PrimitiveType.Create(Domain.SignedInt, dtLeft.BitSize);
            }
            else if (binExp.Operator == Operator.Xor ||
                     binExp.Operator == Operator.Shl)
            {
                dt = PrimitiveType.Create(Domain.Integer, dtLeft.BitSize);
            }
            else
                throw NYI(binExp);
            return RecordDataType(dt, binExp);
        }

        /// <summary>
        /// If dtLeft is a (ptr (struct ...)) and dtRight is a non-pointer
        /// constant, this could be a field access.
        /// </summary>
        /// <param name="dtLeft">Possible pointer to a structure</param>
        /// <param name="dtRight">Type of possible offset</param>
        /// <param name="right">Possible constant offset from start of structure</param>
        /// <returns>A (ptr field-type) if it was a ptr-to-struct, else null.</returns>
        private Pointer? GetPossibleFieldType(DataType dtLeft, DataType dtRight, Expression right)
        {
            if (right is Constant cOffset)
            {
                if (dtRight is PrimitiveType ptRight && ptRight.Domain != Domain.Pointer)
                {
                    int offset = cOffset.ToInt32();
                    return GetPossibleFieldType(dtLeft, offset);
                }
            }
            return null;
        }

        /// <summary>
        /// If dtLeft is a (ptr (struct ...)) and there is a field at the
        /// given offset in that structure, this could be a field access.
        /// </summary>
        /// <param name="dtLeft">Possible pointer to a structure</param>
        /// <param name="offset"></param>
        /// <returns>A (ptr field-type) if it was a ptr-to-struct, else null.</returns>
        private Pointer? GetPossibleFieldType(DataType dtLeft, int offset)
        {
            var ptrLeft = dtLeft.ResolveAs<Pointer>();
            if (ptrLeft == null)
                return null;

            var pointee = ptrLeft.Pointee;
            var strPointee = pointee.ResolveAs<StructureType>();
            if (strPointee == null)
                return null;

            var field = strPointee.Fields.LowerBound(offset);
            if (field == null)
                return null;
            // We're collecting _DataTypes_, so if we encounter
            // a TypeReference, we need to drill past it.
            var dtField = field.DataType.ResolveAs<DataType>();
            if (dtField == null)
                return null;
            // If we access beyond the start of the field, we can't have the
            // same type as the field.
            if (offset != field.Offset)
            {
                // Check if field is nested structure
                var ptrField = factory.CreatePointer(dtField, ptrLeft.BitSize);
                return GetPossibleFieldType(ptrField, offset - field.Offset);
            }
            return factory.CreatePointer(dtField, dtLeft.BitSize);
        }

        private DataType PullSumDataType(DataType dtLeft, DataType dtRight)
        {
            var ptLeft = dtLeft.ResolveAs<PrimitiveType>();
            var ptRight = dtRight.ResolveAs<PrimitiveType>();
            if (ptLeft != null && ptLeft.Domain == Domain.Pointer)
            {
                if (ptRight != null && ptRight.Domain != Domain.Pointer)
                    return PrimitiveType.Create(Domain.Pointer, dtLeft.BitSize);
            }
            if (ptLeft != null && ptLeft.IsIntegral && ptRight != null && ptRight.IsIntegral)
            {
                // According to the C language definition, the sum
                // of unsigned and signed integers is always unsigned.
                if (ptLeft.Domain == Domain.UnsignedInt)
                {
                    return ptLeft;
                }
                if (ptRight.Domain == Domain.UnsignedInt)
                {
                    return ptRight;
                }
            }
            if (dtLeft.ResolveAs<Pointer>() != null)
            {
                if (dtLeft is TypeReference)
                    return dtLeft;
                else 
                    return PrimitiveType.Create(Domain.Pointer, dtLeft.BitSize);
            }
            return dtLeft;
        }

        private DataType PullDiffDataType(DataType dtLeft, DataType dtRight)
        {
            var ptLeft = dtLeft as PrimitiveType;
            var ptRight = dtRight.ResolveAs<PrimitiveType>();
            if (ptLeft != null && ptLeft.Domain == Domain.Pointer || 
                dtLeft is Pointer)
            {
                if (ptRight != null)
                {
                    if ((ptRight.Domain & Domain.Integer) != 0)
                        return PrimitiveType.Create(Domain.Pointer, dtLeft.BitSize);
                    else if ((ptRight.Domain & Domain.Pointer) != 0)
                        return PrimitiveType.Create(Domain.SignedInt, dtLeft.BitSize);
                }
                if (dtRight is Pointer)
                    return PrimitiveType.Create(Domain.SignedInt, dtLeft.BitSize);
                // We are unable to reconcile the differences here. 
                return PrimitiveType.CreateWord(dtLeft.BitSize);
                //$TODO: should be a warning? throw new TypeInferenceException(string.Format("Pulling difference {0} and {1}", dtLeft, dtRight));
            }
            if (ptRight != null && ptRight.Domain == Domain.Pointer || 
                dtRight is Pointer)
            {
                if (ptRight != null && (ptRight.Domain & Domain.Integer) != 0)
                    return dtLeft;
                // If a dtRight is a pointer and it's being subtracted from 
                // something, then the result has to be a ptrdiff_t, i.e.
                // integer.
                if (ptLeft != null && (ptLeft.Domain & Domain.Pointer) != 0)
                    return PrimitiveType.Create(Domain.Integer, dtLeft.BitSize);
                // We are unable to reconcile the differences here. 
                return PrimitiveType.CreateWord(dtLeft.BitSize);
                //$TODO: should be a warning? throw new TypeInferenceException(string.Format("Pulling difference {0} and {1}", dtLeft, dtRight));
            }
            return dtLeft;
        }

        public DataType VisitCast(Cast cast)
        {
            cast.Expression.Accept(this);
            RecordDataType(cast.DataType, cast);
            return cast.DataType;
        }

        public DataType VisitConditionalExpression(ConditionalExpression cond)
        {
            cond.ThenExp.Accept(this);
            cond.FalseExp.Accept(this);
            cond.Condition.Accept(this);
            return RecordDataType(cond.DataType, cond);
        }

        public DataType VisitConditionOf(ConditionOf cof)
        {
            cof.Expression.Accept(this);
            RecordDataType(cof.DataType, cof);
            return cof.DataType;
        }

        public DataType VisitConstant(Constant c)
        {
            var dt = ExistingGlobalField(c) ?? c.DataType;
            return RecordDataType(dt, c);
        }

        private DataType? ExistingGlobalField(Constant c)
        {
            if (!(c.DataType is PrimitiveType pt) || (pt.Domain & Domain.Pointer) == 0)
                return null;
            var global = factory.CreatePointer(globalFields, pt.BitSize);
            return GetPossibleFieldType(global, PrimitiveType.Int32, c);
        }

        public DataType VisitConversion(Conversion conversion)
        {
            conversion.Expression.Accept(this);
            RecordDataType(conversion.DataType, conversion);
            return conversion.DataType;
        }

        public DataType VisitDereference(Dereference deref)
        {
            //$TODO: if deref.Expression is of pointer type, this
            // should be the pointeee.
            return deref.DataType;
        }

        public DataType VisitFieldAccess(FieldAccess acc)
        {
            throw new NotImplementedException();
        }

        public DataType VisitIdentifier(Identifier id)
        {
            return EnsureDataType(id.DataType, id);
        }

        public DataType VisitMemberPointerSelector(MemberPointerSelector mps)
        {
            throw new NotImplementedException();
        }

        public DataType VisitMemoryAccess(MemoryAccess access)
        {
            return VisitMemoryAccessCommon(access, access.EffectiveAddress);
        }

        public DataType VisitMemoryAccessCommon(Expression access, Expression ea)
        {
            var dtEa = ea.Accept(this);
            var ptEa = GetPossibleFieldType(dtEa, 0);
            if (ptEa == null)
            {
                ptEa = dtEa.ResolveAs<Pointer>();
            }
            DataType dt;
            if (ptEa != null)
            {
                //$REVIEW: what if sizeof(access) != sizeof(field_at_0)?
                dt = ptEa.Pointee;
            }
            else
                dt = access.DataType;
            return RecordDataType(dt, access);
        }

        public DataType VisitMkSequence(MkSequence seq)
        {
            var dtElems = seq.Expressions.Select(e => e.Accept(this)).ToArray();
            DataType dtSeq;
            if (dtElems.Length == 2 && IsSelector(dtElems[0]))
            {
                dtSeq = PrimitiveType.Create(Domain.Pointer, seq.DataType.BitSize);
            }
            else 
            {
                if (dtElems[0] is PrimitiveType ptHead && ptHead.IsIntegral)
                {
                    dtSeq = PrimitiveType.Create(ptHead.Domain, seq.DataType.BitSize);
                }
                else
                {
                    dtSeq = seq.DataType;
                }
            }
            return RecordDataType(dtSeq, seq);
        }

        private bool IsSelector(DataType dt)
        {
            return dt is PrimitiveType pt && pt.Domain == Domain.Selector;
        }

        public DataType VisitOutArgument(OutArgument outArgument)
        {
            var dt = outArgument.Expression.Accept(this);
            return dt;
            //Expression exp = outArgument;
            //return RecordDataType(OutPointerTo(outArgument.TypeVariable), exp);
        }

        public DataType VisitPhiFunction(PhiFunction phi)
        {
            throw new NotImplementedException();
        }

        public DataType VisitPointerAddition(PointerAddition pa)
        {
            throw new NotImplementedException();
        }

        public DataType VisitProcedureConstant(ProcedureConstant pc)
        {
            return pc.DataType;
        }

        public DataType VisitScopeResolution(ScopeResolution scopeResolution)
        {
            throw new NotImplementedException();
        }

        public DataType VisitSegmentedAccess(SegmentedAccess access)
        {
            access.BasePointer.Accept(this);
            return VisitMemoryAccessCommon(access, access.EffectiveAddress);
        }

        public DataType VisitSlice(Slice slice)
        {
            slice.Expression.Accept(this);
            return RecordDataType(slice.DataType, slice);
        }

        public DataType VisitTestCondition(TestCondition tc)
        {
            tc.Expression.Accept(this);
            return RecordDataType(PrimitiveType.Bool, tc);
        }

        public DataType VisitUnaryExpression(UnaryExpression unary)
        {
            var dt = unary.Expression.Accept(this);
            if (unary.Operator == Operator.AddrOf)
            {
                dt = factory.CreatePointer(dt, unary.DataType.BitSize);
            }
            return RecordDataType(dt, unary);
        }
    }
}

---- Transformed Tree ----
using Reko.Core.Operators;
using Reko.Core.Types;
using System;
using System.Linq;

namespace Reko.Core.Expressions
{
    /// <summary>
    /// Collect type information by pulling type information from
    /// the leaves of expression trees to their roots.
    /// </summary>
    /// <remarks>
    ///    root
    ///   /  \ 
    /// leaf  leaf
    /// </remarks>
    public abstract class ExpressionTypeAscenderBase : ExpressionVisitor<DataType>
    {
        private readonly IPlatform platform;
        private readonly TypeFactory factory;
        private readonly StructureType globalFields;

        public ExpressionTypeAscenderBase(Program program, TypeFactory factory)
        {
            this.platform = program.Platform;
            this.globalFields = program.GlobalFields;
            this.factory = factory;
        }

        protected abstract DataType RecordDataType(DataType dt, Expression exp);
        protected abstract DataType EnsureDataType(DataType dt, Expression exp);

        public DataType VisitAddress(Address addr)
        {
            var c = addr.ToConstant();
            c.DataType = PrimitiveType.Create(Domain.Pointer, addr.DataType.BitSize);
            var dt = ExistingGlobalField(c) ?? addr.DataType;
            return RecordDataType(dt, addr);
        }

        public DataType VisitApplication(Application appl)
        {
            foreach (var a in appl.Arguments)
            {
                RecordDataType(a.Accept(this), a);
            }
            RecordDataType(appl.Procedure.Accept(this), appl.Procedure);
            var dt = RecordApplicationReturnType(appl.Procedure, appl);
            return dt;
        }

        private DataType RecordApplicationReturnType(Expression pfn, Application appl)
        {
            var dt = RecordDataType(appl.DataType, appl);
            if (pfn is ProcedureConstant pc && 
                pc.Procedure.Signature.ParametersValid)
            {
                dt = RecordDataType(pc.Procedure.Signature.ReturnValue!.DataType, appl);
            }
            return dt;
        }
        public DataType VisitArrayAccess(ArrayAccess acc)
        {
            acc.Array.Accept(this);
            acc.Index.Accept(this);
            return RecordDataType(acc.DataType, acc);
        }

        private Exception NYI(Expression e)
        {
            return new NotImplementedException(string.Format("Not implemented: {0}", e));
        }

        public DataType VisitBinaryExpression(BinaryExpression binExp)
        {
            DataType dtLeft = binExp.Left.Accept(this);
            DataType dtRight = binExp.Right.Accept(this);
            DataType dt;
            if (binExp.Operator == Operator.IAdd)
            {
                var dtField = GetPossibleFieldType(dtLeft, dtRight, binExp.Right);
                if (dtField != null)
                {
                    dt = dtField;
                }
                else
                { 
                    dt = PullSumDataType(dtLeft, dtRight);
                }
            }
            else if (binExp.Operator == Operator.ISub)
            {
                dt = PullDiffDataType(dtLeft, dtRight);
            }
            else if (binExp.Operator == Operator.And || 
                binExp.Operator == Operator.Or)
            {
                dt = PrimitiveType.CreateWord(dtLeft.BitSize).MaskDomain(Domain.Boolean | Domain.Integer | Domain.Character);
            }
            else if (
                binExp.Operator == Operator.IMul ||
                binExp.Operator == Operator.Shl ||
                binExp.Operator == Operator.IMod)
            {
                dt = PrimitiveType.CreateWord(binExp.DataType.BitSize).MaskDomain(Domain.Integer);
            }
            else if (
                binExp.Operator == Operator.SMul ||
                binExp.Operator == Operator.SDiv)
            {
                dt = PrimitiveType.CreateWord(binExp.DataType.BitSize).MaskDomain(Domain.SignedInt);
            }
            else if (
                binExp.Operator == Operator.UMul ||
                binExp.Operator == Operator.UDiv)
            {
                dt = PrimitiveType.CreateWord(binExp.DataType.BitSize).MaskDomain(Domain.UnsignedInt);
            }
            else if (binExp.Operator is ConditionalOperator ||
                binExp.Operator is CorOperator ||
                binExp.Operator is CandOperator)
            {
                dt = PrimitiveType.Bool;
            }
            else if (
                binExp.Operator == Operator.FAdd ||
                binExp.Operator == Operator.FSub ||
                binExp.Operator == Operator.FMul ||
                binExp.Operator == Operator.FDiv)
            {
                dt = PrimitiveType.Create(Domain.Real, binExp.DataType.BitSize);
            }
            else if (binExp.Operator == Operator.Shr)
            {
                dt = PrimitiveType.Create(Domain.UnsignedInt, dtLeft.BitSize);
            }
            else if (binExp.Operator == Operator.Sar)
            {
                dt = PrimitiveType.Create(Domain.SignedInt, dtLeft.BitSize);
            }
            else if (binExp.Operator == Operator.Xor ||
                     binExp.Operator == Operator.Shl)
            {
                dt = PrimitiveType.Create(Domain.Integer, dtLeft.BitSize);
            }
            else
                throw NYI(binExp);
            return RecordDataType(dt, binExp);
        }

        /// <summary>
        /// If dtLeft is a (ptr (struct ...)) and dtRight is a non-pointer
        /// constant, this could be a field access.
        /// </summary>
        /// <param name="dtLeft">Possible pointer to a structure</param>
        /// <param name="dtRight">Type of possible offset</param>
        /// <param name="right">Possible constant offset from start of structure</param>
        /// <returns>A (ptr field-type) if it was a ptr-to-struct, else null.</returns>
        private Pointer? GetPossibleFieldType(DataType dtLeft, DataType dtRight, Expression right)
        {
            if (right is Constant cOffset)
            {
                if (dtRight is PrimitiveType ptRight && ptRight.Domain != Domain.Pointer)
                {
                    int offset = cOffset.ToInt32();
                    return GetPossibleFieldType(dtLeft, offset);
                }
            }
            return null;
        }

        /// <summary>
        /// If dtLeft is a (ptr (struct ...)) and there is a field at the
        /// given offset in that structure, this could be a field access.
        /// </summary>
        /// <param name="dtLeft">Possible pointer to a structure</param>
        /// <param name="offset"></param>
        /// <returns>A (ptr field-type) if it was a ptr-to-struct, else null.</returns>
        private Pointer? GetPossibleFieldType(DataType dtLeft, int offset)
        {
            var ptrLeft = dtLeft.ResolveAs<Pointer>();
            if (ptrLeft == null)
                return null;

            var pointee = ptrLeft.Pointee;
            var strPointee = pointee.ResolveAs<StructureType>();
            if (strPointee == null)
                return null;

            var field = strPointee.Fields.LowerBound(offset);
            if (field == null)
                return null;
            // We're collecting _DataTypes_, so if we encounter
            // a TypeReference, we need to drill past it.
            var dtField = field.DataType.ResolveAs<DataType>();
            if (dtField == null)
                return null;
            // If we access beyond the start of the field, we can't have the
            // same type as the field.
            if (offset != field.Offset)
            {
                // Check if field is nested structure
                var ptrField = factory.CreatePointer(dtField, ptrLeft.BitSize);
                return GetPossibleFieldType(ptrField, offset - field.Offset);
            }
            return factory.CreatePointer(dtField, dtLeft.BitSize);
        }

        private DataType PullSumDataType(DataType dtLeft, DataType dtRight)
        {
            var ptLeft = dtLeft.ResolveAs<PrimitiveType>();
            var ptRight = dtRight.ResolveAs<PrimitiveType>();
            if (ptLeft != null && ptLeft.Domain == Domain.Pointer)
            {
                if (ptRight != null && ptRight.Domain != Domain.Pointer)
                    return PrimitiveType.Create(Domain.Pointer, dtLeft.BitSize);
            }
            if (ptLeft != null && ptLeft.IsIntegral && ptRight != null && ptRight.IsIntegral)
            {
                // According to the C language definition, the sum
                // of unsigned and signed integers is always unsigned.
                if (ptLeft.Domain == Domain.UnsignedInt)
                {
                    return ptLeft;
                }
                if (ptRight.Domain == Domain.UnsignedInt)
                {
                    return ptRight;
                }
            }
            if (dtLeft.ResolveAs<Pointer>() != null)
            {
                if (dtLeft is TypeReference)
                    return dtLeft;
                else 
                    return PrimitiveType.Create(Domain.Pointer, dtLeft.BitSize);
            }
            return dtLeft;
        }

        private DataType PullDiffDataType(DataType dtLeft, DataType dtRight)
        {
            var ptRight = dtRight.ResolveAs<PrimitiveType>();
            if (dtLeft is PrimitiveType ptLeft && ptLeft.Domain == Domain.Pointer || 
                dtLeft is Pointer)
            {
                if (ptRight != null)
                {
                    if ((ptRight.Domain & Domain.Integer) != 0)
                        return PrimitiveType.Create(Domain.Pointer, dtLeft.BitSize);
                    else if ((ptRight.Domain & Domain.Pointer) != 0)
                        return PrimitiveType.Create(Domain.SignedInt, dtLeft.BitSize);
                }
                if (dtRight is Pointer)
                    return PrimitiveType.Create(Domain.SignedInt, dtLeft.BitSize);
                // We are unable to reconcile the differences here. 
                return PrimitiveType.CreateWord(dtLeft.BitSize);
                //$TODO: should be a warning? throw new TypeInferenceException(string.Format("Pulling difference {0} and {1}", dtLeft, dtRight));
            }
            if (ptRight != null && ptRight.Domain == Domain.Pointer || 
                dtRight is Pointer)
            {
                if (ptRight != null && (ptRight.Domain & Domain.Integer) != 0)
                    return dtLeft;

                // If a dtRight is a pointer and it's being subtracted from 
                // something, then the result has to be a ptrdiff_t, i.e.
                // integer.
                if (dtLeft is PrimitiveType ptLeft && (ptLeft.Domain & Domain.Pointer) != 0)
                    return PrimitiveType.Create(Domain.Integer, dtLeft.BitSize);
                // We are unable to reconcile the differences here. 
                return PrimitiveType.CreateWord(dtLeft.BitSize);
                //$TODO: should be a warning? throw new TypeInferenceException(string.Format("Pulling difference {0} and {1}", dtLeft, dtRight));
            }
            return dtLeft;
        }

        public DataType VisitCast(Cast cast)
        {
            cast.Expression.Accept(this);
            RecordDataType(cast.DataType, cast);
            return cast.DataType;
        }

        public DataType VisitConditionalExpression(ConditionalExpression cond)
        {
            cond.ThenExp.Accept(this);
            cond.FalseExp.Accept(this);
            cond.Condition.Accept(this);
            return RecordDataType(cond.DataType, cond);
        }

        public DataType VisitConditionOf(ConditionOf cof)
        {
            cof.Expression.Accept(this);
            RecordDataType(cof.DataType, cof);
            return cof.DataType;
        }

        public DataType VisitConstant(Constant c)
        {
            var dt = ExistingGlobalField(c) ?? c.DataType;
            return RecordDataType(dt, c);
        }

        private DataType? ExistingGlobalField(Constant c)
        {
            if (!(c.DataType is PrimitiveType pt) || (pt.Domain & Domain.Pointer) == 0)
                return null;
            var global = factory.CreatePointer(globalFields, pt.BitSize);
            return GetPossibleFieldType(global, PrimitiveType.Int32, c);
        }

        public DataType VisitConversion(Conversion conversion)
        {
            conversion.Expression.Accept(this);
            RecordDataType(conversion.DataType, conversion);
            return conversion.DataType;
        }

        public DataType VisitDereference(Dereference deref)
        {
            //$TODO: if deref.Expression is of pointer type, this
            // should be the pointeee.
            return deref.DataType;
        }

        public DataType VisitFieldAccess(FieldAccess acc)
        {
            throw new NotImplementedException();
        }

        public DataType VisitIdentifier(Identifier id)
        {
            return EnsureDataType(id.DataType, id);
        }

        public DataType VisitMemberPointerSelector(MemberPointerSelector mps)
        {
            throw new NotImplementedException();
        }

        public DataType VisitMemoryAccess(MemoryAccess access)
        {
            return VisitMemoryAccessCommon(access, access.EffectiveAddress);
        }

        public DataType VisitMemoryAccessCommon(Expression access, Expression ea)
        {
            var dtEa = ea.Accept(this);
            var ptEa = GetPossibleFieldType(dtEa, 0);
            if (ptEa == null)
            {
                ptEa = dtEa.ResolveAs<Pointer>();
            }
            DataType dt;
            if (ptEa != null)
            {
                //$REVIEW: what if sizeof(access) != sizeof(field_at_0)?
                dt = ptEa.Pointee;
            }
            else
                dt = access.DataType;
            return RecordDataType(dt, access);
        }

        public DataType VisitMkSequence(MkSequence seq)
        {
            var dtElems = seq.Expressions.Select(e => e.Accept(this)).ToArray();
            DataType dtSeq;
            if (dtElems.Length == 2 && IsSelector(dtElems[0]))
            {
                dtSeq = PrimitiveType.Create(Domain.Pointer, seq.DataType.BitSize);
            }
            else 
            {
                if (dtElems[0] is PrimitiveType ptHead && ptHead.IsIntegral)
                {
                    dtSeq = PrimitiveType.Create(ptHead.Domain, seq.DataType.BitSize);
                }
                else
                {
                    dtSeq = seq.DataType;
                }
            }
            return RecordDataType(dtSeq, seq);
        }

        private bool IsSelector(DataType dt)
        {
            return dt is PrimitiveType pt && pt.Domain == Domain.Selector;
        }

        public DataType VisitOutArgument(OutArgument outArgument)
        {
            var dt = outArgument.Expression.Accept(this);
            return dt;
            //Expression exp = outArgument;
            //return RecordDataType(OutPointerTo(outArgument.TypeVariable), exp);
        }

        public DataType VisitPhiFunction(PhiFunction phi)
        {
            throw new NotImplementedException();
        }

        public DataType VisitPointerAddition(PointerAddition pa)
        {
            throw new NotImplementedException();
        }

        public DataType VisitProcedureConstant(ProcedureConstant pc)
        {
            return pc.DataType;
        }

        public DataType VisitScopeResolution(ScopeResolution scopeResolution)
        {
            throw new NotImplementedException();
        }

        public DataType VisitSegmentedAccess(SegmentedAccess access)
        {
            access.BasePointer.Accept(this);
            return VisitMemoryAccessCommon(access, access.EffectiveAddress);
        }

        public DataType VisitSlice(Slice slice)
        {
            slice.Expression.Accept(this);
            return RecordDataType(slice.DataType, slice);
        }

        public DataType VisitTestCondition(TestCondition tc)
        {
            tc.Expression.Accept(this);
            return RecordDataType(PrimitiveType.Bool, tc);
        }

        public DataType VisitUnaryExpression(UnaryExpression unary)
        {
            var dt = unary.Expression.Accept(this);
            if (unary.Operator == Operator.AddrOf)
            {
                dt = factory.CreatePointer(dt, unary.DataType.BitSize);
            }
            return RecordDataType(dt, unary);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Core\Expressions\ExpressionTypeAscenderBase.cs(289,45): error CS0136: A local or parameter named 'ptLeft' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Reko.Core.Types;

namespace Reko.Core.Output
{
    public class TypeReferenceFormatter
    {
        private bool declaration;
        private string? declaredName;
        private int depth;//$BUG: used to avoid infinite recursion
        private bool wantSpace;

        public TypeReferenceFormatter(Formatter writer)
        {
            this.Formatter = writer;
        }

        public Formatter Formatter { get; }

        public void WriteTypeReference(DataType dt)
        {
            this.declaration = false;
            this.declaredName = null;
            TypeName(dt);
        }

        /* declaration:
                declaration-specifiers init-declarator-list(opt) ;  */

        public void WriteDeclaration(DataType dt, string name)
        {
            this.declaration = true;
            this.declaredName = name;
            DeclarationSpecifiers(dt);
            InitDeclarator(dt);
        }

        /* init-declarator:
      declarator:
      declarator = initializer   */

        void InitDeclarator(DataType t)
        {
            Declarator(t);
            //if (DECL_INITIAL(t))
            //{
            //    tree init = DECL_INITIAL(t);
            //    /* This C++ bit is handled here because it is easier to do so.
            //       In templates, the C++ parser builds a TREE_LIST for a
            //       direct-initialization; the TREE_PURPOSE is the variable to
            //       initialize and the TREE_VALUE is the initializer.  */
            //    if (TREE_CODE(init) == TREE_LIST)
            //    {
            //        pp_c_left_paren(pp);
            //        pp_expression(TREE_VALUE(init));
            //        pp_right_paren(pp);
            //    }
            //    else
            //    {
            //        pp_space(pp);
            //        pp_equal(pp);
            //        pp_space(pp);
            //        pp_c_initializer(init);
            //    }
            //}
        }

        void CvQualifier(string cv)
        {
            Formatter.Write(' ');
            Formatter.Write(cv);
        }

        void SpaceForPointerOperator(DataType t)
        {
            if (t is Pointer p)
            {
                if (!(t is ArrayType || t is FunctionType))
                    Formatter.Write(' ');
            }
            else
                Formatter.Write(' ');
        }


        /* Declarations.  */

        /* C++ cv-qualifiers are called type-qualifiers in C.  Print out the
           cv-qualifiers of T.  If T is a declaration then it is the cv-qualifier
           of its type.  Take care of possible extensions.

           type-qualifier-list:
               type-qualifier
               type-qualifier-list type-qualifier

           type-qualifier:
               const
               restrict                              -- C99
               __restrict__                          -- GNU C
               volatile    */

        //$REVIEW: we don't do cv-qualifiers... yet?
        void TypeQualifierList(DataType t)
        {
            //type_qual qualifiers;

            //if (!TYPE_P(t))
            //    t = TREE_TYPE(t);

            //qualifiers = TYPE_QUALS(t);
            //if ((qualifiers & type_qual.CONST) != 0)
            //    pp_c_cv_qualifier("const");
            //if ((qualifiers & type_qual.VOLATILE) != 0)
            //    pp_c_cv_qualifier("volatile");
            //if ((qualifiers & type_qual.RESTRICT) != 0)
            //    pp_c_cv_qualifier(flag_isoc99 ? "restrict" : "__restrict__");
        }

        /* pointer:
              * type-qualifier-list(opt)
              * type-qualifier-list(opt) pointer  */

        void Pointer(Pointer t)
        {
            if (t.Pointee is Pointer ptPointee)
                Pointer(ptPointee);
            WriteSpace();
            Formatter.Write('*');
            TypeFormatter.WriteQualifier(t.Qualifier, Formatter);
            TypeQualifierList(t);
        }

        void MemberPointer(MemberPointer m)
        {
            if (m.Pointee is Pointer ptPointee)
                Pointer(ptPointee);
            if (m.Pointee is MemberPointer mpPointee)
                MemberPointer(mpPointee);
            Formatter.Write(' ');
            var baseType = StripPointerOperator(m.BasePointer);
            Formatter.Write(baseType.Name);
            Formatter.Write("::*");
            TypeQualifierList(m);
        }

        void ReferenceTo(ReferenceTo r)
        {
            WriteSpace();
            Formatter.Write('&');
            TypeQualifierList(r);
        }

        /* type-specifier:
              void
              char
              short
              int
              long
              float
              double
              signed
              unsigned
              _Bool                          -- C99
              _Complex                       -- C99
              _Imaginary                     -- C99
              struct-or-union-specifier
              enum-specifier
              typedef-name.

          GNU extensions.
          simple-type-specifier:
              __complex__
              __vector__   */

        void TypeSpecifier(DataType t)
        {
            TypeFormatter.WriteQualifier(t.Qualifier, Formatter);
            if (t is UnknownType)
            {
                Formatter.Write("<type-error>");
                return;
            }
            else if (t is EquivalenceClass)
            {
                Formatter.Write(t.Name);
                wantSpace = true;
                return;
            }
            else if (t is PrimitiveType primitiveType) {
                //case tree_code.VOID_TYPE:
                //case tree_code.BOOLEAN_TYPE:
                //case tree_code.CHAR_TYPE:
                //case tree_code.INTEGER_TYPE:
                //case tree_code.REAL_TYPE:
                //if (TYPE_NAME(t) != null)
                //    t = TYPE_NAME(t);
                //else
                //    t = c_common_type_for_mode(TYPE_MODE(t), TREE_UNSIGNED(t));
                WritePrimitiveTypeName(primitiveType);
                //if (declaration && !string.IsNullOrEmpty(declaredName))
                //    fmt.Write(' ');
                wantSpace = true;
                return;
            }
            else if (t is VoidType voidType)
            {
                WriteVoidType(voidType);
                wantSpace = true;
                return;
            }
            else if (t is UnionType)
            {
                Formatter.WriteKeyword("union");
                Formatter.Write(" ");
            }
            else if (t is StructureType)
            {
                Formatter.WriteKeyword("struct");
                Formatter.Write(" ");
            }
            else if (t is EnumType)
            {
                Formatter.WriteKeyword("enum");
                Formatter.Write(" ");
            }
            if (string.IsNullOrEmpty(t.Name))
                Formatter.Write("<anonymous>");
            else
                Formatter.Write(t.Name);
            wantSpace = true;
        }

        public virtual void WritePrimitiveTypeName(PrimitiveType t)
        {
            Formatter.WriteType(t.Name, t);
            wantSpace = true;
        }

        public virtual void WriteVoidType(VoidType t)
        {
            Formatter.WriteType(t.Name, t);
            wantSpace = true;
        }

        private void WriteSpace()
        {
            if (wantSpace)
            {
                Formatter.Write(' ');
                wantSpace = false;
            }
        }

        /* specifier-qualifier-list:
              type-specifier specifier-qualifier-list-opt
              type-qualifier specifier-qualifier-list-opt


          Implementation note:  Because of the non-linearities in array or
          function declarations, this routine prints not just the
          specifier-qualifier-list of such entities or types of such entities,
          but also the 'pointer' production part of their declarators.  The
          remaining part is done by pp_declarator or pp_c_abstract_declarator.  */

        void SpecifierQualifierList(DataType t)
        {
            if (this.depth > 50) //$BUG: used to avoid infinite recursion
                return;
            ++this.depth;
            if (!(t is Pointer))
                TypeQualifierList(t);
            var pt = t as Pointer;
            var mp = t as MemberPointer;
            var rf = t as ReferenceTo;
            if (pt != null || mp != null || rf != null)
            {
                // Get the types-specifier of this type.  
                DataType pointee = StripPointerOperator(
                    pt != null 
                        ? pt.Pointee
                        : mp != null 
                            ? mp.Pointee
                            : rf!.Referent);
                SpecifierQualifierList(pointee);
                if (pointee is ArrayType || pointee is FunctionType)
                {
                    Formatter.Write(" (");
                    wantSpace = false;
                }
                if (pt != null)
                    Pointer(pt);
                else if (mp != null)
                    MemberPointer(mp);
                else if (rf != null)
                    ReferenceTo(rf); 
                --this.depth;
                return;
            }

            if (t is FunctionType ft && ft.ReturnValue != null)
            {
                SpecifierQualifierList(ft.ReturnValue.DataType);
                --this.depth;
                return;
            }
            if (t is ArrayType at)
            {
                SpecifierQualifierList(at.ElementType);
            }
            else
            {
                TypeSpecifier(t);
            }
            --this.depth;
        }

        private DataType StripPointerOperator(DataType dt)
        {
            var pt = dt as Pointer;
            var mp = dt as MemberPointer;
            while (pt != null || mp != null)
            {
                if (pt != null)
                    dt = pt.Pointee;
                else
                    dt = mp!.Pointee;
                pt = dt as Pointer;
                mp = dt as MemberPointer;
            }
            if (dt is EquivalenceClass eq && eq.DataType != null)
                dt = eq.DataType;
            return dt;
        }

        /* parameter-type-list:
              parameter-list
              parameter-list , ...

           parameter-list:
              parameter-declaration
              parameter-list , parameter-declaration

           parameter-declaration:
              declaration-specifiers declarator
              declaration-specifiers abstract-declarator(opt)   */

        void ParameterTypeList(FunctionType? ft)
        {
            var name = declaredName;
            Formatter.Write('(');
            if (ft == null || ft.Parameters == null || ft.Parameters.Length == 0)
            {
                // fmt.Write("void");      // In C, 0-parameter functions use 'void'
            }
            else
            {
                bool first = true;
                for (int i = 0; i < ft.Parameters.Length; ++i)
                {
                    if (!first)
                        Formatter.Write(", ");
                    first = false;
                    declaredName = ft.Parameters[i].Name;
                    DeclarationSpecifiers(ft.Parameters[i].DataType);
                    if (declaration && !string.IsNullOrEmpty(declaredName))
                        Declarator(ft.Parameters[i].DataType);
                    else
                        AbstractDeclarator(ft.Parameters[i].DataType);
                }
            }
            Formatter.Write(')');
            declaredName = name;
        }

        /* abstract-declarator:
              pointer
              pointer(opt) direct-abstract-declarator  */

        void AbstractDeclarator(DataType dt)
        {
            if (this.depth > 50)
                return;         //$BUG: discover cause of the deep recursion?
            ++this.depth;
            if (dt is Pointer pt)
            {
                var pointee = pt.Pointee;
                if (pointee is EquivalenceClass eq && eq.DataType != null)
                    pointee = eq.DataType;
                if (pointee is ArrayType ||
                    pointee is FunctionType)
                    Formatter.Write(')');
                dt = pointee;
            }
            DirectAbstractDeclarator(dt);
            --this.depth;
        }

        /* direct-abstract-declarator:
              ( abstract-declarator )
              direct-abstract-declarator(opt) [ assignment-expression(opt) ]
              direct-abstract-declarator(opt) [ * ]
              direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */

        void DirectAbstractDeclarator(DataType t)
        {
            if (t is Pointer)
            {
                AbstractDeclarator(t);
            }
            else if (t is FunctionType ft)
            {
                ParameterTypeList(ft);
                //DirectAbstractDeclarator(ft);
            }
            else if (t is ArrayType at)
            {
                Formatter.Write('[');
                if (at.Length != 0)
                {
                    Formatter.Write(at.Length);
                }
                Formatter.Write(']');
                DirectAbstractDeclarator(at.ElementType);
            }
            else
            {
                return;
            }
        }

        /* type-name:
              specifier-qualifier-list  abstract-declarator(opt)  */

        void TypeName(DataType t)
        {
            SpecifierQualifierList(t);
            AbstractDeclarator(t);
        }

        /* storage-class-specifier:
              typedef
              extern
              static
              auto
              register  */

        //void StorageClassSpecifier(tree t)
        //{
        //    //if (TREE_CODE(t) == TYPE_DECL)
        //    //    fmt.Write("typedef");
        //    //else if (DECL_P(t))
        //    //{
        //    //    if (DECL_REGISTER(t))
        //    //        fmt.Write("register");
        //    //    else if (TREE_STATIC(t) && TREE_CODE(t) == VAR_DECL)
        //    //        fmt.Write("static");
        //    //}
        //}

        /* function-specifier:
              inline   */

        void FunctionSpecifier(DataType dt)
        {
        //    if (TREE_CODE(t) == tree_code.FUNCTION_DECL && DECL_DECLARED_INLINE_P(t))
        //        fmt.Write("inline");
        }

        /* declaration-specifiers:
              storage-class-specifier declaration-specifiers(opt)
              type-specifier declaration-specifiers(opt)
              type-qualifier declaration-specifiers(opt)
              function-specifier declaration-specifiers(opt)  */

        void DeclarationSpecifiers(DataType dt)
        {
            // StorageClassSpecifier(t);
            FunctionSpecifier(dt);
            SpecifierQualifierList(dt);
        }

        /* direct-declarator
              identifier
              ( declarator )
              direct-declarator [ type-qualifier-list(opt) assignment-expression(opt) ]
              direct-declarator [ static type-qualifier-list(opt) assignment-expression(opt)]
              direct-declarator [ type-qualifier-list static assignment-expression ]
              direct-declarator [ type-qualifier-list * ]
              direct-declaratpr ( parameter-type-list )
              direct-declarator ( identifier-list(opt) )  */

        void DirectDeclarator(DataType dt)
        {
            if (declaration)
            {
                if (!string.IsNullOrEmpty(this.declaredName))
                {
                    SpaceForPointerOperator(dt);
                    Formatter.Write(this.declaredName ?? "");
                }
                AbstractDeclarator(dt);
                return;
            }
            if (dt is ArrayType at)
            {
                AbstractDeclarator(at.ElementType);
                return;
            }
            if (dt is FunctionType ft)
            {
                ParameterTypeList(ft);
                if (ft.ReturnValue != null)
                {
                    AbstractDeclarator(ft.ReturnValue.DataType);
                }
                return;
            }
        }

        void DirectDeclarator(FunctionType sig)
        {
            SpaceForPointerOperator(sig.ReturnValue!.DataType);
            Formatter.Write(declaredName ?? "");
            ParameterTypeList(null);
            AbstractDeclarator(sig.ReturnValue.DataType);
        }

        /* declarator:
              pointer(opt)  direct-declarator   */

        void Declarator(DataType dt)
        {
            //if (dt is PrimitiveType || dt is EnumType ||
            //    dt is StructureType || dt is UnionType)
            //{
            //    return;
            //}
            DirectDeclarator(dt);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Reko.Core.Types;

namespace Reko.Core.Output
{
    public class TypeReferenceFormatter
    {
        private bool declaration;
        private string? declaredName;
        private int depth;//$BUG: used to avoid infinite recursion
        private bool wantSpace;

        public TypeReferenceFormatter(Formatter writer)
        {
            this.Formatter = writer;
        }

        public Formatter Formatter { get; }

        public void WriteTypeReference(DataType dt)
        {
            this.declaration = false;
            this.declaredName = null;
            TypeName(dt);
        }

        /* declaration:
                declaration-specifiers init-declarator-list(opt) ;  */

        public void WriteDeclaration(DataType dt, string name)
        {
            this.declaration = true;
            this.declaredName = name;
            DeclarationSpecifiers(dt);
            InitDeclarator(dt);
        }

        /* init-declarator:
      declarator:
      declarator = initializer   */

        void InitDeclarator(DataType t)
        {
            Declarator(t);
            //if (DECL_INITIAL(t))
            //{
            //    tree init = DECL_INITIAL(t);
            //    /* This C++ bit is handled here because it is easier to do so.
            //       In templates, the C++ parser builds a TREE_LIST for a
            //       direct-initialization; the TREE_PURPOSE is the variable to
            //       initialize and the TREE_VALUE is the initializer.  */
            //    if (TREE_CODE(init) == TREE_LIST)
            //    {
            //        pp_c_left_paren(pp);
            //        pp_expression(TREE_VALUE(init));
            //        pp_right_paren(pp);
            //    }
            //    else
            //    {
            //        pp_space(pp);
            //        pp_equal(pp);
            //        pp_space(pp);
            //        pp_c_initializer(init);
            //    }
            //}
        }

        void CvQualifier(string cv)
        {
            Formatter.Write(' ');
            Formatter.Write(cv);
        }

        void SpaceForPointerOperator(DataType t)
        {
            if (t is Pointer p)
            {
                if (!(t is ArrayType || t is FunctionType))
                    Formatter.Write(' ');
            }
            else
                Formatter.Write(' ');
        }


        /* Declarations.  */

        /* C++ cv-qualifiers are called type-qualifiers in C.  Print out the
           cv-qualifiers of T.  If T is a declaration then it is the cv-qualifier
           of its type.  Take care of possible extensions.

           type-qualifier-list:
               type-qualifier
               type-qualifier-list type-qualifier

           type-qualifier:
               const
               restrict                              -- C99
               __restrict__                          -- GNU C
               volatile    */

        //$REVIEW: we don't do cv-qualifiers... yet?
        void TypeQualifierList(DataType t)
        {
            //type_qual qualifiers;

            //if (!TYPE_P(t))
            //    t = TREE_TYPE(t);

            //qualifiers = TYPE_QUALS(t);
            //if ((qualifiers & type_qual.CONST) != 0)
            //    pp_c_cv_qualifier("const");
            //if ((qualifiers & type_qual.VOLATILE) != 0)
            //    pp_c_cv_qualifier("volatile");
            //if ((qualifiers & type_qual.RESTRICT) != 0)
            //    pp_c_cv_qualifier(flag_isoc99 ? "restrict" : "__restrict__");
        }

        /* pointer:
              * type-qualifier-list(opt)
              * type-qualifier-list(opt) pointer  */

        void Pointer(Pointer t)
        {
            if (t.Pointee is Pointer ptPointee)
                Pointer(ptPointee);
            WriteSpace();
            Formatter.Write('*');
            TypeFormatter.WriteQualifier(t.Qualifier, Formatter);
            TypeQualifierList(t);
        }

        void MemberPointer(MemberPointer m)
        {
            if (m.Pointee is Pointer ptPointee)
                Pointer(ptPointee);
            if (m.Pointee is MemberPointer mpPointee)
                MemberPointer(mpPointee);
            Formatter.Write(' ');
            var baseType = StripPointerOperator(m.BasePointer);
            Formatter.Write(baseType.Name);
            Formatter.Write("::*");
            TypeQualifierList(m);
        }

        void ReferenceTo(ReferenceTo r)
        {
            WriteSpace();
            Formatter.Write('&');
            TypeQualifierList(r);
        }

        /* type-specifier:
              void
              char
              short
              int
              long
              float
              double
              signed
              unsigned
              _Bool                          -- C99
              _Complex                       -- C99
              _Imaginary                     -- C99
              struct-or-union-specifier
              enum-specifier
              typedef-name.

          GNU extensions.
          simple-type-specifier:
              __complex__
              __vector__   */

        void TypeSpecifier(DataType t)
        {
            TypeFormatter.WriteQualifier(t.Qualifier, Formatter);
            if (t is UnknownType)
            {
                Formatter.Write("<type-error>");
                return;
            }
            else if (t is EquivalenceClass)
            {
                Formatter.Write(t.Name);
                wantSpace = true;
                return;
            }
            else if (t is PrimitiveType primitiveType) {
                //case tree_code.VOID_TYPE:
                //case tree_code.BOOLEAN_TYPE:
                //case tree_code.CHAR_TYPE:
                //case tree_code.INTEGER_TYPE:
                //case tree_code.REAL_TYPE:
                //if (TYPE_NAME(t) != null)
                //    t = TYPE_NAME(t);
                //else
                //    t = c_common_type_for_mode(TYPE_MODE(t), TREE_UNSIGNED(t));
                WritePrimitiveTypeName(primitiveType);
                //if (declaration && !string.IsNullOrEmpty(declaredName))
                //    fmt.Write(' ');
                wantSpace = true;
                return;
            }
            else if (t is VoidType voidType)
            {
                WriteVoidType(voidType);
                wantSpace = true;
                return;
            }
            else if (t is UnionType)
            {
                Formatter.WriteKeyword("union");
                Formatter.Write(" ");
            }
            else if (t is StructureType)
            {
                Formatter.WriteKeyword("struct");
                Formatter.Write(" ");
            }
            else if (t is EnumType)
            {
                Formatter.WriteKeyword("enum");
                Formatter.Write(" ");
            }
            if (string.IsNullOrEmpty(t.Name))
                Formatter.Write("<anonymous>");
            else
                Formatter.Write(t.Name);
            wantSpace = true;
        }

        public virtual void WritePrimitiveTypeName(PrimitiveType t)
        {
            Formatter.WriteType(t.Name, t);
            wantSpace = true;
        }

        public virtual void WriteVoidType(VoidType t)
        {
            Formatter.WriteType(t.Name, t);
            wantSpace = true;
        }

        private void WriteSpace()
        {
            if (wantSpace)
            {
                Formatter.Write(' ');
                wantSpace = false;
            }
        }

        /* specifier-qualifier-list:
              type-specifier specifier-qualifier-list-opt
              type-qualifier specifier-qualifier-list-opt


          Implementation note:  Because of the non-linearities in array or
          function declarations, this routine prints not just the
          specifier-qualifier-list of such entities or types of such entities,
          but also the 'pointer' production part of their declarators.  The
          remaining part is done by pp_declarator or pp_c_abstract_declarator.  */

        void SpecifierQualifierList(DataType t)
        {
            if (this.depth > 50) //$BUG: used to avoid infinite recursion
                return;
            ++this.depth;
            if (!(t is Pointer))
                TypeQualifierList(t);

            if (t is Pointer pt || t is MemberPointer mp || t is ReferenceTo rf)
            {
                // Get the types-specifier of this type.  
                DataType pointee = StripPointerOperator(
                    t is Pointer pt 
                        ? pt.Pointee
                        : t is MemberPointer mp 
                            ? mp.Pointee
                            : rf!.Referent);
                SpecifierQualifierList(pointee);
                if (pointee is ArrayType || pointee is FunctionType)
                {
                    Formatter.Write(" (");
                    wantSpace = false;
                }
                if (t is Pointer pt)
                    Pointer(pt);
                else if (t is MemberPointer mp)
                    MemberPointer(mp);
                else if (t is ReferenceTo rf)
                    ReferenceTo(rf); 
                --this.depth;
                return;
            }

            if (t is FunctionType ft && ft.ReturnValue != null)
            {
                SpecifierQualifierList(ft.ReturnValue.DataType);
                --this.depth;
                return;
            }
            if (t is ArrayType at)
            {
                SpecifierQualifierList(at.ElementType);
            }
            else
            {
                TypeSpecifier(t);
            }
            --this.depth;
        }

        private DataType StripPointerOperator(DataType dt)
        {
            var pt = dt as Pointer;
            var mp = dt as MemberPointer;
            while (pt != null || mp != null)
            {
                if (pt != null)
                    dt = pt.Pointee;
                else
                    dt = mp!.Pointee;
                pt = dt as Pointer;
                mp = dt as MemberPointer;
            }
            if (dt is EquivalenceClass eq && eq.DataType != null)
                dt = eq.DataType;
            return dt;
        }

        /* parameter-type-list:
              parameter-list
              parameter-list , ...

           parameter-list:
              parameter-declaration
              parameter-list , parameter-declaration

           parameter-declaration:
              declaration-specifiers declarator
              declaration-specifiers abstract-declarator(opt)   */

        void ParameterTypeList(FunctionType? ft)
        {
            var name = declaredName;
            Formatter.Write('(');
            if (ft == null || ft.Parameters == null || ft.Parameters.Length == 0)
            {
                // fmt.Write("void");      // In C, 0-parameter functions use 'void'
            }
            else
            {
                bool first = true;
                for (int i = 0; i < ft.Parameters.Length; ++i)
                {
                    if (!first)
                        Formatter.Write(", ");
                    first = false;
                    declaredName = ft.Parameters[i].Name;
                    DeclarationSpecifiers(ft.Parameters[i].DataType);
                    if (declaration && !string.IsNullOrEmpty(declaredName))
                        Declarator(ft.Parameters[i].DataType);
                    else
                        AbstractDeclarator(ft.Parameters[i].DataType);
                }
            }
            Formatter.Write(')');
            declaredName = name;
        }

        /* abstract-declarator:
              pointer
              pointer(opt) direct-abstract-declarator  */

        void AbstractDeclarator(DataType dt)
        {
            if (this.depth > 50)
                return;         //$BUG: discover cause of the deep recursion?
            ++this.depth;
            if (dt is Pointer pt)
            {
                var pointee = pt.Pointee;
                if (pointee is EquivalenceClass eq && eq.DataType != null)
                    pointee = eq.DataType;
                if (pointee is ArrayType ||
                    pointee is FunctionType)
                    Formatter.Write(')');
                dt = pointee;
            }
            DirectAbstractDeclarator(dt);
            --this.depth;
        }

        /* direct-abstract-declarator:
              ( abstract-declarator )
              direct-abstract-declarator(opt) [ assignment-expression(opt) ]
              direct-abstract-declarator(opt) [ * ]
              direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */

        void DirectAbstractDeclarator(DataType t)
        {
            if (t is Pointer)
            {
                AbstractDeclarator(t);
            }
            else if (t is FunctionType ft)
            {
                ParameterTypeList(ft);
                //DirectAbstractDeclarator(ft);
            }
            else if (t is ArrayType at)
            {
                Formatter.Write('[');
                if (at.Length != 0)
                {
                    Formatter.Write(at.Length);
                }
                Formatter.Write(']');
                DirectAbstractDeclarator(at.ElementType);
            }
            else
            {
                return;
            }
        }

        /* type-name:
              specifier-qualifier-list  abstract-declarator(opt)  */

        void TypeName(DataType t)
        {
            SpecifierQualifierList(t);
            AbstractDeclarator(t);
        }

        /* storage-class-specifier:
              typedef
              extern
              static
              auto
              register  */

        //void StorageClassSpecifier(tree t)
        //{
        //    //if (TREE_CODE(t) == TYPE_DECL)
        //    //    fmt.Write("typedef");
        //    //else if (DECL_P(t))
        //    //{
        //    //    if (DECL_REGISTER(t))
        //    //        fmt.Write("register");
        //    //    else if (TREE_STATIC(t) && TREE_CODE(t) == VAR_DECL)
        //    //        fmt.Write("static");
        //    //}
        //}

        /* function-specifier:
              inline   */

        void FunctionSpecifier(DataType dt)
        {
        //    if (TREE_CODE(t) == tree_code.FUNCTION_DECL && DECL_DECLARED_INLINE_P(t))
        //        fmt.Write("inline");
        }

        /* declaration-specifiers:
              storage-class-specifier declaration-specifiers(opt)
              type-specifier declaration-specifiers(opt)
              type-qualifier declaration-specifiers(opt)
              function-specifier declaration-specifiers(opt)  */

        void DeclarationSpecifiers(DataType dt)
        {
            // StorageClassSpecifier(t);
            FunctionSpecifier(dt);
            SpecifierQualifierList(dt);
        }

        /* direct-declarator
              identifier
              ( declarator )
              direct-declarator [ type-qualifier-list(opt) assignment-expression(opt) ]
              direct-declarator [ static type-qualifier-list(opt) assignment-expression(opt)]
              direct-declarator [ type-qualifier-list static assignment-expression ]
              direct-declarator [ type-qualifier-list * ]
              direct-declaratpr ( parameter-type-list )
              direct-declarator ( identifier-list(opt) )  */

        void DirectDeclarator(DataType dt)
        {
            if (declaration)
            {
                if (!string.IsNullOrEmpty(this.declaredName))
                {
                    SpaceForPointerOperator(dt);
                    Formatter.Write(this.declaredName ?? "");
                }
                AbstractDeclarator(dt);
                return;
            }
            if (dt is ArrayType at)
            {
                AbstractDeclarator(at.ElementType);
                return;
            }
            if (dt is FunctionType ft)
            {
                ParameterTypeList(ft);
                if (ft.ReturnValue != null)
                {
                    AbstractDeclarator(ft.ReturnValue.DataType);
                }
                return;
            }
        }

        void DirectDeclarator(FunctionType sig)
        {
            SpaceForPointerOperator(sig.ReturnValue!.DataType);
            Formatter.Write(declaredName ?? "");
            ParameterTypeList(null);
            AbstractDeclarator(sig.ReturnValue.DataType);
        }

        /* declarator:
              pointer(opt)  direct-declarator   */

        void Declarator(DataType dt)
        {
            //if (dt is PrimitiveType || dt is EnumType ||
            //    dt is StructureType || dt is UnionType)
            //{
            //    return;
            //}
            DirectDeclarator(dt);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(22,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(24,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(300,34): error CS0136: A local or parameter named 'pt' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(302,46): error CS0136: A local or parameter named 'mp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(311,34): error CS0128: A local variable or function named 'pt' is already defined in this scope,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(313,45): error CS0136: A local or parameter named 'mp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(315,43): error CS0136: A local or parameter named 'rf' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(304,31): error CS0165: Use of unassigned local variable 'rf',D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(312,29): error CS0165: Use of unassigned local variable 'pt',D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(22,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Core\Output\TypeReferenceFormatter.cs(24,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Core\Types\DataTypeComparer.cs
Description: Error: Unable to create valid SyntaxTree for document: DataTypeComparer.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (x is PrimitiveType ix && y is PrimitiveType iy)
			{
				return ix.Compare(iy);
			}
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (x is PrimitiveType ix && y is PrimitiveType iy)
			{
				return ix.Compare(iy);
			}
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace Reko.Core.Types
{
	/// <summary>
	/// Imposes a total ordering of DataTypes and compares two data types to 
    /// see if they are equal or less than each other.
	/// </summary>
	public class DataTypeComparer : IComparer<DataType>, IDataTypeVisitor<int>, IEqualityComparer<DataType>
	{
        private const int Prim = 0;
        private const int Enum = 1;
        private const int Ptr = 2;
        private const int MemPtr = 3;
        private const int Fn = 4;
        private const int Array = 5;
        private const int String = 6;
        private const int Struct = 7;
        private const int Union = 8;
        private const int TRef = 9;
        private const int TVar = 10;
        private const int EqClass = 11;
        private const int Code = 12;
        private const int Ref = 13;
        private const int Unk = 14;
        private const int Void = 15;

        private IDictionary<Tuple<DataType, DataType>, int> compareResult;

		private static DataTypeComparer ourGlobalComparer = new DataTypeComparer();

        public DataTypeComparer()
        {
            this.compareResult = new Dictionary<Tuple<DataType, DataType>, int>();
        }

        /// <summary>
        /// Implements a partial ordering on data types, where 
        /// primitives &lt; pointers &lt; arrays &lt; structs &lt; unions
        /// </summary>
        /// <remarks>
        /// </remarks>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public int Compare(DataType x, DataType y)
        {
            return Compare(x, y, 0);
        }

        public int Compare(DataType x, DataType y, int count)
        {
            var typePair = new Tuple<DataType, DataType>(x, y);

            int d;

            // avoid infinite recursion
            if (compareResult.TryGetValue(typePair, out d))
                return d;

            compareResult[typePair] = 0;
            d = CompareInternal(x, y, count);
            compareResult[typePair] = d;

            return d;
        }

        public int CompareInternal(DataType x, DataType y, int count)
        {
            if (count > 20)
            {
                Debug.WriteLine("Way too deep");     //$BUG: discover why datatypes recurse so deep.
                return 0;
            }
            int prioX = x.Accept(this);
			int prioY = y.Accept(this);
			int dPrio = prioX - prioY;
			if (dPrio != 0)
				return dPrio;

            if (x is VoidType)
                return 0;

            if (x is UnknownType unkX && y is UnknownType unkY)
                return unkX.Size.CompareTo(unkY.Size);
            if (x is UnknownType)
                return -1;
            if (y is UnknownType)
                return 1;

			PrimitiveType? ix = x as PrimitiveType;
			PrimitiveType? iy = y as PrimitiveType;
			if (ix != null && iy != null)
			{
				return ix.Compare(iy);
			}
			if (ix != null)
				return -1;
			if (iy != null)
				return 1;

            if (x is EnumType || y is EnumType)
                throw new NotImplementedException();

            CodeType? cx = x as CodeType;
            CodeType? cy = y as CodeType;
            if (cx != null && cy != null)
            {
                return 0; 
            }
            if (cx != null)
                return -1;
            if (cy != null)
                return 1;

			TypeVariable? tx = x as TypeVariable;
			TypeVariable? ty = y as TypeVariable;
			if (tx != null && ty != null)
			{
				return tx.Number - ty.Number;
			}

            TypeReference? tr_x = x as TypeReference;
            TypeReference? tr_y = y as TypeReference;
            if (tr_x != null && tr_y != null)
            {
                return StringComparer.InvariantCulture.Compare(tr_x.Name, tr_y.Name);
            }

			EquivalenceClass? ex = x as EquivalenceClass;
			EquivalenceClass? ey = y as EquivalenceClass;
			if (ex != null && ey != null)
			{
				return ex.Number - ey.Number;
			}

			Pointer? ptrX = x as Pointer;
			Pointer? ptrY = y as Pointer;
			if (ptrX != null && ptrY != null)
			{
				return Compare(ptrX.Pointee, ptrY.Pointee, ++count);
			}

			MemberPointer? mX = x as MemberPointer;
			MemberPointer? mY = y as MemberPointer;
			if (mX != null && mY != null)
			{
				int d = Compare(mX.BasePointer, mY.BasePointer, ++count);
				if (d != 0)
					return d;
				return Compare(mX.Pointee, mY.Pointee, ++count);
			}

            ReferenceTo? rX = x as ReferenceTo;
            ReferenceTo? rY = y as ReferenceTo;
            if (rX != null && rY != null)
            {
                return Compare(rX.Referent, rY.Referent, ++count);
            }

			StructureType? sX = x as StructureType;
			StructureType? sY = y as StructureType;
			if (sX != null && sY != null)
			{
				return Compare(sX, sY, ++count);
			}

			UnionType? ux = x as UnionType;
			UnionType? uy = y as UnionType;
			if (ux != null && uy != null)
			{
				return Compare(ux, uy, ++count);
			}
			ArrayType? ax = x as ArrayType;
			ArrayType? ay = y as ArrayType;
			if (ax != null && ay != null)
			{
				return Compare(ax, ay, ++count);
			}

            StringType? strX = x as StringType;
            StringType? strY = y as StringType;
            if (strX != null && strY != null)
            {
                return Compare(strX, strY, ++count);
            }

            FunctionType? fnX = x as FunctionType;
            FunctionType? fnY = y as FunctionType;
            if (fnX != null && fnY != null)
            {
                return Compare(fnX, fnY, ++count);
            }
			throw new NotImplementedException(string.Format("NYI: comparison between {0} and {1}", x.GetType(), y.GetType()));
		}

		public int Compare(UnionType x, UnionType y, int count)
		{
			int d;
			d = x.Alternatives.Count - y.Alternatives.Count;
			if (d != 0)
				return d;
			++count;
            for (int i = 0; i < x.Alternatives.Count; ++i)
            {
				UnionAlternative ax = x.Alternatives.Values[i];
                UnionAlternative ay = y.Alternatives.Values[i];
				d = Compare(ax.DataType, ay.DataType, count);
				if (d != 0)
					return d;
			}
			return 0;
		}

		public int Compare(ArrayType x, ArrayType y, int count)
		{
			int d = Compare(x.ElementType, y.ElementType, ++count);
			if (d != 0)
				return d;
			return x.Length - y.Length;
		}

        public int Compare(StringType x, StringType y, int count)
        {
            int d = Compare(x.ElementType, y.ElementType, ++count);
            if (d != 0)
                return d;
            if (x.LengthPrefixType == null && y.LengthPrefixType == null)
                return 0;
            if (x.LengthPrefixType == null)
                return -1;
            if (y.LengthPrefixType == null)
                return 1;
            return Compare(x.LengthPrefixType, y.LengthPrefixType, ++count);
        }

		public int Compare(StructureType x, StructureType y, int count)
		{
			int d;
			if (x.Size > 0 && y.Size > 0)
			{
				d = x.Size - y.Size;
				if (d != 0)
					return d;
			}
			d = x.Fields.Count - y.Fields.Count;
			if (d != 0)
				return d;

			++count;
			IEnumerator<StructureField> ex = x.Fields.GetEnumerator();
            IEnumerator<StructureField> ey = y.Fields.GetEnumerator();
			while (ex.MoveNext())
			{
				ey.MoveNext();
				StructureField fx = ex.Current;
				StructureField fy = ey.Current;
				d = fx.Offset - fy.Offset;
				if (d != 0)
					return d;
				d = Compare(fx.DataType, fy.DataType, count);
				if (d != 0)
					return d;
			}
			return 0;
		}

        public int Compare(FunctionType x, FunctionType y, int count)
        {
            int d = x.Parameters!.Length - y.Parameters!.Length;
            if (d != 0)
                return d;
            ++count;
            for (int i = 0; i < x.Parameters.Length; ++i)
            {
                d = Compare(x.Parameters[i].DataType, y.Parameters[i].DataType, count);
                if (d != 0)
                    return d;
            }
            return Compare(x.ReturnValue!.DataType, y.ReturnValue!.DataType, count);
        }

        public bool Equals(DataType a, DataType b)
        {
            return Compare(a, b) == 0;
        }

        public int GetHashCode(DataType dt)
        {
            switch (dt)
            {
            case PrimitiveType pt:
                return pt.GetHashCode();
            case UnknownType _:
                return dt.GetType().GetHashCode();
            case Pointer ptr:                ;
                return GetHashCode(ptr.Pointee) * 11 ^ ptr.GetType().GetHashCode();
            case ReferenceTo rt:
                return GetHashCode(rt.Referent) * 11 ^ rt.GetType().GetHashCode();
            case FunctionType ft:
                if (ft.ParametersValid)
                {
                    int hash = 0;
                    if (ft.ReturnValue != null)
                    {
                        hash = GetHashCode(ft.ReturnValue.DataType);
                    }
                    foreach (var p in ft.Parameters!)
                    {
                        hash = hash * 11 ^ GetHashCode(p.DataType);
                    }
                    return hash;
                }
                else
                {
                    return ft.ReturnAddressOnStack + ft.StackDelta;
                }
            }
            return dt.GetType().GetHashCode();
        }

		#region IDataTypeVisitor Members /////////////////////////////////////////

		public int VisitArray(ArrayType at)
		{
			return Array;
		}

        public int VisitClass(ClassType ct)
        {
            throw new NotImplementedException();
        }

        public int VisitCode(CodeType c)
        {
            return Code;
        }

        public int VisitEnum(EnumType e)
        {
            return Enum;
        }

		public int VisitEquivalenceClass(EquivalenceClass eq)
		{
			return EqClass;
		}

		public int VisitFunctionType(FunctionType ft)
		{
			return Fn;
		}

		public int VisitMemberPointer(MemberPointer memptr)
		{
			return MemPtr;
		}

		public int VisitPrimitive(PrimitiveType pt)
		{
			return Prim;
		}

        public int VisitString(StringType str)
        {
            return String;
        }

		public int VisitStructure(StructureType str)
		{
			return Struct;
		}

		public int VisitPointer(Pointer ptr)
		{
			return Ptr;
		}

        public int VisitReference(ReferenceTo refTo)
        {
            return Ref;
        }

        public int VisitTypeReference(TypeReference typeref)
        {
            return TRef;
        }

		public int VisitTypeVariable(TypeVariable tv)
		{
			return TVar;
		}

		public int VisitUnion(UnionType ut)
		{
			return Union;
		}

		public int VisitUnknownType(UnknownType ut)
		{
			return Unk;
		}

        public int VisitVoidType(VoidType vt)
        {
            return Void;
        }
		#endregion

        //$REVIEW: this is thread-unsafe. We keep it because we have really deep type comparisons due to
        // unresolved bugs in type inference. Once those are resolved, performance should improve.
		public static DataTypeComparer Instance => ourGlobalComparer;
	}
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Core\Types\Unifier.cs
Description: Error: Unable to create valid SyntaxTree for document: Unifier.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (a is PrimitiveType pa && b is PrimitiveType pb)
			{
				if (pa.Size != pb.Size)
					return false;
				return (pa.Domain &  pb.Domain) != 0;
			}
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (a is PrimitiveType pa && b is PrimitiveType pb)
			{
				if (pa.Size != pb.Size)
					return false;
				return (pa.Domain &  pb.Domain) != 0;
			}
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core;
using Reko.Core.Expressions;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Reko.Core.Types
{
	/// <summary>
	/// Performs type unification, returning a general unifier for the two
    /// data type parameters.
	/// </summary>
	public class Unifier
	{
        private static readonly TraceSwitch classTrace = new TraceSwitch(nameof(Unifier), "Traces unifier progress") { Level = TraceLevel.Off }; 

		private readonly TypeFactory factory;
        private readonly TraceSwitch trace;
		private readonly IDictionary<Tuple<DataType, DataType>, bool> cache = new Dictionary<Tuple<DataType, DataType>, bool>();

        public Unifier()
            : this(new TypeFactory(), classTrace)
        {
        }

        public Unifier(TypeFactory factory)
            : this(factory, classTrace)
        {
        }

		public Unifier(TypeFactory factory, TraceSwitch trace)
		{
			this.factory = factory;
            this.trace = trace;
        }

		public bool AreCompatible(DataType a, DataType b)
		{
			return AreCompatible(a, b, 0);
		}
		
		private bool AreCompatible(DataType a, DataType b, int depth)
		{
			var typePair = new Tuple<DataType, DataType>(a, b);

			if (cache.TryGetValue(typePair, out bool d))
				return d;

			d = DoAreCompatible(a, b, depth);
			cache[typePair] = d;

			return d;
		}

		private bool DoAreCompatible(DataType a, DataType b, int depth)
		{
			if (a == null || b == null)
				return false;

            if (depth > 20)
            {
                trace.Error("Way too deep");     //$BUG: discover why datatypes recurse so deep.
                return true;
            }
			
			PrimitiveType? pa = a as PrimitiveType;
			PrimitiveType? pb = b as PrimitiveType;
			if (pa != null && pb != null)
			{
				if (pa.Size != pb.Size)
					return false;
				return (pa.Domain &  pb.Domain) != 0;
			}

            TypeReference? tra = a as TypeReference;
            TypeReference? trb = b as TypeReference;
            if (tra != null && trb != null)
                return tra == trb;
            if (tra != null)
                return AreCompatible(tra.Referent, b, ++depth);
            if (trb != null)
                return AreCompatible(a, trb.Referent, ++depth);

			TypeVariable? tva = a as TypeVariable;
			TypeVariable? tvb = b as TypeVariable;
			if (tva != null && tvb != null)
			{
				return tva.Number == tvb.Number;
			}

			EquivalenceClass? eqA = a as EquivalenceClass;
			EquivalenceClass? eqB = b as EquivalenceClass;
			if (eqA != null && eqB != null)
			{
				return eqA.Number == eqB.Number;
			}

			Pointer? ptrA = a as Pointer;
			Pointer? ptrB = b as Pointer;
			if (ptrA != null)
				return IsCompatibleWithPointer(ptrA, b, ++depth);
			if (ptrB != null)
				return IsCompatibleWithPointer(ptrB, a, ++depth);

			MemberPointer? mpA = a as MemberPointer;
			MemberPointer? mpB = b as MemberPointer;
			if (mpA != null)
				return IsCompatibleWithMemberPointer(mpA, b, ++depth);
			if (mpB != null)
				return IsCompatibleWithMemberPointer(mpB, a, ++depth);

			StructureType? sa = a as StructureType;
			StructureType? sb = b as StructureType;
			if (sa != null && sb != null)
			{
				return AreCompatible(sa, sb);
			}

            ArrayType? aa = a as ArrayType;
			ArrayType? ab = b as ArrayType;
			if (aa != null && ab != null)
			{
				return AreCompatible(aa.ElementType, ab.ElementType, ++depth);
			}

			UnionType? ua = a as UnionType;
			UnionType? ub = b as UnionType;
			if (ua != null && ub != null)
				return true;

			FunctionType? fa = a as FunctionType;
			FunctionType? fb = b as FunctionType;
			if (fa != null && fb != null)
			{
                if (fa.ParametersValid != fb.ParametersValid)
                    return false;
				return fa.Parameters!.Length == fb.Parameters!.Length;
			}

            CodeType? ca = a as CodeType;
            CodeType? cb = a as CodeType;
            if (ca != null && cb != null)
            {
                return true;
            }
            if (a is UnknownType unkA)
            {
                if (unkA.Size == 0 || a.Size == b.Size)
                    return true;
            }
            if (b is UnknownType unkB)
            {
                if (unkB.Size == 0 || a.Size == b.Size)
                    return true;
            }
            return false;
		}

		private bool AreCompatible(StructureType a, StructureType b)
		{
			if (a.Size > 0 && b.Size > 0)
			{
				return a.Size == b.Size;
			}
			return true;
		}

		private bool IsCompatibleWithPointer(Pointer ptrA, DataType b, int depth)
		{
            if (b is Pointer ptrB)
            {
                if (AreCompatible(ptrA.Pointee, ptrB.Pointee, ++depth))
                    return true;
                var arrayA = ptrA.Pointee as ArrayType;
                var arrayB = ptrB.Pointee as ArrayType;
                if (arrayA != null)
                    return AreCompatible(arrayA.ElementType, ptrB.Pointee, ++depth);
                else if (arrayB != null)
                    return AreCompatible(ptrA.Pointee, arrayB.ElementType, ++depth);
                else
                    return false;
            }
            if (b is PrimitiveType pb)
            {
                if ((pb.Domain & Domain.Selector | Domain.Pointer) != 0 && pb.Size == ptrA.Size)
                    return true;
            }
            return false;
		}

		private bool IsCompatibleWithMemberPointer(MemberPointer mpA, DataType b, int depth)
		{
            if (b is MemberPointer mpB)
                return
                    AreCompatible(mpA.BasePointer, mpB.BasePointer, ++depth) &&
                    AreCompatible(mpA.Pointee, mpB.Pointee, ++depth);
            if (b is PrimitiveType pb && pb.BitSize == mpA.BitSize)
            {
                if (pb == PrimitiveType.Word16 || pb == PrimitiveType.Word32 ||
                    pb.Domain == Domain.Pointer ||
                    pb.Domain == Domain.Selector ||
                    pb.Domain == Domain.Offset)
                    return true;
            }
            return false;
		}

        private int recDepth;

        //$TODO: change the signature to disallow nulls.
		public DataType? Unify(DataType? a, DataType? b)
		{
            if (++recDepth > 100)
            {
                --recDepth;
                trace.Error("Unifier: exceeded stack depth, giving up");
                if (a == null && b == null)
                    return null;
                if (a == null)
                    return b;
                if (b == null)
                    return a;
                return factory.CreateUnionType(null, null, new[] { a, b });
            }
            var u = UnifyInternal(a, b);
            --recDepth;
            return u;
		}

		private DataType? UnifyInternal(DataType? a, DataType? b)
		{
			if (a == null)
				return b;
			if (b == null)
				return a;

			if (a == b)
				return a;

            if (a is UnknownType)
            {
                if (a.Size == 0 || a.Size == b.Size)
                    return b;
            }
            if (b is UnknownType)
            {
                if (b.Size == 0 || a.Size == b.Size)
                    return a;
            }

            if (a is VoidType)
                return b;
            if (b is VoidType)
                return a;

            UnionType? ua = a as UnionType;
			UnionType? ub = b as UnionType;
			if (ua != null && ub != null)
			{
				UnionType u2 = UnifyUnions(ua, ub);
				return u2.Simplify();
			}
			if (ua != null)
			{
				UnifyIntoUnion(ua, b);
				return ua.Simplify();
			}
			if (ub != null)
			{
				UnifyIntoUnion(ub, a);
				return ub.Simplify();
			}

			PrimitiveType? pa = a as PrimitiveType;
			PrimitiveType? pb = b as PrimitiveType;
			if (pa != null && pb != null)
			{
				if (pa == pb)
					return pa;

                return UnifyPrimitives(pa, pb);
			}

			TypeVariable? tA = a as TypeVariable;
			TypeVariable? tB = b as TypeVariable;
            if (tA != null && tB != null)
            {
                return UnifyTypeVariables(tA, tB);
            }

            TypeReference? trA = a as TypeReference;
            TypeReference? trB = b as TypeReference;
            if (trA != null && trB != null)
            {
                if (trA == trB)
                    return trA;
                else 
                    return MakeUnion(a, b);
            }
            if (trA != null)
            {
                if (AreCompatible(trA.Referent, b))
                {
                    return new TypeReference(trA.Name, UnifyInternal(trA.Referent, b)!);
                }
            }
            if (trB != null)
            {
                if (AreCompatible(a, trB.Referent))
                {
                    return new TypeReference(trB.Name, UnifyInternal(trB.Referent, a)!);
                }
            }

			EquivalenceClass? eqA = a as EquivalenceClass;
			EquivalenceClass? eqB = b as EquivalenceClass;
			if (eqA != null && eqB != null)
			{
				if (eqA.Number == eqB.Number)
					return eqA;
				else
					return MakeUnion(eqA, eqB);
			}

			Pointer? ptrA = a as Pointer;
			Pointer? ptrB = b as Pointer;
			if (ptrA != null && ptrB != null)
			{
				DataType dt = UnifyInternal(ptrA.Pointee, ptrB.Pointee)!;
				return new Pointer(dt, Math.Max(ptrA.BitSize, ptrB.BitSize));
			}
            if (ptrA != null)
            {
                var dt = UnifyPointer(ptrA, b);
                if (dt != null)
                    return dt;
            }
            if (ptrB != null)
            {
                var dt = UnifyPointer(ptrB, a);
                if (dt != null)
                    return dt;
            }

			MemberPointer? mpA = a as MemberPointer;
			MemberPointer? mpB = b as MemberPointer;
			if (mpA != null && mpB != null)
			{
				DataType baseType = UnifyInternal(mpA.BasePointer, mpB.BasePointer)!;
				DataType pointee = UnifyInternal(mpA.Pointee, mpB.Pointee)!;
				return new MemberPointer(baseType, pointee, mpB.BitSize);
			}
			if (mpA != null)
			{
				var dt = UnifyMemberPointer(mpA, b);
                if (dt != null)
                    return dt;
			}
			if (mpB != null)
			{
				var dt = UnifyMemberPointer(mpB, a);
                if (dt != null)
                    return dt;
			}

			FunctionType? funA = a as FunctionType;
			FunctionType? funB = b as FunctionType;
			if (funA != null && funB != null)
			{
				return UnifyFunctions(funA, funB);
			}
            if (funA != null && b is CodeType)
            {
                return funA;
            }
            if (funB != null && a is CodeType)
            {
                return funB;
            }

			ArrayType? arrA = a as ArrayType;
			ArrayType? arrB = b as ArrayType;
			if (arrA != null && arrB != null)
			{
				return UnifyArrays(arrA, arrB);
			}
			if (arrA != null && arrA.ElementType.Size >= b.Size)
			{
				arrA.ElementType = Unify(arrA.ElementType, b)!;
				return arrA;
			}
			if (arrB != null && arrB.ElementType.Size >= a.Size)
			{
				arrB.ElementType = Unify(arrB.ElementType, a)!;
				return arrB;
			}

			StructureType? strA = a as StructureType;
			StructureType? strB = b as StructureType;
			if (strA != null && strB != null)
			{
				return UnifyStructures(strA, strB);
			}
			if (strA != null && (strA.Size == 0 || strA.Size >= b.Size))
			{
                MergeIntoStructure(b, strA);
				return strA;
			}
			if (strB != null && (strB.Size == 0 || strB.Size >= a.Size))
			{
                MergeIntoStructure(a, strB);
				return strB;
			}
			if (strA != null || strB != null)
			{
				return MakeUnion(a, b);
			}
            CodeType? ca = a as CodeType;
            CodeType? cb = b as CodeType;
            if (ca != null && cb != null)
            {
                return ca;
            }
            if (tA != null)
            {
                return UnifyTypeVariable(tA, b);
            }
            if (tB != null)
            {
                return UnifyTypeVariable(tB, a);
            }
            return MakeUnion(a, b);
		}

        private DataType UnifyPrimitives(PrimitiveType pa, PrimitiveType pb)
        {
            Domain d = pa.Domain & pb.Domain;
            if (d != 0 && pa.BitSize == pb.BitSize)
            {
                return PrimitiveType.Create(d, pa.BitSize);
            }
            if (pa.Domain == Domain.SegPointer && pb.BitSize == 16)
                return pa;
            return MakeUnion(pa, pb);
        }

        private void MergeIntoStructure(DataType a, StructureType str)
        {
            StructureField? f = str.Fields.AtOffset(0);
            if (f != null)
            {
                f.DataType = Unify(a, f.DataType)!;
            }
            else
            {
                str.Fields.Add(0, a);
            }
        }

		public DataType UnifyArrays(ArrayType a, ArrayType b)
		{
			if (a.ElementType.Size == b.ElementType.Size)
			{
				int cElems = a.Length;
				if (cElems < b.Length)
					cElems = b.Length;
				return new ArrayType(Unify(a.ElementType, b.ElementType)!, cElems);
			}
			return MakeUnion(a, b);
		}

		public void UnifyIntoUnion(UnionType u, DataType dt)
		{
			foreach (UnionAlternative alt in u.Alternatives.Values)
			{
				if (AreCompatible(alt.DataType, dt))
				{
					alt.DataType = Unify(alt.DataType, dt)!;
					return;
				}
			}
			u.Alternatives.Add(new UnionAlternative(dt, u.Alternatives.Count));
		}

		public DataType UnifyFunctions(FunctionType a, FunctionType b)
		{
            if (!a.ParametersValid && !b.ParametersValid)
            {
                return a;
            }
            if (!a.ParametersValid)
            {
                return b;
            }
            if (!b.ParametersValid)
            {
                return a;
            }
			if (a.Parameters!.Length != b.Parameters!.Length)
			{
				return MakeUnion(a, b);
			}
			DataType ret = Unify(a.ReturnValue!.DataType, b.ReturnValue!.DataType)!;
			Identifier [] args = new Identifier[a.Parameters.Length];
			for (int i = 0; i < args.Length; ++i)
			{
				var dt = Unify(a.Parameters[i].DataType, b.Parameters[i].DataType)!;
                var name = a.Parameters[i].Name;
                args[i] = new Identifier(name, dt, a.Parameters[i].Storage);   //$BUG: unify storages!
			}
			return factory.CreateFunctionType(new Identifier("", ret, a.ReturnValue.Storage), args);
		}

		/// <summary>
		/// Unifies two structures by merging the fields in offset order.
		/// </summary>
		/// <remarks>
		/// Fields are taken from 
		/// </remarks>
		/// <param name="a"></param>
		/// <param name="b"></param>
		/// <returns></returns>
		public DataType UnifyStructures(StructureType a, StructureType b)
		{
			int newSize = 0;
			if (a.Size != 0 && b.Size != 0)
			{
				if (a.Size != b.Size)
				{
					return MakeUnion(a, b);
				}
				else
				{
					newSize = a.Size;
				}
			} 
			else if (a.Size != 0)
			{
				newSize = a.Size;
			}
			else if (b.Size != 0)
			{
				newSize = b.Size;
			}

            string? name;
            if (a.Name != null)
			{
				if (b.Name != null && a.Name != b.Name)
                    return MakeUnion(a, b);
                else
					name = a.Name;
			}
			else
			{
				name = b.Name;
			}

			StructureType mem = factory.CreateStructureType(name, newSize);
			mem.IsSegment = (a.IsSegment || b.IsSegment);

			IEnumerator<StructureField> ea = a.Fields.GetEnumerator();
            IEnumerator<StructureField> eb = b.Fields.GetEnumerator();
			StructureField? fa = null;
			StructureField? fb = null;
			for (;;)
			{
				if (fa == null && ea.MoveNext())
					fa = ea.Current;
				if (fb == null && eb.MoveNext())
					fb = eb.Current;
			
				if (fa == null || fb == null)
					break;

                var nestedStructureUnifier = new NestedStructureUnifier(this);
                if (nestedStructureUnifier.Match(fa, fb))
                {
                    nestedStructureUnifier.Unify();
                    fa = nestedStructureUnifier.NextFieldA;
                    fb = nestedStructureUnifier.NextFieldB;
                }
                else if (fa.Offset < fb.Offset)
				{
                    mem.Fields.Add(fa.Clone());
                    fa = null;
				}
				else if (fa.Offset > fb.Offset)
				{
                    mem.Fields.Add(fb.Clone());
					fb = null;
				}
				else
				{
                    var fieldType = Unify(fa.DataType, fb.DataType)!;
                    if (!TryMakeFieldName(fa, fb, out string fieldName))
                        throw new NotSupportedException(
                            string.Format(
                                "Failed to unify field '{0}' in structure '{1}' with field '{2}' in structure '{3}'.",
                                fa.Name, a, fb.Name, b));
                    mem.Fields.Add(fa.Offset, fieldType, fieldName);
					fa = null;
					fb = null;
				}
			}
			if (fa != null)
			{
				mem.Fields.Add(fa);
				while (ea.MoveNext())
				{
					StructureField f = ea.Current;
					mem.Fields.Add(f.Clone());
				}
			}
			if (fb != null)
			{
				mem.Fields.Add(fb);
				while (eb.MoveNext())
				{
					StructureField f = eb.Current;
					mem.Fields.Add(f.Clone());
				}
			}
            mem.ForceStructure = a.ForceStructure | b.ForceStructure;
			return mem;
		}

        private bool TryMakeFieldName(StructureField fa, StructureField fb, out string name)
        {
            name = null!;
            if (fa.IsNameSet && fb.IsNameSet && fa.Name != fb.Name)
                return false;
            if (fa.IsNameSet)
                name = fa.Name;
            if (fb.IsNameSet)
                name = fb.Name;
            return true;
        }

        class NestedStructureUnifier
        {
            private readonly Unifier unifier;
            private StructureField? fNestedStruct;
            private StructureField? fOther;
            private StructureField? fa;
            private StructureField? fb;


            public NestedStructureUnifier(Unifier unifier)
            {
                this.unifier = unifier;
            }

            public bool Match(StructureField fa, StructureField fb)
            {
                this.fa = fa;
                this.fb = fb;
                this.fNestedStruct = null;
                this.fOther = null;
                this.NextFieldA = null;
                this.NextFieldB = null;
                var strFa = fa.DataType.TypeReferenceAs<StructureType>();
                var strFb = fb.DataType.TypeReferenceAs<StructureType>();
                // only one field should be nested structure
                if (
                    (strFa == null && strFb == null) ||
                    (strFa != null && strFb != null))
                    return false;

                // check which of two fields is nested structure and store it
                // and other field in corresponding variables.
                int strSize;
                if (strFa != null)
                {
                    fNestedStruct = fa;
                    fOther = fb;
                    strSize = strFa.GetInferredSize();
                }
                else
                {
                    fNestedStruct = fb;
                    fOther = fa;
                    strSize = strFb!.GetInferredSize();
                }

                // check if other field is inside nested structure
                return (
                    fOther.Offset >= fNestedStruct.Offset &&
                    fOther.Offset < fNestedStruct.Offset + strSize);
            }

            public void Unify()
            {
                var str = unifier.factory.CreateStructureType(null, 0);
                str.Fields.Add(
                    fOther!.Offset - fNestedStruct!.Offset,
                    fOther.DataType);

                var fieldType = unifier.Unify(fNestedStruct.DataType, str)!;
                var field = new StructureField(
                    fNestedStruct.Offset,
                    fieldType,
                    fNestedStruct.Name);
                NextFieldA = (fOther == fa) ? null : field;
                NextFieldB = (fOther == fb) ? null : field;
            }

            public StructureField? NextFieldA { get; private set; }
            public StructureField? NextFieldB { get; private set; }
        }

        public DataType? UnifyPointer(Pointer ptrA, DataType b)
		{
            if (b is PrimitiveType pb)
            {
                if ((ptrA.Size == 0 || pb.Size == 0 || ptrA.Size == pb.Size) &&
                    (pb.Domain & Domain.Pointer | Domain.Selector) != 0)
                {
                    return ptrA.Clone();
                }
            }
            return null;
		}

		public DataType? UnifyMemberPointer(MemberPointer mpA, DataType b)
		{
            if (b is PrimitiveType pb)
            {
                if (pb == PrimitiveType.Word16 || pb == PrimitiveType.Word32 ||
                    pb.Domain == Domain.Selector || pb.Domain == Domain.Offset)
                {
                    //$REVIEW: line above should be if (mpA.Size = b.Size .... as in UnifyPointer.
                    return mpA.Clone();
                }
            }
            return null;
		}

		public virtual DataType UnifyTypeVariables(TypeVariable tA, TypeVariable tB)
		{
			if (tA.Number == tB.Number)
				return tA;
			else
				return MakeUnion(tA, tB);
		}

        private DataType UnifyTypeVariable(TypeVariable tv, DataType dt)
        {
            // TypeVariable should be already unified with this DataType by
            // ExpressionTypeAscender so just return DataType
            return dt;
        }

        public UnionType UnifyUnions(UnionType u1, UnionType u2)
		{
			UnionType u = new UnionType(null, null);
			foreach (UnionAlternative a in u1.Alternatives.Values.ToList())
			{
				UnifyIntoUnion(u, a.DataType);
			}
			foreach (UnionAlternative a in u2.Alternatives.Values.ToList())
			{
				UnifyIntoUnion(u, a.DataType);
			}
			return u;
		}

		public UnionType MakeUnion(DataType a, DataType b)
		{
			return factory.CreateUnionType(null, null, new DataType [] { a, b } );
		}

		private DataType Nyi(DataType a, DataType b)
		{
            throw new NotImplementedException($"Don't know how to unify {a} with {b}.");
		}
	}
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 5 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\src\Decompiler\Analysis\ConstDivisionImplementedByMultiplication.cs
Description: Error: Unable to create valid SyntaxTree for document: ConstDivisionImplementedByMultiplication.cs. Caught exception: System.ArgumentException: Syntax node is not within syntax tree
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CheckSyntaxNode(CSharpSyntaxNode syntax)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 121
   at Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 197
   at Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitReturnStatement(ReturnStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Syntax node is not within syntax tree
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Reko.Core.Expressions;
using Reko.Core.Operators;
using Reko.Core.Code;
using Reko.Core;
using System.Linq;

namespace Reko.Analysis
{
    /// <summary>
    /// Undoes the transformation compilers sometimes do on integer constant
    /// divisions.
    /// </summary>
    /// <remarks>
    /// Compilers may transform a division 
    /// <code>
    /// a = b / c 
    /// </code>
    /// where c is a (small) integer constant into the corresponding
    /// <code>
    /// hi:lo = b * d 
    /// a = hi
    /// a = a >> sh
    /// </code>
    /// for speed. This transformation undoes such transformations into
    /// multiplications by a rational.
    /// </remarks>
    public class ConstDivisionImplementedByMultiplication
    {
        private readonly SsaState ssa;
        private readonly ExpressionEmitter m;
        private Identifier? idDst;
        private Expression? dividend;
        private Rational bestRational;
        private Identifier? idOrig;

        public ConstDivisionImplementedByMultiplication(SsaState ssa)
        {
            this.ssa = ssa;
            this.m = new ExpressionEmitter();
        }

        public void Transform()
        {
            foreach (var stm in ssa.Procedure.Statements)
            {
                if (Match(stm.Instruction))
                {
                    TransformInstruction();
                }
            }
        }

        /// <summary>
        /// Find the best rational that approximates the fraction 
        /// </summary>
        /// <param name="factor">Divisor &lt;1 1 scaled by 2^32.</param>
        /// <returns></returns>
        public static Rational FindBestRational(uint factor)
        {
            return Rational.FromDouble(factor * Math.Pow(2.0, -32));
        }

        /// <summary>
        /// Determine whether <paramref name="instr"/> is a match for 
        /// the pattern that is a constant division
        /// </summary>
        /// <remarks>
        /// The pattern is:
        /// <code>
        /// hi:lo = r * const
        /// hi = slice(hi:lo) (alias)
        /// hi = hi >> shift  (optional)
        /// </code>
        /// This transformation must be carried out before value propagation
        /// pushes the shift inside other operations.
        /// </remarks>
        /// <param name="instr"></param>
        /// <returns></returns>
        public bool Match(Instruction instr)
        {
            // Look for hi:lo = a * C
            if (!(instr is Assignment ass) ||
                !(ass.Dst.Storage is SequenceStorage dst) ||
                dst.Elements.Length != 2 ||
                !(ass.Src is BinaryExpression bin) ||
                !(bin.Operator is IMulOperator) ||
                !(bin.Right is Constant cRight) ||
                ass.Dst.DataType.Size <= bin.Left.DataType.Size)
            {
                return false;
            }

            this.idOrig = ass.Dst;
            this.idDst = FindAlias(ass.Dst, dst.Elements[0]);
            if (idDst == null)
                return false;

            var best = FindBestRational(cRight.ToUInt32());

            // There may be a subsequent SAR / SHR to increase 
            // the divisor.

            var idSlice = idDst;
            Constant? rShift = null;
            if (idSlice != null)
            {
                rShift = FindShiftUse(idSlice);
                if (rShift != null)
                {
                    best = best / (1 << rShift.ToInt32());
                }
            }
            this.bestRational = best;

            this.dividend = bin.Left;
            return true;
        }

        private Identifier? FindAlias(Identifier id, Storage regHead)
        {
            return (ssa.Identifiers[id].Uses
                .Select(u => u.Instruction)
                .OfType<AliasAssignment>()
                .Where(a => a.Dst.Storage == regHead)
                .Select(a => a.Dst)
                .FirstOrDefault());
        }

        private Constant? FindShiftUse(Identifier idSlice)
        {
            return ssa.Identifiers[idSlice]
                .Uses.Select(u => u.Instruction)
                .OfType<Assignment>()
                .Select(a =>
                {
                    if (a.Src is BinaryExpression b &&
                        b.Left == idSlice &&
                        (b.Operator == Operator.Sar || b.Operator == Operator.Shr))
                    {
                        return b.Right as Constant;
                    }
                    else
                    {
                        return null;
                    }
                })
                .Where(x => x != null)
                .FirstOrDefault();
        }

        private Identifier? FindSliceUse(Identifier id)
        {
            return ssa.Identifiers[id]
                .Uses.Select(u => u.Instruction)
                .OfType<Assignment>()
                .Select(a =>
                {
                    var s = a.Src as Slice;
                    if (s == null || s.Expression != id)
                        return null;
                    else
                        return a.Dst;
                })
                .Where(x => x != null)
                .FirstOrDefault();
        }

        public Assignment TransformInstruction()
        {
            var eNum = dividend!;
            if (bestRational.Numerator != 1)
            {
                eNum = m.IMul(
                    eNum,
                    Constant.Int32((int)bestRational.Numerator));
            }
            var sidOrig = ssa.Identifiers[idOrig!];
            var sidDst = ssa.Identifiers[idDst!];
            sidOrig.Uses.Remove(sidDst.DefStatement!);
            var ass = new Assignment(
                idDst!,
                m.SDiv(
                    eNum,
                    Constant.Int32((int)bestRational.Denominator)));

            sidDst.DefStatement!.Instruction = ass;
            return ass;
        }
    }
}
---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Decompiler\Analysis\SequenceIdentifierGenerator.cs
Description: Error: Unable to create valid SyntaxTree for document: SequenceIdentifierGenerator.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (seq.Expressions[0] is Identifier idHead && seq.Expressions[1] is Identifier idTail)
            {
                var sidHead = ssa.Identifiers[idHead];
                var sidTail = ssa.Identifiers[idTail];
                if (sidHead.DefStatement!.Instruction is DefInstruction &&
                    sidTail.DefStatement!.Instruction is DefInstruction)
                {
                    return ReplaceMkSequence(seq, stmCur!, sidHead, sidTail);
                }
            }
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (seq.Expressions[0] is Identifier idHead && seq.Expressions[1] is Identifier idTail)
            {
                var sidHead = ssa.Identifiers[idHead];
                var sidTail = ssa.Identifiers[idTail];
                if (sidHead.DefStatement!.Instruction is DefInstruction &&
                    sidTail.DefStatement!.Instruction is DefInstruction)
                {
                    return ReplaceMkSequence(seq, stmCur!, sidHead, sidTail);
                }
            }
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core.Code;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Reko.Core.Expressions;
using Reko.Core.Types;
using Reko.Core;
using System.Diagnostics;
using Reko.Core.Operators;

namespace Reko.Analysis
{
    /// <summary>
    /// Attempts to propagate sequence identifiers to the inputs
    /// and outputs of a procedure.
    /// </summary>
    public class SequenceIdentifierGenerator : InstructionTransformer
    {
        private readonly SsaTransform sst;
        private readonly SsaState ssa;
        private Statement? stmCur;      //$REFACTOR: context var.

        public SequenceIdentifierGenerator(SsaTransform sst)
        {
            this.sst = sst;
            this.ssa = sst.SsaState;
        }

        public void Transform()
        {
            foreach (var stm in sst.SsaState.Procedure.Statements.ToList())
            {
                this.stmCur = stm;
                stm.Instruction.Accept(this);
            }
        }

        public override Instruction TransformAssignment(Assignment ass)
        {
            if (!(ass.Dst.Storage is SequenceStorage seq))
                return ass;
            var sid = ssa.Identifiers[ass.Dst];
            var stores = sid.Uses
                .Select(u => ClassifyStore(u))
                .Where(u => u != null);
            var grps = from u in stores
                       orderby u.Statement.LinearAddress
                       group u by u.Statement.Block;
            foreach (var grp in grps)
            {
                ProcessAdjacentStores(sid, grp.ToArray());
            }
            return ass;
        }

        private void ProcessAdjacentStores(SsaIdentifier sid, StoreOffset[] storeOffset)
        {
            for (int i = 0; i < storeOffset.Length; ++i)
            {
                if (storeOffset[i] == null)
                    continue;
                var slice1a = GetSliceRhs(storeOffset[i].Store);
                var slice1b = GetSliceRhs(storeOffset[i].Store);
                if (slice1a != null || slice1b != null)
                {
                    for (int j = i + 1; j < storeOffset.Length; ++j)
                    {
                        var slice2a = GetSliceRhs(storeOffset[j].Store);
                        var slice2b = GetSliceRhs(storeOffset[j].Store);
                        if (slice1a != null && slice2b != null)
                        {
                            ReplaceStores(sid, storeOffset[i], storeOffset[j]);
                            storeOffset[i] = null!;
                            storeOffset[j] = null!;
                        }
                        else if (slice1b != null && slice2a != null)
                        {
                            throw new NotImplementedException();
                        }
                    }
                }
            }
        }

        private void ReplaceStores(SsaIdentifier sid, StoreOffset stoTail, StoreOffset stoHead)
        {
            if (Operator.Lt.ApplyConstants(stoTail.Offset, stoHead.Offset).ToBoolean())
            {
                stoTail.Store.Dst.DataType = sid.Identifier.DataType;
                stoTail.Store.Src = sid.Identifier;

                ssa.DeleteStatement(stoHead.Statement);
            }
            else
            {
                throw new NotImplementedException();
            }
        }

        private Slice? GetSliceRhs(Store store)
        {
            var slice = store.Src as Slice;
            return slice;
        }

        private class StoreOffset
        {
            public StoreOffset(Statement stm, Store store, Constant Offset)
            {
                this.Statement = stm;
                this.Store = store;
                this.Offset = Offset;
            }

            public readonly Statement Statement;
            public readonly Store Store;
            public readonly Constant Offset;
        }

        private StoreOffset? ClassifyStore(Statement stm)
        {
            if (!(stm.Instruction is Store store))
                return null;
            Expression ea;
            if (store.Dst is MemoryAccess access)
                ea = access.EffectiveAddress;
            else
            {
                if (store.Dst is SegmentedAccess segAccess)
                    ea = segAccess.EffectiveAddress;
                else
                    return null;
            }
            Constant? offset = null;
            if (ea is Identifier)
                offset = Constant.Zero(ea.DataType);
            else
            {
                if (ea is BinaryExpression bin)
                {
                    if (bin.Operator == Operator.IAdd || bin.Operator == Operator.ISub)
                    {
                        offset = bin.Right as Constant;
                    }
                }
            }
            if (offset == null)
                return null;
            return new StoreOffset(stm, store, offset);
        }

        public override Expression VisitMkSequence(MkSequence seq)
        {
            if (seq.Expressions.Length != 2)
                return seq; //$TODO: do this for longer sequences?
            var idHead = seq.Expressions[0] as Identifier;
            var idTail = seq.Expressions[1] as Identifier;
            if (idHead != null && idTail != null)
            {
                var sidHead = ssa.Identifiers[idHead];
                var sidTail = ssa.Identifiers[idTail];
                if (sidHead.DefStatement!.Instruction is DefInstruction &&
                    sidTail.DefStatement!.Instruction is DefInstruction)
                {
                    return ReplaceMkSequence(seq, stmCur!, sidHead, sidTail);
                }
            }
            return seq;
        }

        private Expression ReplaceMkSequence(MkSequence seq, Statement stmCur, SsaIdentifier sidHead, SsaIdentifier sidTail)
        {
            var idSeq = ssa.Procedure.Frame.EnsureSequence(
                seq.DataType,
                sidHead.OriginalIdentifier.Storage,
                sidTail.OriginalIdentifier.Storage);
            SsaIdentifier sidSeq = EnsureSequenceArgument(idSeq);
            sidSeq.Uses.Add(stmCur);
            RemoveUse(sidHead);
            RemoveUse(sidTail);
            return sidSeq.Identifier;
        }

        private SsaIdentifier EnsureSequenceArgument(Identifier idSeq)
        {
            if (!ssa.Identifiers.TryGetValue(idSeq, out SsaIdentifier sidSeq))
            {
                var b = ssa.Procedure.EntryBlock;
                var def = b.Statements.Add(b.Address.ToLinear(), null!);    //$REFACTOR this to SsaState.AddDefineStatement
                sidSeq = ssa.Identifiers.Add(idSeq, null, null, false);
                sidSeq.DefStatement = def;
                def.Instruction = new DefInstruction(sidSeq.Identifier);
            }
            return sidSeq;
        }

        private void RemoveUse(SsaIdentifier sid)
        {
            sid.Uses.Remove(stmCur!);
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 7 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\src\Decompiler\Analysis\StackPointerBackpropagator.cs
Description: Error: Unable to create valid SyntaxTree for document: StackPointerBackpropagator.cs. Caught exception: System.ArgumentException: Syntax node is not within syntax tree
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CheckSyntaxNode(CSharpSyntaxNode syntax)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 121
   at Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 42
   at Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 197
   at Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitReturnStatement(ReturnStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Syntax node is not within syntax tree
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core;
using Reko.Core.Code;
using Reko.Core.Expressions;
using Reko.Core.Operators;
using Reko.Core.Services;
using System.Collections.Generic;
using System.Linq;

namespace Reko.Analysis
{
    /// <summary>
    /// Backpropagate stack pointer from procedure return.
    /// Assumes that stack pointer at the end of procedure has the same
    /// value as at the start
    /// </summary>
    /// <example>
    /// If we have
    /// <code>
    ///     call eax; We do not know calling convention of this indirect call
    ///             ; So we do not know value of stack pointer after it
    /// cleanup:
    ///     pop esi
    ///     pop ebp
    ///     ret
    /// </code>
    /// then we could assume than stack pointer at "cleanup" label is
    /// "fp - 8"
    /// </example>
    // $REVIEW: It is highly unlikely that there is a procedure that
    // leaves the stack pointer at different values depending on what
    // path you took through it. Should we encounter such procedures in
    // a binary we might consider turning this analysis off with a user
    // switch.
    public class StackPointerBackpropagator
    {
        private readonly SsaState ssa;
        private readonly ExpressionEmitter m;
        private readonly DecompilerEventListener listener;

        public StackPointerBackpropagator(SsaState ssa, DecompilerEventListener listener)
        {
            this.ssa = ssa;
            this.m = new ExpressionEmitter();
            this.listener = listener;
        }

        /// <summary>
        /// First find use of stack pointer at procedure exit block.
        /// Check if its definition is like 'sp_at_exit = sp_previous + offset'
        /// and 'sp_previous' is trashed (usually after indirect calls). We
        /// assume that stack pointer at the end ('sp_at_exit') is 'fp'. So
        /// 'sp_previous' is 'fp - offset'. So we replace definition of
        /// 'sp_previous' with 'fp - offset'
        /// </summary>
        public void BackpropagateStackPointer()
        {
            foreach (var spAtExit in FindStackUsesAtExit(ssa.Procedure))
            {
                if (listener.IsCanceled())
                    return;
                BackpropagateStackPointer(spAtExit);
            }
        }

        private void BackpropagateStackPointer(Identifier spAtExit)
        {
            var spCur = spAtExit;
            var offset = 0;
            for (; ; )
            {
                if (listener.IsCanceled())
                    return;
                var (spPrevious, delta) = MatchStackOffsetPattern(spCur);
                if (spPrevious == null)
                    break;
                ReplaceStackDefinition(spCur, spPrevious, offset);
                offset -= delta;
                spCur = spPrevious;
            }
            if (IsTrashed(spCur))
            {
                ReplaceStackDefinition(spCur, null!, offset);   //$BUG: should not be null!
            }
        }

        private bool IsTrashed(Identifier sp)
        {
            var definition = ssa.Identifiers[sp].DefStatement;
            switch (definition?.Instruction)
            {
            case CallInstruction _:
            case PhiAssignment _:
                return true;
            default:
                return false;
            }
        }

        private (Identifier?, int) MatchStackOffsetPattern(Identifier sp)
        {
            (Identifier?, int) noMatch = (null, 0);
            var sid = ssa.Identifiers[sp];
            var def = sid.DefStatement!;
            if (!(def.Instruction is Assignment ass))
                return noMatch;
            if (!(ass.Src is BinaryExpression bin))
                return noMatch;
            if ((bin.Operator != Operator.IAdd &&
                bin.Operator != Operator.ISub))
                return noMatch;
            if (!(bin.Left is Identifier id))
                return noMatch;
            if (id.Storage != sp.Storage)
                return noMatch;
            if (!(bin.Right is Constant c))
                return noMatch;
            var offset = c.ToInt32();
            if (bin.Operator == Operator.ISub)
                offset = -offset;
            return (id, offset);
        }

        /// <summary>
        /// Replace definition of '<paramref name="sp"/>' with
        /// 'fp - <paramref name="frameOffset"/>'
        /// </summary>
        /// <param name="sp"></param>
        /// <param name="frameOffset"></param>
        private void ReplaceStackDefinition(Identifier sp, Identifier spPrev, int frameOffset)
        {
            var spDef = ssa.Identifiers[sp].DefStatement!;
            if (spDef.Instruction is Assignment ass)
            {
                var fp = ssa.Procedure.Frame.FramePointer;
                ssa.Identifiers[spPrev].Uses.Remove(spDef);
                ssa.Identifiers[fp].Uses.Add(spDef);
                ass.Src = m.AddSubSignedInt(fp, frameOffset);
            }
            else
            {
	           // insert new stack definition
	            InsertStackDefinition(sp, frameOffset, spDef);
                // Remove old stack definition
                RemoveDefinition(sp, spDef);
            }
        }

        private void InsertStackDefinition(
            Identifier stack,
            int frameOffset,
            Statement stmAfter)
        {
            var fp = ssa.Procedure.Frame.FramePointer;
            var pos = stmAfter.Block.Statements.IndexOf(stmAfter);
            var src = m.AddSubSignedInt(fp, frameOffset);
            var newStm = stmAfter.Block.Statements.Insert(
                pos + 1,
                stmAfter.LinearAddress,
                new Assignment(stack, src));
            ssa.Identifiers[stack].DefStatement = newStm;
            ssa.AddUses(newStm);
        }

        private void RemoveDefinition(Identifier id, Statement defStatement)
        {
            switch (defStatement.Instruction)
            {
            case CallInstruction ci:
                ci.Definitions.RemoveWhere(cb => cb.Expression == id);
                break;
            case PhiAssignment phi:
                ssa.DeleteStatement(defStatement);
                break;
            }
        }

        private Identifier FindStackUseAtExit(Procedure proc)
        {
            return proc.ExitBlock.Statements
                .Select(s => s.Instruction)
                .OfType<UseInstruction>()
                .Select(u => u.Expression)
                .OfType<Identifier>()
                .Where(id => id.Storage == proc.Architecture.StackRegister)
                .SingleOrDefault();
        }

        private IEnumerable<Identifier> FindStackUsesAtExit(Procedure proc)
        {
            var sp = FindStackUseAtExit(proc);
            if (sp == null)
                return new Identifier[] { };
            var def = ssa.Identifiers[sp].DefStatement;
            if (def?.Instruction is PhiAssignment phi)
                return phi.Src.Arguments
                    .Select(de => de.Value)
                    .OfType<Identifier>().Distinct();
            return new Identifier[] { sp };
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Evaluation;
using Reko.Core;
using Reko.Analysis;
using Reko.Core.Expressions;
using Reko.Core.Operators;
using Reko.Core.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using Reko.Core.Services;
using System.Diagnostics;
using System.Xml.Schema;
using Reko.Core.Code;
using Reko.Scanning;

namespace Reko.Evaluation 
{
    /// <summary>
    /// Partially evaluates expressions, using an <see cref="EvaluationContext"/> to obtain the values
    /// of identifiers and optionally modifies the expression being evaluated.
    /// </summary>
    public class ExpressionSimplifier : ExpressionVisitor<Expression>
    {
        private readonly SegmentMap segmentMap;
        private EvaluationContext ctx;
        private readonly ExpressionValueComparer cmp;
        private readonly ExpressionEmitter m;
        private readonly Unifier unifier;

        private readonly AddTwoIdsRule add2ids;
        private readonly Add_e_c_cRule addEcc;
        private readonly Add_mul_id_c_id_Rule addMici;
        private readonly ConstConstBin_Rule constConstBin;
        private readonly IdConstant idConst;
        private readonly IdCopyPropagationRule idCopyPropagation;
        private readonly IdBinIdc_Rule idBinIdc;
        private readonly SliceConstant_Rule sliceConst;
        private readonly SliceMem_Rule sliceMem;
        private readonly SliceSegmentedPointer_Rule sliceSegPtr;
        private readonly SliceShift sliceShift;
        private readonly Shl_add_Rule shAdd;
        private readonly Shl_mul_e_Rule shMul;
        private readonly ShiftShift_c_c_Rule shiftShift;
        private readonly NegSub_Rule negSub;
        private readonly Mps_Constant_Rule mpsRule;
        private readonly BinOpWithSelf_Rule binopWithSelf;
        private readonly ConstDivisionImplementedByMultiplication constDiv;
        private readonly IdProcConstRule idProcConstRule;
        private readonly ConvertConvertRule convertConvertRule;
        private readonly DistributedCastRule distributedCast;
        private readonly DistributedConversionRule distributedConvert;
        private readonly DistributedSliceRule distributedSlice;
        private readonly MkSeqFromSlices_Rule mkSeqFromSlicesRule;
        private readonly ComparisonConstOnLeft constOnLeft;
        private readonly SliceSequence sliceSeq;
        private readonly SliceConvert sliceConvert;
        private readonly LogicalNotFollowedByNegRule logicalNotFollowedByNeg;
        private readonly LogicalNotFromArithmeticSequenceRule logicalNotFromBorrow;
        private readonly UnaryNegEqZeroRule unaryNegEqZero;

        public ExpressionSimplifier(SegmentMap segmentMap, EvaluationContext ctx, DecompilerEventListener listener)
        {
            this.segmentMap = segmentMap ?? throw new ArgumentNullException(nameof(SegmentMap));
            this.ctx = ctx;
            this.cmp = new ExpressionValueComparer();
            this.m = new ExpressionEmitter();
            this.unifier = new Unifier();
            this.add2ids = new AddTwoIdsRule(ctx);
            this.addEcc = new Add_e_c_cRule(ctx);
            this.addMici = new Add_mul_id_c_id_Rule(ctx);
            this.idConst = new IdConstant(ctx, unifier, listener);
            this.idCopyPropagation = new IdCopyPropagationRule(ctx);
            this.idBinIdc = new IdBinIdc_Rule(ctx);
            this.sliceConst = new SliceConstant_Rule();
            this.sliceMem = new SliceMem_Rule();
            this.sliceSegPtr = new SliceSegmentedPointer_Rule(ctx);
            this.negSub = new NegSub_Rule();
            this.constConstBin = new ConstConstBin_Rule();
            this.shAdd = new Shl_add_Rule(ctx);
            this.shMul = new Shl_mul_e_Rule(ctx);
            this.shiftShift = new ShiftShift_c_c_Rule(ctx);
            this.mpsRule = new Mps_Constant_Rule(ctx);
            this.sliceShift = new SliceShift(ctx);
            this.binopWithSelf = new BinOpWithSelf_Rule();
            this.constDiv = new ConstDivisionImplementedByMultiplication(ctx);
            this.idProcConstRule = new IdProcConstRule(ctx);
            this.convertConvertRule = new ConvertConvertRule(ctx);
            this.distributedConvert = new DistributedConversionRule();
            this.distributedCast = new DistributedCastRule();
            this.distributedSlice = new DistributedSliceRule();
            this.mkSeqFromSlicesRule = new MkSeqFromSlices_Rule(ctx);
            this.constOnLeft = new ComparisonConstOnLeft();
            this.sliceSeq = new SliceSequence(ctx);
            this.sliceConvert = new SliceConvert();
            this.logicalNotFollowedByNeg = new LogicalNotFollowedByNegRule();
            this.logicalNotFromBorrow = new LogicalNotFromArithmeticSequenceRule();
            this.unaryNegEqZero = new UnaryNegEqZeroRule();
        }

        public bool Changed { get { return changed; } set { changed = value; } }
        private bool changed;

        private bool IsAddOrSub(Operator op)
        {
            return op == Operator.IAdd || op == Operator.ISub;
        }

        private bool IsIntComparison(Operator op)
        {
            return op == Operator.Eq || op == Operator.Ne ||
                   op == Operator.Ge || op == Operator.Gt ||
                   op == Operator.Le || op == Operator.Lt ||
                   op == Operator.Uge || op == Operator.Ugt ||
                   op == Operator.Ule || op == Operator.Ult;
        }

        private bool IsFloatComparison(Operator op)
        {
            return op == Operator.Feq || op == Operator.Fne ||
                   op == Operator.Fge || op == Operator.Fgt ||
                   op == Operator.Fle || op == Operator.Flt;
        }

        public static Constant SimplifyTwoConstants(BinaryOperator op, Constant l, Constant r)
        {
            var lType = (PrimitiveType)l.DataType;
            var rType = (PrimitiveType)r.DataType;
            return op.ApplyConstants(l, r);
        }

        public virtual Expression VisitAddress(Address addr)
        {
            return addr;
        }

        public virtual Expression VisitApplication(Application appl)
        {
            var args = new Expression[appl.Arguments.Length];
            for (int i = 0; i < appl.Arguments.Length; ++i)
            {
                var arg = appl.Arguments[i];
                args[i] = arg.Accept(this);
            }
            // Rotations-with-carries that rotate in a false carry 
            // flag can be simplified to shifts.
            if (appl.Procedure is ProcedureConstant pc && 
                pc.Procedure is IntrinsicProcedure intrinsic)
            {
                switch (intrinsic.Name)
                {
                case IntrinsicProcedure.RolC:
                    if (IsSingleBitRotationWithClearCarryIn(args))
                    {
                        Changed = true;
                        return new BinaryExpression(Operator.Shl, appl.DataType, args[0], args[1]);
                    }
                    break;
                case IntrinsicProcedure.RorC:
                    if (IsSingleBitRotationWithClearCarryIn(args))
                    {
                        Changed = true;
                        return new BinaryExpression(Operator.Shr, appl.DataType, args[0], args[1]);
                    }
                    break;
                case IntrinsicProcedure.Rol:
                    var rol = CombineRotations(intrinsic.Name, appl, args);
                    if (rol != null)
                    {
                        Changed = true;
                        return rol;
                    }
                    break;
                case IntrinsicProcedure.Ror:
                    var ror = CombineRotations(intrinsic.Name, appl, args);
                    if (ror != null)
                    {
                        Changed = true;
                        return ror;
                    }
                    break;
                }
            }
            appl = new Application(
                appl.Procedure.Accept(this),
                appl.DataType,
                args);
            return ctx.GetValue(appl);
        }

        private Expression? CombineRotations(string rotationName, Application appl, Expression[] args)
        {
            if (args[1] is Constant cOuter &&
                args[0] is Application appInner &&
                appInner.Procedure is ProcedureConstant pcInner &&
                pcInner.Procedure is IntrinsicProcedure intrinsicInner)
            {
                if (intrinsicInner.Name == rotationName)
                {
                    if (appInner.Arguments[1] is Constant cInner)
                    {
                        var cTot = Operator.IAdd.ApplyConstants(cOuter, cInner);
                        Changed = true;
                        return new Application(
                            appl.Procedure,
                            appl.DataType,
                            appInner.Arguments[0],
                            cTot);
                    }
                }
            }
            return null;
        }

        private static bool IsSingleBitRotationWithClearCarryIn(Expression[] args)
        {
            Debug.Assert(args.Length == 3);
            return args[1] is Constant sh &&
                                    sh.ToInt32() == 1 &&
                                    args[2] is Constant c &&
                                    c.IsIntegerZero;
        }

        public virtual Expression VisitArrayAccess(ArrayAccess acc)
        {
            return new ArrayAccess(
                acc.DataType,
                acc.Array.Accept(this),
                acc.Index.Accept(this));
        }

        public virtual Expression VisitBinaryExpression(BinaryExpression binExp)
        {
            // (+ id1 id1) ==> (* id1 2)

            if (add2ids.Match(binExp))
            {
                Changed = true;
                return add2ids.Transform().Accept(this);
            }
            if (binopWithSelf.Match(binExp))
            {
                Changed = true;
                return binopWithSelf.Transform(ctx).Accept(this);
            }
            if (distributedConvert.Match(binExp))
            {
                Changed = true;
                return distributedConvert.Transform(ctx).Accept(this);
            }
            if (distributedCast.Match(binExp))
            {
                Changed = true;
                return distributedCast.Transform(ctx).Accept(this);
            }
            if (distributedSlice.Match(binExp))
            {
                Changed = true;
                return distributedSlice.Transform(ctx).Accept(this);
            }

            var left = binExp.Left.Accept(this);
            var right = binExp.Right.Accept(this);
            Constant? cLeft = left as Constant;
            Constant? cRight = right as Constant;
            if (cLeft != null && BinaryExpression.Commutes(binExp.Operator))
            {
                cRight = cLeft; left = right; right = cLeft;
            }

            //$TODO: operands to binary operations appear to be
            // mismatched in some processors. Change the ctor
            // of BinaryExpression to catch this later.
            var sameBitsize = left.DataType.BitSize == right.DataType.BitSize;
            if (cRight != null)
            {
                // (- X 0) ==> X
                // (+ X 0) ==> X
                if (cRight.IsIntegerZero && IsAddOrSub(binExp.Operator))
                {
                    Changed = true;
                    return left;
                }
                if (binExp.Operator == Operator.Or)
                {
                    if (cRight.IsIntegerZero)
                    {
                        Changed = true;
                        return left;
                    }
                    // (| X 0xFFFF...F) ==> 0xFFFF...F
                    if (cRight.IsMaxUnsigned && sameBitsize && !CriticalInstruction.IsCritical(left))
                    {
                        ctx.RemoveExpressionUse(left);
                        Changed = true;
                        return right;
                    }
                }
                if (binExp.Operator == Operator.And)
                {
                    if (cRight.IsIntegerZero && sameBitsize && !CriticalInstruction.IsCritical(left))
                    {
                        ctx.RemoveExpressionUse(left);
                        Changed = true;
                        return cRight;
                    }
                    if (cRight.IsMaxUnsigned && sameBitsize)
                    {
                        Changed = true;
                        return left;
                    }
                }
                if (binExp.Operator == Operator.Xor)
                {
                    if (cRight.IsIntegerZero)
                    {
                        Changed = true;
                        return left;
                    }
                    if (cRight.IsMaxUnsigned && sameBitsize)
                    {
                        Changed = true;
                        return new UnaryExpression(Operator.Comp, left.DataType, left).Accept(this);
                    }
                }
            }

            //$REVIEW: this is evaluation! Shouldn't the be done by the evaluator?
            if (left == Constant.Invalid || right == Constant.Invalid)
                return Constant.Invalid;

            binExp = new BinaryExpression(binExp.Operator, binExp.DataType, left, right);
            if (constConstBin.Match(binExp))
            {
                Changed = true;
                return constConstBin.Transform();
            }
            Identifier? idLeft = left as Identifier;
            Identifier? idRight = right as Identifier;

            // (rel? id1 c) should just pass.

            if (IsIntComparison(binExp.Operator) && cRight != null && idLeft != null)
                return binExp;

            // Floating point expressions with "integer" constants 
            if (IsFloatComparison(binExp.Operator) && IsNonFloatConstant(cRight))
            {
                cRight = ctx.ReinterpretAsFloat(cRight!);
                right = cRight;
                binExp = new BinaryExpression(
                    binExp.Operator,
                    binExp.DataType,
                    binExp.Left,
                    cRight);
            }

            var binLeft = left as BinaryExpression;
            var cLeftRight = (binLeft != null) ? binLeft.Right as Constant : null;

            // (+ (+ e c1) c2) ==> (+ e (+ c1 c2))
            // (+ (- e c1) c2) ==> (+ e (- c2 c1))
            // (- (+ e c1) c2) ==> (- e (- c2 c1))
            // (- (- e c1) c2) ==> (- e (+ c1 c2))

            if (binLeft != null && cLeftRight != null && cRight != null)
            {
                if (IsAddOrSub(binExp.Operator) && IsAddOrSub(binLeft.Operator) &&
                !cLeftRight.IsReal && !cRight.IsReal)
                {
                    Changed = true;
                    var binOperator = binExp.Operator;
                    Constant c;
                    if (binLeft.Operator == binOperator)
                    {
                        c = Operator.IAdd.ApplyConstants(cLeftRight, cRight);
                    }
                    else
                    {
                        if (Math.Abs(cRight.ToInt64()) >= Math.Abs(cLeftRight.ToInt64()))
                        {
                            c = Operator.ISub.ApplyConstants(cRight, cLeftRight);
                        }
                        else
                        {
                            binOperator =
                                binOperator == Operator.IAdd
                                    ? Operator.ISub
                                    : Operator.IAdd;
                            c = Operator.ISub.ApplyConstants(cLeftRight, cRight);
                        }
                    }
                    if (c.IsIntegerZero)
                        return binLeft.Left;
                    return new BinaryExpression(binOperator, binExp.DataType, binLeft.Left, c);
                }
                if (binExp.Operator == Operator.IMul && binLeft.Operator == Operator.IMul)
                {
                    Changed = true;
                    var c = Operator.IMul.ApplyConstants(cLeftRight, cRight);
                    if (c.IsIntegerZero)
                        return c;
                    else
                        return new BinaryExpression(binExp.Operator, binExp.DataType, binLeft.Left, c);
                }
            }

            // (rel (- c e) 0 => (rel -c e) => (rel.Negate e c)

            if (binLeft != null && cRight != null && cRight.IsIntegerZero &&
                IsIntComparison(binExp.Operator) &&
                binLeft.Left is Constant cBinLeft &&
                binLeft.Operator == Operator.ISub)
            {
                return new BinaryExpression(
                    ((ConditionalOperator) binExp.Operator).Negate(),
                    binExp.DataType,
                    binLeft.Right,
                    cBinLeft);
            }

            // (rel (- e c1) c2) => (rel e c1+c2)

            if (binLeft != null && cLeftRight != null && cRight != null &&
                IsIntComparison(binExp.Operator) && IsAddOrSub(binLeft.Operator) &&
                !cLeftRight.IsReal && !cRight.IsReal)
            {
                // (>u (- e c1) c2) => (>u e c1+c2) || (<u e c2)
                if (binExp.Operator == Operator.Ugt && 
                    binLeft.Operator == Operator.ISub &&
                    !cRight.IsIntegerZero)
                {
                    Changed = true;
                    ctx.UseExpression(binLeft.Left);
                    var c = ExpressionSimplifier.SimplifyTwoConstants(Operator.IAdd, cLeftRight, cRight);
                    return new BinaryExpression(Operator.Cor, PrimitiveType.Bool,
                        new BinaryExpression(binExp.Operator, PrimitiveType.Bool, binLeft.Left, c),
                        new BinaryExpression(Operator.Ult, PrimitiveType.Bool, binLeft.Left, cLeftRight));
                }
                else
                {
                    Changed = true;
                    ctx.RemoveIdentifierUse(idLeft!);
                    var op = binLeft.Operator == Operator.IAdd ? Operator.ISub : Operator.IAdd;
                    var c = ExpressionSimplifier.SimplifyTwoConstants(op, cLeftRight, cRight);
                    return new BinaryExpression(binExp.Operator, PrimitiveType.Bool, binLeft.Left, c);
                }
            }

            // (rel C non-C) => (trans(rel) non-C C)
            if (constOnLeft.Match(binExp))
            {
                Changed = true;
                return constOnLeft.Transform().Accept(this);
            }
            if (addMici.Match(binExp))
            {
                Changed = true;
                return addMici.Transform();
            }

            if (shAdd.Match(binExp))
            {
                Changed = true;
                return shAdd.Transform();
            }

            if (shMul.Match(binExp))
            {
                Changed = true;
                return shMul.Transform();
            }

            if (shiftShift.Match(binExp))
            {
                Changed = true;
                return shiftShift.Transform();
            }
            var eNew = ShiftLeftShiftRight(binExp, cRight);
            if (eNew != null)
            {
                Changed = true;
                return eNew;
            }

            // (-exp == 0) => (exp == 0)
            if (unaryNegEqZero.Match(binExp))
            {
                Changed = true;
                return unaryNegEqZero.Transform();
            }

            if (logicalNotFromBorrow.Match(binExp))
            {
                Changed = true;
                return logicalNotFromBorrow.Transform();
            }

            // No change, just return as is.

            return binExp;
        }

        private bool IsNonFloatConstant(Constant? cRight)
        {
            return 
                cRight != null &&
                cRight.DataType is PrimitiveType pt &&
                pt.Domain != Domain.Real;
        }

        private Expression? ShiftLeftShiftRight(BinaryExpression bin, Constant? cRight)
        {
            if (cRight == null)
                return null;
            if (bin.Left is BinaryExpression binInner)
            {
                DataType dtConvert;
                if (bin.Operator == Operator.Shr)
                {
                    dtConvert = binInner.DataType;
                }
                else if (bin.Operator == Operator.Sar)
                {
                    dtConvert = PrimitiveType.Create(Domain.SignedInt, binInner.DataType.BitSize);
                }
                else
                {
                    return null;
                }

                if (binInner.Operator == Operator.Shl &&
                    binInner.Right is Constant cInnerRight &&
                    cmp.Equals(cRight, cInnerRight))
                {
                    var dtSlice = PrimitiveType.CreateWord(binInner.Left.DataType.BitSize - cRight.ToInt32());
                    var slice = new Slice(dtSlice, binInner.Left, 0);
                    return new Conversion(slice, slice.DataType, dtConvert);
                }
            }
            return null;
        }

        public static Constant SimplifyTwoConstants(Operator op, Constant l, Constant r)
        {
            PrimitiveType lType = (PrimitiveType) l.DataType;
            PrimitiveType rType = (PrimitiveType) r.DataType;
            if ((lType.Domain & rType.Domain) != 0)
            {
                return ((BinaryOperator) op).ApplyConstants(l, r);
            }
            throw new ArgumentException(string.Format("Can't add types of different domains {0} and {1}", l.DataType, r.DataType));
        }

        public virtual Expression VisitConversion(Conversion conversion)
        {
            var exp = conversion.Expression.Accept(this);
            if (exp != Constant.Invalid)
            {
                var ptCvt = conversion.DataType.ResolveAs<PrimitiveType>();
                var ptSrc = conversion.SourceDataType.ResolveAs<PrimitiveType>();
                if (exp is Constant c && ptCvt != null)
                {
                    if (ptSrc != null)
                    {
                        if (ptCvt.Domain == Domain.Real)
                        {
                            if (ptSrc.Domain == Domain.Real)
                            {
                                if (ptCvt.Size < ptSrc.Size)
                                {
                                    // Real-to-real conversion.
                                    Changed = true;
                                    return ConstantReal.Create(ptCvt, c.ToReal64());
                                }
                            }
                            else if (ptSrc.IsWord)
                            {
                                // Raw bit pattern reinterpretation.
                                Changed = true;
                                return CastRawBitsToReal(ptCvt, c);
                            }
                            else
                            {
                                // integer to real conversion
                                Changed = true;
                                return ConstantReal.Create(ptCvt, c.ToInt64());
                            }
                        }
                        else if ((ptSrc.Domain & Domain.Integer) != 0)
                        {
                            if (ptSrc != null)
                            {
                                if (ptSrc.Domain == Domain.SignedInt)
                                {
                                    Changed = true;
                                    return Constant.Create(ptCvt, c.ToInt64());
                                }
                                else if (ptSrc.Domain.HasFlag(Domain.SignedInt))
                                {
                                    Changed = true;
                                    return Constant.Create(ptCvt, c.ToUInt64());
                                }
                            }
                        }
                    }
                }
                if (exp is Identifier id && 
                    ctx.GetDefiningExpression(id) is MkSequence seq)
                {
                    // If we are casting a SEQ, and the corresponding element is >= 
                    // the size of the cast, then use deposited part directly.
                    var lsbElem = seq.Expressions[seq.Expressions.Length - 1];
                    int sizeDiff = lsbElem.DataType.Size - conversion.DataType.Size;
                    if (sizeDiff >= 0)
                    {
                        foreach (var elem in seq.Expressions)
                        {
                            ctx.RemoveExpressionUse(elem);
                        }
                        ctx.UseExpression(lsbElem);
                        Changed = true;
                        if (sizeDiff > 0)
                        {
                            return new Conversion(lsbElem, lsbElem.DataType, conversion.DataType);
                        }
                        else
                        {
                            return lsbElem;
                        }
                    }
                }
                if (exp is ProcedureConstant pc && conversion.DataType.BitSize == pc.DataType.BitSize)
                {
                    // (wordnn) procedure_const => procedure_const
                    return pc;
                }
                if (exp.DataType.BitSize == conversion.DataType.BitSize)
                {
                    // Redundant word-casts can be stripped.
                    if (conversion.DataType.IsWord)
                    {
                        return exp;
                    }
                }
                conversion = new Conversion(exp, exp.DataType, conversion.DataType);
            }
            if (convertConvertRule.Match(conversion))
            {
                Changed = true;
                return convertConvertRule.Transform();
            }
            return conversion;
        }

        /// <summary>
        /// Take a bitvector of type wordXXX and reinterpret it as a floating-point
        /// constant.
        /// </summary>
        /// <param name="ptCast">Floating-point type to which the raw bits are being cast.</param>
        /// <param name="rawBits">The raw bits being cast.</param>
        /// <returns>A floating-point constant, possibly with a <see cref="Cast"/> wrapped around it
        /// if the constant is not 32- or 64-bit.
        /// </returns>
        private Expression CastRawBitsToReal(PrimitiveType ptCast, Constant rawBits)
        {
            var bitSize = Math.Min(rawBits.DataType.BitSize, 64);
            var dtImm = PrimitiveType.Create(Domain.Real, bitSize);
            var cImm = Constant.RealFromBitpattern(dtImm, rawBits.ToInt64());
            cImm = ConstantReal.Create(dtImm, cImm.ToReal64());
            if (cImm.DataType.BitSize == ptCast.BitSize)
            {
                return cImm;
            }
            else
            {
                return new Conversion(cImm, cImm.DataType, ptCast);
            }
        }

        public virtual Expression VisitCast(Cast cast)
        {
            var e = cast.Expression.Accept(this);
            return new Cast(cast.DataType, e);
        }

        public virtual Expression VisitConditionalExpression(ConditionalExpression c)
        {
            var cond = c.Condition.Accept(this);
            var t = c.ThenExp.Accept(this);
            var f = c.FalseExp.Accept(this);
            if (cond is Constant cCond && cCond.DataType == PrimitiveType.Bool)
            {
                if (cCond.IsZero)
                    return f;
                else
                    return t;
            }
            return new ConditionalExpression(c.DataType, cond, t, f);
        }

        public virtual Expression VisitConditionOf(ConditionOf c)
        {
            var e = c.Expression.Accept(this);
            //$REVIEW: if e == 0, then Z flags could be set to 1. But that's architecture specific, so
            // we leave that as an exercise to re reader
            if (e != c.Expression)
                c = new ConditionOf(e);
            return c;
        }

        public virtual Expression VisitConstant(Constant c)
        {
            return c;
        }

        public virtual Expression VisitDereference(Dereference deref)
        {
            var e = deref.Expression.Accept(this);
            return new Dereference(deref.DataType, e);
        }

        public virtual Expression VisitFieldAccess(FieldAccess acc)
        {
            throw new NotImplementedException();
        }

        public virtual Expression VisitIdentifier(Identifier id)
        {
            if (idConst.Match(id))
            {
                Changed = true;
                return idConst.Transform();
            }
            if (idProcConstRule.Match(id))
            {
                Changed = true;
                return idProcConstRule.Transform();
            }
            // jkl: Copy propagation causes real problems when used during trashed register analysis.
            // If needed in other passes, it should be an option for expression e
            if (idCopyPropagation.Match(id))
            {
                Changed = true;
                return idCopyPropagation.Transform();
            }
            if (idBinIdc.Match(id))
            {
                Changed = true;
                return idBinIdc.Transform();
            }
            return id;
        }

        public virtual Expression VisitMemberPointerSelector(MemberPointerSelector mps)
        {
            if (mpsRule.Match(mps))
            {
                Changed = true;
                return mpsRule.Transform();
            }
            return mps;
        }

        public virtual Expression VisitMemoryAccess(MemoryAccess access)
        {
            var value = new MemoryAccess(
                access.MemoryId,
                access.EffectiveAddress.Accept(this),
                access.DataType);
            var newValue = ctx.GetValue(value, segmentMap);
            if (newValue != value)
            {
                ctx.RemoveExpressionUse(value);
                ctx.UseExpression(newValue);
            }
            return newValue;
        }

        public virtual Expression VisitMkSequence(MkSequence seq)
        {
            var newSeq = seq.Expressions.Select(e =>
            {
                var eNew = e.Accept(this);
                if (eNew == Constant.Invalid)
                    eNew = e;
                return eNew;
            }).ToArray();
            if (newSeq.Length == 2)
            {
                // Special case for the frequent case of segment:offset or 
                // two concatenated bit vectors.
                if (newSeq[0] is Constant c1 && newSeq[1] is Constant c2)
                {
                    PrimitiveType tHead = (PrimitiveType) c1.DataType;
                    PrimitiveType tTail = (PrimitiveType) c2.DataType;
                    PrimitiveType t;
                    Changed = true;
                    if (tHead.Domain == Domain.Selector)            //$REVIEW: seems to require Address, SegmentedAddress?
                    {
                        t = PrimitiveType.Create(Domain.Pointer, tHead.BitSize + tTail.BitSize);
                        return ctx.MakeSegmentedAddress(c1, c2);
                    }
                    else
                    {
                        t = PrimitiveType.Create(tHead.Domain, tHead.BitSize + tTail.BitSize);
                        return Constant.Create(t, (c1.ToUInt64() << tTail.BitSize) | c2.ToUInt64());
                    }
                }
            }
            else if (newSeq.All(e => e is Constant))
            {
                //$TODO: > 64 bit values?
                ulong value = 0;
                for (int i = 0; i < newSeq.Length; ++i)
                {
                    var c = (Constant) newSeq[i];
                    value = (value << c.DataType.BitSize) | c.ToUInt64();
                }
                return Constant.Create(seq.DataType, value);
            }
            if (newSeq.Take(newSeq.Length - 1).All(e => e.IsZero))
            {
                var tail = newSeq.Last();
                // leading zeros imply a conversion to unsigned.
                return new Conversion(
                    tail,
                    PrimitiveType.Create(Domain.UnsignedInt, tail.DataType.BitSize),
                    PrimitiveType.Create(Domain.UnsignedInt, seq.DataType.BitSize));
            }
            var mem = FuseAdjacentMemoryAccesses(seq.DataType, newSeq);
            if (mem != null)
                return mem;
            return FuseAdjacentSlices(seq.DataType, newSeq);
        }

        private Expression? FuseAdjacentMemoryAccesses(DataType dt, Expression[] elems)
        {
            var (access, seg, ea, offset) = AsMemoryAccess(elems[0]);
            if (access == null)
                return null;
            var fused = new List<Expression>();
            var offsetFused = offset;
            for (int i = 1; i < elems.Length; ++i)
            {
                var (accNew, segNew, eaNew, offNew) = AsMemoryAccess(elems[i]);
                if (accNew == null)
                    return null;
                if (cmp.Equals(seg, segNew) &&
                    cmp.Equals(ea, eaNew) &&
                    ctx.Endianness.OffsetsAdjacent(offNew, offset, accNew.DataType.Size))
                {
                    offsetFused = Math.Min(offsetFused, offNew);
                }
                else
                    return null;
            }
            Expression fusedEa;
            if (ea is null)
            {
                fusedEa = Constant.Create(access.EffectiveAddress.DataType, (ulong)offsetFused);
            }
            else
            {
                fusedEa = m.AddSubSignedInt(ea, offsetFused);
            }

            var result = (seg is null)
                ? m.Mem(access.MemoryId, dt, fusedEa)
                : m.SegMem(access.MemoryId, dt, seg, fusedEa);

            foreach (var e in elems)
                ctx.RemoveExpressionUse(e);
            ctx.UseExpression(result);
            return result;
        }

        private (MemoryAccess? access, Expression? seg, Expression? ea, long offset) AsMemoryAccess(Expression expression)
        {
            MemoryAccess access;
            Expression? seg;
            Expression ea;
            if (expression is SegmentedAccess segmem)
            {
                access = segmem;
                seg = segmem.BasePointer;
                ea = segmem.EffectiveAddress;
            }
            else if (expression is MemoryAccess mem)
            {
                access = mem;
                seg = null;
                ea = mem.EffectiveAddress;
            }
            else
                return (null, null, null, 0);

            long offset = 0;
            Expression? eaStripped = ea;
            if (ea is Constant global)
            {
                offset = global.ToInt64();
                eaStripped = null;
            }
            else if (ea is Address addr && !addr.Selector.HasValue)
            {
                offset = (long) addr.ToLinear();
                eaStripped = null;
            }
            else if (ea is BinaryExpression bin)
            {
                if (bin.Right is Constant c)
                {
                    if (bin.Operator == Operator.IAdd)
                    {
                        offset = c.ToInt64();
                        eaStripped = bin.Left;
                    }
                    else if (bin.Operator == Operator.ISub)
                    {
                        offset = -c.ToInt64();
                        eaStripped = bin.Left;
                    }
                }
            }
            return (access, seg, eaStripped, offset);
        }

        private Expression FuseAdjacentSlices(DataType dataType, Expression[] elems)
        {
            var fused = new List<Expression> { AsSlice(elems[0]) ?? elems[0] };
            bool changed = false;
            for (int i = 1; i < elems.Length; ++i)
            {
                Slice? slNext = AsSlice(elems[i]);
                if (fused[fused.Count - 1] is Slice slPrev && slNext != null &&
                    cmp.Equals(slPrev.Expression, slNext.Expression) &&
                    slPrev.Offset == slNext.Offset + slNext.DataType.BitSize)
                {
                    // Fuse the two consecutive slices. 
                    var newSlice = new Slice(
                        PrimitiveType.CreateWord(slPrev.DataType.BitSize + slNext.DataType.BitSize),
                        slNext.Expression,
                        slNext.Offset);
                    fused[fused.Count - 1] = newSlice.Accept(this);
                    changed = true;
                }
                else
                {
                    fused.Add(elems[i]);
                }
            }
            if (changed)
            {
                foreach (var e in elems)
                    ctx.RemoveExpressionUse(e);
                foreach (var f in fused)
                    ctx.UseExpression(f);
                if (fused.Count == 1)
                    return fused[0];
                else
                    return new MkSequence(dataType, fused.ToArray());
            }
            else
            {
                return new MkSequence(dataType, elems);
            }
        }

        private Slice? AsSlice(Expression? e)
        {
            if (e is Identifier id)
            {
                e = ctx.GetDefiningExpression(id);
            }
            if (e is Cast c)
            {
                return new Slice(c.DataType, c.Expression, 0);
            }
            else
            {
                return e as Slice;
            }
        }

        public virtual Expression VisitOutArgument(OutArgument outArg)
        {
            Expression exp;
            if (outArg.Expression is Identifier)
                exp = outArg.Expression;
            else 
                exp = outArg.Expression.Accept(this);
            return new OutArgument(outArg.DataType, exp);
        }

        public virtual Expression VisitPhiFunction(PhiFunction pc)
        {
            var oldChanged = Changed;
            var args = pc.Arguments
                .Select(a =>
                {
                    var arg = SimplifyPhiArg(a.Value.Accept(this));
                    ctx.RemoveExpressionUse(arg);
                    return arg;
                })
                .Where(a => ctx.GetValue((a as Identifier)!) != pc)
                .ToArray();
            Changed = oldChanged;

            var cmp = new ExpressionValueComparer();
            var e = args.FirstOrDefault();
            if (e != null && args.All(a => cmp.Equals(a, e)))
            {
                Changed = true;
                ctx.UseExpression(e);
                return e;
            }
            else
            {
                ctx.UseExpression(pc);
                return pc;
            }
        }

        /// <summary>
        /// VisitBinaryExpression method could not simplify following statements:
        ///    y = x - const
        ///    a = y + const
        ///    x = phi(a, b)
        /// to
        ///    y = x - const
        ///    a = x
        ///    x = phi(a, b)
        /// IdBinIdc rule class processes y as 'used in phi' and prevents propagation.
        /// This method could be used to do such simplification (y + const ==> x)
        /// </summary
        private Expression SimplifyPhiArg(Expression arg)
        {
            if (!(arg is BinaryExpression bin &&
                  bin.Left is Identifier idLeft &&
                  ctx.GetValue(idLeft) is BinaryExpression binLeft))
                return arg;

            ctx.RemoveIdentifierUse(idLeft);
            ctx.UseExpression(binLeft);
            bin = new BinaryExpression(
                bin.Operator,
                bin.DataType,
                binLeft,
                bin.Right);
            return bin.Accept(this);
        }

        public virtual Expression VisitPointerAddition(PointerAddition pa)
        {
            return pa;
        }

        public virtual Expression VisitProcedureConstant(ProcedureConstant pc)
        {
            return pc;
        }

        public virtual Expression VisitScopeResolution(ScopeResolution sc)
        {
            return sc;
        }

        public virtual Expression VisitSegmentedAccess(SegmentedAccess segMem)
        {
            var basePtr = segMem.BasePointer.Accept(this);
            var offset = segMem.EffectiveAddress.Accept(this);
            if (basePtr is Constant cBase && offset is Constant cOffset)
            {
                var addr = ctx.MakeSegmentedAddress(cBase, cOffset);
                var mem = new MemoryAccess(segMem.MemoryId, addr, segMem.DataType);
                return ctx.GetValue(mem, segmentMap);
            }
            segMem = new SegmentedAccess(segMem.MemoryId, basePtr, offset, segMem.DataType);
            if (sliceSegPtr.Match(segMem))
            {
                Changed = true;
                return sliceSegPtr.Transform();
            }
            return ctx.GetValue(segMem, segmentMap);
        }

        public virtual Expression VisitSlice(Slice slice)
        {
            var e = slice.Expression.Accept(this);
            // Is the slice the same size as the expression?
            if (slice.Offset == 0 && slice.DataType.BitSize == e.DataType.BitSize)
                return e;
            slice = new Slice(slice.DataType, e, slice.Offset);
            if (sliceConst.Match(slice))
            {
                Changed = true;
                return sliceConst.Transform();
            }
            if (sliceMem.Match(slice))
            {
                Changed = true;
                return sliceMem.Transform();
            }

            // (slice (shl e n) n) ==> e
            if (sliceShift.Match(slice))
            {
                Changed = true;
                return sliceShift.Transform();
            }
            if (sliceSeq.Match(slice))
            {
                Changed = true;
                return sliceSeq.Transform();
            }
            if (sliceConvert.Match(slice))
            {
                Changed = true;
                return sliceConvert.Transform();
            }
            if (e is Identifier id &&
                ctx.GetDefiningExpression(id) is MkSequence seq)
            {
                // If we are casting a SEQ, and the corresponding element is >= 
                // the size of the cast, then use deposited part directly.
                var lsbElem = seq.Expressions[seq.Expressions.Length - 1];
                int sizeDiff = lsbElem.DataType.Size - slice.DataType.Size;
                if (sizeDiff >= 0)
                {
                    foreach (var elem in seq.Expressions)
                    {
                        ctx.RemoveExpressionUse(elem);
                    }
                    ctx.UseExpression(lsbElem);
                    Changed = true;
                    if (sizeDiff > 0)
                    {
                        return new Slice(slice.DataType, lsbElem, slice.Offset);
                    }
                    else
                    {
                        return lsbElem;
                    }
                }
            }
            return slice;
        }

        public virtual Expression VisitTestCondition(TestCondition tc)
        {
            return new TestCondition(tc.ConditionCode, tc.Expression.Accept(this));
        }

        public virtual Expression VisitUnaryExpression(UnaryExpression unary)
        {
            unary = new UnaryExpression(unary.Operator, unary.DataType, unary.Expression.Accept(this));
            if (negSub.Match(unary))
            {
                Changed = true;
                return negSub.Transform();
            }

            // (!-exp) >= (!exp)
            if (logicalNotFollowedByNeg.Match(unary))
            {
                Changed = true;
                return logicalNotFollowedByNeg.Transform();
            }

            return unary;
        }
    }
}

---- Transformed Tree ----
using Reko.Evaluation;
using Reko.Core;
using Reko.Analysis;
using Reko.Core.Expressions;
using Reko.Core.Operators;
using Reko.Core.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using Reko.Core.Services;
using System.Diagnostics;
using System.Xml.Schema;
using Reko.Core.Code;
using Reko.Scanning;

namespace Reko.Evaluation 
{
    /// <summary>
    /// Partially evaluates expressions, using an <see cref="EvaluationContext"/> to obtain the values
    /// of identifiers and optionally modifies the expression being evaluated.
    /// </summary>
    public class ExpressionSimplifier : ExpressionVisitor<Expression>
    {
        private readonly SegmentMap segmentMap;
        private EvaluationContext ctx;
        private readonly ExpressionValueComparer cmp;
        private readonly ExpressionEmitter m;
        private readonly Unifier unifier;

        private readonly AddTwoIdsRule add2ids;
        private readonly Add_e_c_cRule addEcc;
        private readonly Add_mul_id_c_id_Rule addMici;
        private readonly ConstConstBin_Rule constConstBin;
        private readonly IdConstant idConst;
        private readonly IdCopyPropagationRule idCopyPropagation;
        private readonly IdBinIdc_Rule idBinIdc;
        private readonly SliceConstant_Rule sliceConst;
        private readonly SliceMem_Rule sliceMem;
        private readonly SliceSegmentedPointer_Rule sliceSegPtr;
        private readonly SliceShift sliceShift;
        private readonly Shl_add_Rule shAdd;
        private readonly Shl_mul_e_Rule shMul;
        private readonly ShiftShift_c_c_Rule shiftShift;
        private readonly NegSub_Rule negSub;
        private readonly Mps_Constant_Rule mpsRule;
        private readonly BinOpWithSelf_Rule binopWithSelf;
        private readonly ConstDivisionImplementedByMultiplication constDiv;
        private readonly IdProcConstRule idProcConstRule;
        private readonly ConvertConvertRule convertConvertRule;
        private readonly DistributedCastRule distributedCast;
        private readonly DistributedConversionRule distributedConvert;
        private readonly DistributedSliceRule distributedSlice;
        private readonly MkSeqFromSlices_Rule mkSeqFromSlicesRule;
        private readonly ComparisonConstOnLeft constOnLeft;
        private readonly SliceSequence sliceSeq;
        private readonly SliceConvert sliceConvert;
        private readonly LogicalNotFollowedByNegRule logicalNotFollowedByNeg;
        private readonly LogicalNotFromArithmeticSequenceRule logicalNotFromBorrow;
        private readonly UnaryNegEqZeroRule unaryNegEqZero;

        public ExpressionSimplifier(SegmentMap segmentMap, EvaluationContext ctx, DecompilerEventListener listener)
        {
            this.segmentMap = segmentMap ?? throw new ArgumentNullException(nameof(SegmentMap));
            this.ctx = ctx;
            this.cmp = new ExpressionValueComparer();
            this.m = new ExpressionEmitter();
            this.unifier = new Unifier();
            this.add2ids = new AddTwoIdsRule(ctx);
            this.addEcc = new Add_e_c_cRule(ctx);
            this.addMici = new Add_mul_id_c_id_Rule(ctx);
            this.idConst = new IdConstant(ctx, unifier, listener);
            this.idCopyPropagation = new IdCopyPropagationRule(ctx);
            this.idBinIdc = new IdBinIdc_Rule(ctx);
            this.sliceConst = new SliceConstant_Rule();
            this.sliceMem = new SliceMem_Rule();
            this.sliceSegPtr = new SliceSegmentedPointer_Rule(ctx);
            this.negSub = new NegSub_Rule();
            this.constConstBin = new ConstConstBin_Rule();
            this.shAdd = new Shl_add_Rule(ctx);
            this.shMul = new Shl_mul_e_Rule(ctx);
            this.shiftShift = new ShiftShift_c_c_Rule(ctx);
            this.mpsRule = new Mps_Constant_Rule(ctx);
            this.sliceShift = new SliceShift(ctx);
            this.binopWithSelf = new BinOpWithSelf_Rule();
            this.constDiv = new ConstDivisionImplementedByMultiplication(ctx);
            this.idProcConstRule = new IdProcConstRule(ctx);
            this.convertConvertRule = new ConvertConvertRule(ctx);
            this.distributedConvert = new DistributedConversionRule();
            this.distributedCast = new DistributedCastRule();
            this.distributedSlice = new DistributedSliceRule();
            this.mkSeqFromSlicesRule = new MkSeqFromSlices_Rule(ctx);
            this.constOnLeft = new ComparisonConstOnLeft();
            this.sliceSeq = new SliceSequence(ctx);
            this.sliceConvert = new SliceConvert();
            this.logicalNotFollowedByNeg = new LogicalNotFollowedByNegRule();
            this.logicalNotFromBorrow = new LogicalNotFromArithmeticSequenceRule();
            this.unaryNegEqZero = new UnaryNegEqZeroRule();
        }

        public bool Changed { get { return changed; } set { changed = value; } }
        private bool changed;

        private bool IsAddOrSub(Operator op)
        {
            return op == Operator.IAdd || op == Operator.ISub;
        }

        private bool IsIntComparison(Operator op)
        {
            return op == Operator.Eq || op == Operator.Ne ||
                   op == Operator.Ge || op == Operator.Gt ||
                   op == Operator.Le || op == Operator.Lt ||
                   op == Operator.Uge || op == Operator.Ugt ||
                   op == Operator.Ule || op == Operator.Ult;
        }

        private bool IsFloatComparison(Operator op)
        {
            return op == Operator.Feq || op == Operator.Fne ||
                   op == Operator.Fge || op == Operator.Fgt ||
                   op == Operator.Fle || op == Operator.Flt;
        }

        public static Constant SimplifyTwoConstants(BinaryOperator op, Constant l, Constant r)
        {
            var lType = (PrimitiveType)l.DataType;
            var rType = (PrimitiveType)r.DataType;
            return op.ApplyConstants(l, r);
        }

        public virtual Expression VisitAddress(Address addr)
        {
            return addr;
        }

        public virtual Expression VisitApplication(Application appl)
        {
            var args = new Expression[appl.Arguments.Length];
            for (int i = 0; i < appl.Arguments.Length; ++i)
            {
                var arg = appl.Arguments[i];
                args[i] = arg.Accept(this);
            }
            // Rotations-with-carries that rotate in a false carry 
            // flag can be simplified to shifts.
            if (appl.Procedure is ProcedureConstant pc && 
                pc.Procedure is IntrinsicProcedure intrinsic)
            {
                switch (intrinsic.Name)
                {
                case IntrinsicProcedure.RolC:
                    if (IsSingleBitRotationWithClearCarryIn(args))
                    {
                        Changed = true;
                        return new BinaryExpression(Operator.Shl, appl.DataType, args[0], args[1]);
                    }
                    break;
                case IntrinsicProcedure.RorC:
                    if (IsSingleBitRotationWithClearCarryIn(args))
                    {
                        Changed = true;
                        return new BinaryExpression(Operator.Shr, appl.DataType, args[0], args[1]);
                    }
                    break;
                case IntrinsicProcedure.Rol:
                    var rol = CombineRotations(intrinsic.Name, appl, args);
                    if (rol != null)
                    {
                        Changed = true;
                        return rol;
                    }
                    break;
                case IntrinsicProcedure.Ror:
                    var ror = CombineRotations(intrinsic.Name, appl, args);
                    if (ror != null)
                    {
                        Changed = true;
                        return ror;
                    }
                    break;
                }
            }
            appl = new Application(
                appl.Procedure.Accept(this),
                appl.DataType,
                args);
            return ctx.GetValue(appl);
        }

        private Expression? CombineRotations(string rotationName, Application appl, Expression[] args)
        {
            if (args[1] is Constant cOuter &&
                args[0] is Application appInner &&
                appInner.Procedure is ProcedureConstant pcInner &&
                pcInner.Procedure is IntrinsicProcedure intrinsicInner)
            {
                if (intrinsicInner.Name == rotationName)
                {
                    if (appInner.Arguments[1] is Constant cInner)
                    {
                        var cTot = Operator.IAdd.ApplyConstants(cOuter, cInner);
                        Changed = true;
                        return new Application(
                            appl.Procedure,
                            appl.DataType,
                            appInner.Arguments[0],
                            cTot);
                    }
                }
            }
            return null;
        }

        private static bool IsSingleBitRotationWithClearCarryIn(Expression[] args)
        {
            Debug.Assert(args.Length == 3);
            return args[1] is Constant sh &&
                                    sh.ToInt32() == 1 &&
                                    args[2] is Constant c &&
                                    c.IsIntegerZero;
        }

        public virtual Expression VisitArrayAccess(ArrayAccess acc)
        {
            return new ArrayAccess(
                acc.DataType,
                acc.Array.Accept(this),
                acc.Index.Accept(this));
        }

        public virtual Expression VisitBinaryExpression(BinaryExpression binExp)
        {
            // (+ id1 id1) ==> (* id1 2)

            if (add2ids.Match(binExp))
            {
                Changed = true;
                return add2ids.Transform().Accept(this);
            }
            if (binopWithSelf.Match(binExp))
            {
                Changed = true;
                return binopWithSelf.Transform(ctx).Accept(this);
            }
            if (distributedConvert.Match(binExp))
            {
                Changed = true;
                return distributedConvert.Transform(ctx).Accept(this);
            }
            if (distributedCast.Match(binExp))
            {
                Changed = true;
                return distributedCast.Transform(ctx).Accept(this);
            }
            if (distributedSlice.Match(binExp))
            {
                Changed = true;
                return distributedSlice.Transform(ctx).Accept(this);
            }

            var left = binExp.Left.Accept(this);
            var right = binExp.Right.Accept(this);

            if (left is Constant cLeft && BinaryExpression.Commutes(binExp.Operator))
            {
                cRight = cLeft; left = right; right = cLeft;
            }

            //$TODO: operands to binary operations appear to be
            // mismatched in some processors. Change the ctor
            // of BinaryExpression to catch this later.
            var sameBitsize = left.DataType.BitSize == right.DataType.BitSize;

            if (right is Constant cRight)
            {
                // (- X 0) ==> X
                // (+ X 0) ==> X
                if (cRight.IsIntegerZero && IsAddOrSub(binExp.Operator))
                {
                    Changed = true;
                    return left;
                }
                if (binExp.Operator == Operator.Or)
                {
                    if (cRight.IsIntegerZero)
                    {
                        Changed = true;
                        return left;
                    }
                    // (| X 0xFFFF...F) ==> 0xFFFF...F
                    if (cRight.IsMaxUnsigned && sameBitsize && !CriticalInstruction.IsCritical(left))
                    {
                        ctx.RemoveExpressionUse(left);
                        Changed = true;
                        return right;
                    }
                }
                if (binExp.Operator == Operator.And)
                {
                    if (cRight.IsIntegerZero && sameBitsize && !CriticalInstruction.IsCritical(left))
                    {
                        ctx.RemoveExpressionUse(left);
                        Changed = true;
                        return cRight;
                    }
                    if (cRight.IsMaxUnsigned && sameBitsize)
                    {
                        Changed = true;
                        return left;
                    }
                }
                if (binExp.Operator == Operator.Xor)
                {
                    if (cRight.IsIntegerZero)
                    {
                        Changed = true;
                        return left;
                    }
                    if (cRight.IsMaxUnsigned && sameBitsize)
                    {
                        Changed = true;
                        return new UnaryExpression(Operator.Comp, left.DataType, left).Accept(this);
                    }
                }
            }

            //$REVIEW: this is evaluation! Shouldn't the be done by the evaluator?
            if (left == Constant.Invalid || right == Constant.Invalid)
                return Constant.Invalid;

            binExp = new BinaryExpression(binExp.Operator, binExp.DataType, left, right);
            if (constConstBin.Match(binExp))
            {
                Changed = true;
                return constConstBin.Transform();
            }
            Identifier? idRight = right as Identifier;

            // (rel? id1 c) should just pass.

            if (IsIntComparison(binExp.Operator) && right is Constant cRight && left is Identifier idLeft)
                return binExp;

            // Floating point expressions with "integer" constants 
            if (IsFloatComparison(binExp.Operator) && IsNonFloatConstant(cRight))
            {
                cRight = ctx.ReinterpretAsFloat(cRight!);
                right = cRight;
                binExp = new BinaryExpression(
                    binExp.Operator,
                    binExp.DataType,
                    binExp.Left,
                    cRight);
            }

            var binLeft = left as BinaryExpression;
            var cLeftRight = (binLeft != null) ? binLeft.Right as Constant : null;

            // (+ (+ e c1) c2) ==> (+ e (+ c1 c2))
            // (+ (- e c1) c2) ==> (+ e (- c2 c1))
            // (- (+ e c1) c2) ==> (- e (- c2 c1))
            // (- (- e c1) c2) ==> (- e (+ c1 c2))

            if (binLeft != null && cLeftRight != null && right is Constant cRight)
            {
                if (IsAddOrSub(binExp.Operator) && IsAddOrSub(binLeft.Operator) &&
                !cLeftRight.IsReal && !cRight.IsReal)
                {
                    Changed = true;
                    var binOperator = binExp.Operator;
                    Constant c;
                    if (binLeft.Operator == binOperator)
                    {
                        c = Operator.IAdd.ApplyConstants(cLeftRight, cRight);
                    }
                    else
                    {
                        if (Math.Abs(cRight.ToInt64()) >= Math.Abs(cLeftRight.ToInt64()))
                        {
                            c = Operator.ISub.ApplyConstants(cRight, cLeftRight);
                        }
                        else
                        {
                            binOperator =
                                binOperator == Operator.IAdd
                                    ? Operator.ISub
                                    : Operator.IAdd;
                            c = Operator.ISub.ApplyConstants(cLeftRight, cRight);
                        }
                    }
                    if (c.IsIntegerZero)
                        return binLeft.Left;
                    return new BinaryExpression(binOperator, binExp.DataType, binLeft.Left, c);
                }
                if (binExp.Operator == Operator.IMul && binLeft.Operator == Operator.IMul)
                {
                    Changed = true;
                    var c = Operator.IMul.ApplyConstants(cLeftRight, cRight);
                    if (c.IsIntegerZero)
                        return c;
                    else
                        return new BinaryExpression(binExp.Operator, binExp.DataType, binLeft.Left, c);
                }
            }

            // (rel (- c e) 0 => (rel -c e) => (rel.Negate e c)

            if (binLeft != null && right is Constant cRight && cRight.IsIntegerZero &&
                IsIntComparison(binExp.Operator) &&
                binLeft.Left is Constant cBinLeft &&
                binLeft.Operator == Operator.ISub)
            {
                return new BinaryExpression(
                    ((ConditionalOperator) binExp.Operator).Negate(),
                    binExp.DataType,
                    binLeft.Right,
                    cBinLeft);
            }

            // (rel (- e c1) c2) => (rel e c1+c2)

            if (binLeft != null && cLeftRight != null && right is Constant cRight &&
                IsIntComparison(binExp.Operator) && IsAddOrSub(binLeft.Operator) &&
                !cLeftRight.IsReal && !cRight.IsReal)
            {
                // (>u (- e c1) c2) => (>u e c1+c2) || (<u e c2)
                if (binExp.Operator == Operator.Ugt && 
                    binLeft.Operator == Operator.ISub &&
                    !cRight.IsIntegerZero)
                {
                    Changed = true;
                    ctx.UseExpression(binLeft.Left);
                    var c = ExpressionSimplifier.SimplifyTwoConstants(Operator.IAdd, cLeftRight, cRight);
                    return new BinaryExpression(Operator.Cor, PrimitiveType.Bool,
                        new BinaryExpression(binExp.Operator, PrimitiveType.Bool, binLeft.Left, c),
                        new BinaryExpression(Operator.Ult, PrimitiveType.Bool, binLeft.Left, cLeftRight));
                }
                else
                {
                    Changed = true;
                    ctx.RemoveIdentifierUse(idLeft!);
                    var op = binLeft.Operator == Operator.IAdd ? Operator.ISub : Operator.IAdd;
                    var c = ExpressionSimplifier.SimplifyTwoConstants(op, cLeftRight, cRight);
                    return new BinaryExpression(binExp.Operator, PrimitiveType.Bool, binLeft.Left, c);
                }
            }

            // (rel C non-C) => (trans(rel) non-C C)
            if (constOnLeft.Match(binExp))
            {
                Changed = true;
                return constOnLeft.Transform().Accept(this);
            }
            if (addMici.Match(binExp))
            {
                Changed = true;
                return addMici.Transform();
            }

            if (shAdd.Match(binExp))
            {
                Changed = true;
                return shAdd.Transform();
            }

            if (shMul.Match(binExp))
            {
                Changed = true;
                return shMul.Transform();
            }

            if (shiftShift.Match(binExp))
            {
                Changed = true;
                return shiftShift.Transform();
            }
            var eNew = ShiftLeftShiftRight(binExp, cRight);
            if (eNew != null)
            {
                Changed = true;
                return eNew;
            }

            // (-exp == 0) => (exp == 0)
            if (unaryNegEqZero.Match(binExp))
            {
                Changed = true;
                return unaryNegEqZero.Transform();
            }

            if (logicalNotFromBorrow.Match(binExp))
            {
                Changed = true;
                return logicalNotFromBorrow.Transform();
            }

            // No change, just return as is.

            return binExp;
        }

        private bool IsNonFloatConstant(Constant? cRight)
        {
            return 
                cRight != null &&
                cRight.DataType is PrimitiveType pt &&
                pt.Domain != Domain.Real;
        }

        private Expression? ShiftLeftShiftRight(BinaryExpression bin, Constant? cRight)
        {
            if (cRight == null)
                return null;
            if (bin.Left is BinaryExpression binInner)
            {
                DataType dtConvert;
                if (bin.Operator == Operator.Shr)
                {
                    dtConvert = binInner.DataType;
                }
                else if (bin.Operator == Operator.Sar)
                {
                    dtConvert = PrimitiveType.Create(Domain.SignedInt, binInner.DataType.BitSize);
                }
                else
                {
                    return null;
                }

                if (binInner.Operator == Operator.Shl &&
                    binInner.Right is Constant cInnerRight &&
                    cmp.Equals(cRight, cInnerRight))
                {
                    var dtSlice = PrimitiveType.CreateWord(binInner.Left.DataType.BitSize - cRight.ToInt32());
                    var slice = new Slice(dtSlice, binInner.Left, 0);
                    return new Conversion(slice, slice.DataType, dtConvert);
                }
            }
            return null;
        }

        public static Constant SimplifyTwoConstants(Operator op, Constant l, Constant r)
        {
            PrimitiveType lType = (PrimitiveType) l.DataType;
            PrimitiveType rType = (PrimitiveType) r.DataType;
            if ((lType.Domain & rType.Domain) != 0)
            {
                return ((BinaryOperator) op).ApplyConstants(l, r);
            }
            throw new ArgumentException(string.Format("Can't add types of different domains {0} and {1}", l.DataType, r.DataType));
        }

        public virtual Expression VisitConversion(Conversion conversion)
        {
            var exp = conversion.Expression.Accept(this);
            if (exp != Constant.Invalid)
            {
                var ptCvt = conversion.DataType.ResolveAs<PrimitiveType>();
                var ptSrc = conversion.SourceDataType.ResolveAs<PrimitiveType>();
                if (exp is Constant c && ptCvt != null)
                {
                    if (ptSrc != null)
                    {
                        if (ptCvt.Domain == Domain.Real)
                        {
                            if (ptSrc.Domain == Domain.Real)
                            {
                                if (ptCvt.Size < ptSrc.Size)
                                {
                                    // Real-to-real conversion.
                                    Changed = true;
                                    return ConstantReal.Create(ptCvt, c.ToReal64());
                                }
                            }
                            else if (ptSrc.IsWord)
                            {
                                // Raw bit pattern reinterpretation.
                                Changed = true;
                                return CastRawBitsToReal(ptCvt, c);
                            }
                            else
                            {
                                // integer to real conversion
                                Changed = true;
                                return ConstantReal.Create(ptCvt, c.ToInt64());
                            }
                        }
                        else if ((ptSrc.Domain & Domain.Integer) != 0)
                        {
                            if (ptSrc != null)
                            {
                                if (ptSrc.Domain == Domain.SignedInt)
                                {
                                    Changed = true;
                                    return Constant.Create(ptCvt, c.ToInt64());
                                }
                                else if (ptSrc.Domain.HasFlag(Domain.SignedInt))
                                {
                                    Changed = true;
                                    return Constant.Create(ptCvt, c.ToUInt64());
                                }
                            }
                        }
                    }
                }
                if (exp is Identifier id && 
                    ctx.GetDefiningExpression(id) is MkSequence seq)
                {
                    // If we are casting a SEQ, and the corresponding element is >= 
                    // the size of the cast, then use deposited part directly.
                    var lsbElem = seq.Expressions[seq.Expressions.Length - 1];
                    int sizeDiff = lsbElem.DataType.Size - conversion.DataType.Size;
                    if (sizeDiff >= 0)
                    {
                        foreach (var elem in seq.Expressions)
                        {
                            ctx.RemoveExpressionUse(elem);
                        }
                        ctx.UseExpression(lsbElem);
                        Changed = true;
                        if (sizeDiff > 0)
                        {
                            return new Conversion(lsbElem, lsbElem.DataType, conversion.DataType);
                        }
                        else
                        {
                            return lsbElem;
                        }
                    }
                }
                if (exp is ProcedureConstant pc && conversion.DataType.BitSize == pc.DataType.BitSize)
                {
                    // (wordnn) procedure_const => procedure_const
                    return pc;
                }
                if (exp.DataType.BitSize == conversion.DataType.BitSize)
                {
                    // Redundant word-casts can be stripped.
                    if (conversion.DataType.IsWord)
                    {
                        return exp;
                    }
                }
                conversion = new Conversion(exp, exp.DataType, conversion.DataType);
            }
            if (convertConvertRule.Match(conversion))
            {
                Changed = true;
                return convertConvertRule.Transform();
            }
            return conversion;
        }

        /// <summary>
        /// Take a bitvector of type wordXXX and reinterpret it as a floating-point
        /// constant.
        /// </summary>
        /// <param name="ptCast">Floating-point type to which the raw bits are being cast.</param>
        /// <param name="rawBits">The raw bits being cast.</param>
        /// <returns>A floating-point constant, possibly with a <see cref="Cast"/> wrapped around it
        /// if the constant is not 32- or 64-bit.
        /// </returns>
        private Expression CastRawBitsToReal(PrimitiveType ptCast, Constant rawBits)
        {
            var bitSize = Math.Min(rawBits.DataType.BitSize, 64);
            var dtImm = PrimitiveType.Create(Domain.Real, bitSize);
            var cImm = Constant.RealFromBitpattern(dtImm, rawBits.ToInt64());
            cImm = ConstantReal.Create(dtImm, cImm.ToReal64());
            if (cImm.DataType.BitSize == ptCast.BitSize)
            {
                return cImm;
            }
            else
            {
                return new Conversion(cImm, cImm.DataType, ptCast);
            }
        }

        public virtual Expression VisitCast(Cast cast)
        {
            var e = cast.Expression.Accept(this);
            return new Cast(cast.DataType, e);
        }

        public virtual Expression VisitConditionalExpression(ConditionalExpression c)
        {
            var cond = c.Condition.Accept(this);
            var t = c.ThenExp.Accept(this);
            var f = c.FalseExp.Accept(this);
            if (cond is Constant cCond && cCond.DataType == PrimitiveType.Bool)
            {
                if (cCond.IsZero)
                    return f;
                else
                    return t;
            }
            return new ConditionalExpression(c.DataType, cond, t, f);
        }

        public virtual Expression VisitConditionOf(ConditionOf c)
        {
            var e = c.Expression.Accept(this);
            //$REVIEW: if e == 0, then Z flags could be set to 1. But that's architecture specific, so
            // we leave that as an exercise to re reader
            if (e != c.Expression)
                c = new ConditionOf(e);
            return c;
        }

        public virtual Expression VisitConstant(Constant c)
        {
            return c;
        }

        public virtual Expression VisitDereference(Dereference deref)
        {
            var e = deref.Expression.Accept(this);
            return new Dereference(deref.DataType, e);
        }

        public virtual Expression VisitFieldAccess(FieldAccess acc)
        {
            throw new NotImplementedException();
        }

        public virtual Expression VisitIdentifier(Identifier id)
        {
            if (idConst.Match(id))
            {
                Changed = true;
                return idConst.Transform();
            }
            if (idProcConstRule.Match(id))
            {
                Changed = true;
                return idProcConstRule.Transform();
            }
            // jkl: Copy propagation causes real problems when used during trashed register analysis.
            // If needed in other passes, it should be an option for expression e
            if (idCopyPropagation.Match(id))
            {
                Changed = true;
                return idCopyPropagation.Transform();
            }
            if (idBinIdc.Match(id))
            {
                Changed = true;
                return idBinIdc.Transform();
            }
            return id;
        }

        public virtual Expression VisitMemberPointerSelector(MemberPointerSelector mps)
        {
            if (mpsRule.Match(mps))
            {
                Changed = true;
                return mpsRule.Transform();
            }
            return mps;
        }

        public virtual Expression VisitMemoryAccess(MemoryAccess access)
        {
            var value = new MemoryAccess(
                access.MemoryId,
                access.EffectiveAddress.Accept(this),
                access.DataType);
            var newValue = ctx.GetValue(value, segmentMap);
            if (newValue != value)
            {
                ctx.RemoveExpressionUse(value);
                ctx.UseExpression(newValue);
            }
            return newValue;
        }

        public virtual Expression VisitMkSequence(MkSequence seq)
        {
            var newSeq = seq.Expressions.Select(e =>
            {
                var eNew = e.Accept(this);
                if (eNew == Constant.Invalid)
                    eNew = e;
                return eNew;
            }).ToArray();
            if (newSeq.Length == 2)
            {
                // Special case for the frequent case of segment:offset or 
                // two concatenated bit vectors.
                if (newSeq[0] is Constant c1 && newSeq[1] is Constant c2)
                {
                    PrimitiveType tHead = (PrimitiveType) c1.DataType;
                    PrimitiveType tTail = (PrimitiveType) c2.DataType;
                    PrimitiveType t;
                    Changed = true;
                    if (tHead.Domain == Domain.Selector)            //$REVIEW: seems to require Address, SegmentedAddress?
                    {
                        t = PrimitiveType.Create(Domain.Pointer, tHead.BitSize + tTail.BitSize);
                        return ctx.MakeSegmentedAddress(c1, c2);
                    }
                    else
                    {
                        t = PrimitiveType.Create(tHead.Domain, tHead.BitSize + tTail.BitSize);
                        return Constant.Create(t, (c1.ToUInt64() << tTail.BitSize) | c2.ToUInt64());
                    }
                }
            }
            else if (newSeq.All(e => e is Constant))
            {
                //$TODO: > 64 bit values?
                ulong value = 0;
                for (int i = 0; i < newSeq.Length; ++i)
                {
                    var c = (Constant) newSeq[i];
                    value = (value << c.DataType.BitSize) | c.ToUInt64();
                }
                return Constant.Create(seq.DataType, value);
            }
            if (newSeq.Take(newSeq.Length - 1).All(e => e.IsZero))
            {
                var tail = newSeq.Last();
                // leading zeros imply a conversion to unsigned.
                return new Conversion(
                    tail,
                    PrimitiveType.Create(Domain.UnsignedInt, tail.DataType.BitSize),
                    PrimitiveType.Create(Domain.UnsignedInt, seq.DataType.BitSize));
            }
            var mem = FuseAdjacentMemoryAccesses(seq.DataType, newSeq);
            if (mem != null)
                return mem;
            return FuseAdjacentSlices(seq.DataType, newSeq);
        }

        private Expression? FuseAdjacentMemoryAccesses(DataType dt, Expression[] elems)
        {
            var (access, seg, ea, offset) = AsMemoryAccess(elems[0]);
            if (access == null)
                return null;
            var fused = new List<Expression>();
            var offsetFused = offset;
            for (int i = 1; i < elems.Length; ++i)
            {
                var (accNew, segNew, eaNew, offNew) = AsMemoryAccess(elems[i]);
                if (accNew == null)
                    return null;
                if (cmp.Equals(seg, segNew) &&
                    cmp.Equals(ea, eaNew) &&
                    ctx.Endianness.OffsetsAdjacent(offNew, offset, accNew.DataType.Size))
                {
                    offsetFused = Math.Min(offsetFused, offNew);
                }
                else
                    return null;
            }
            Expression fusedEa;
            if (ea is null)
            {
                fusedEa = Constant.Create(access.EffectiveAddress.DataType, (ulong)offsetFused);
            }
            else
            {
                fusedEa = m.AddSubSignedInt(ea, offsetFused);
            }

            var result = (seg is null)
                ? m.Mem(access.MemoryId, dt, fusedEa)
                : m.SegMem(access.MemoryId, dt, seg, fusedEa);

            foreach (var e in elems)
                ctx.RemoveExpressionUse(e);
            ctx.UseExpression(result);
            return result;
        }

        private (MemoryAccess? access, Expression? seg, Expression? ea, long offset) AsMemoryAccess(Expression expression)
        {
            MemoryAccess access;
            Expression? seg;
            Expression ea;
            if (expression is SegmentedAccess segmem)
            {
                access = segmem;
                seg = segmem.BasePointer;
                ea = segmem.EffectiveAddress;
            }
            else if (expression is MemoryAccess mem)
            {
                access = mem;
                seg = null;
                ea = mem.EffectiveAddress;
            }
            else
                return (null, null, null, 0);

            long offset = 0;
            Expression? eaStripped = ea;
            if (ea is Constant global)
            {
                offset = global.ToInt64();
                eaStripped = null;
            }
            else if (ea is Address addr && !addr.Selector.HasValue)
            {
                offset = (long) addr.ToLinear();
                eaStripped = null;
            }
            else if (ea is BinaryExpression bin)
            {
                if (bin.Right is Constant c)
                {
                    if (bin.Operator == Operator.IAdd)
                    {
                        offset = c.ToInt64();
                        eaStripped = bin.Left;
                    }
                    else if (bin.Operator == Operator.ISub)
                    {
                        offset = -c.ToInt64();
                        eaStripped = bin.Left;
                    }
                }
            }
            return (access, seg, eaStripped, offset);
        }

        private Expression FuseAdjacentSlices(DataType dataType, Expression[] elems)
        {
            var fused = new List<Expression> { AsSlice(elems[0]) ?? elems[0] };
            bool changed = false;
            for (int i = 1; i < elems.Length; ++i)
            {
                Slice? slNext = AsSlice(elems[i]);
                if (fused[fused.Count - 1] is Slice slPrev && slNext != null &&
                    cmp.Equals(slPrev.Expression, slNext.Expression) &&
                    slPrev.Offset == slNext.Offset + slNext.DataType.BitSize)
                {
                    // Fuse the two consecutive slices. 
                    var newSlice = new Slice(
                        PrimitiveType.CreateWord(slPrev.DataType.BitSize + slNext.DataType.BitSize),
                        slNext.Expression,
                        slNext.Offset);
                    fused[fused.Count - 1] = newSlice.Accept(this);
                    changed = true;
                }
                else
                {
                    fused.Add(elems[i]);
                }
            }
            if (changed)
            {
                foreach (var e in elems)
                    ctx.RemoveExpressionUse(e);
                foreach (var f in fused)
                    ctx.UseExpression(f);
                if (fused.Count == 1)
                    return fused[0];
                else
                    return new MkSequence(dataType, fused.ToArray());
            }
            else
            {
                return new MkSequence(dataType, elems);
            }
        }

        private Slice? AsSlice(Expression? e)
        {
            if (e is Identifier id)
            {
                e = ctx.GetDefiningExpression(id);
            }
            if (e is Cast c)
            {
                return new Slice(c.DataType, c.Expression, 0);
            }
            else
            {
                return e as Slice;
            }
        }

        public virtual Expression VisitOutArgument(OutArgument outArg)
        {
            Expression exp;
            if (outArg.Expression is Identifier)
                exp = outArg.Expression;
            else 
                exp = outArg.Expression.Accept(this);
            return new OutArgument(outArg.DataType, exp);
        }

        public virtual Expression VisitPhiFunction(PhiFunction pc)
        {
            var oldChanged = Changed;
            var args = pc.Arguments
                .Select(a =>
                {
                    var arg = SimplifyPhiArg(a.Value.Accept(this));
                    ctx.RemoveExpressionUse(arg);
                    return arg;
                })
                .Where(a => ctx.GetValue((a as Identifier)!) != pc)
                .ToArray();
            Changed = oldChanged;

            var cmp = new ExpressionValueComparer();
            var e = args.FirstOrDefault();
            if (e != null && args.All(a => cmp.Equals(a, e)))
            {
                Changed = true;
                ctx.UseExpression(e);
                return e;
            }
            else
            {
                ctx.UseExpression(pc);
                return pc;
            }
        }

        /// <summary>
        /// VisitBinaryExpression method could not simplify following statements:
        ///    y = x - const
        ///    a = y + const
        ///    x = phi(a, b)
        /// to
        ///    y = x - const
        ///    a = x
        ///    x = phi(a, b)
        /// IdBinIdc rule class processes y as 'used in phi' and prevents propagation.
        /// This method could be used to do such simplification (y + const ==> x)
        /// </summary
        private Expression SimplifyPhiArg(Expression arg)
        {
            if (!(arg is BinaryExpression bin &&
                  bin.Left is Identifier idLeft &&
                  ctx.GetValue(idLeft) is BinaryExpression binLeft))
                return arg;

            ctx.RemoveIdentifierUse(idLeft);
            ctx.UseExpression(binLeft);
            bin = new BinaryExpression(
                bin.Operator,
                bin.DataType,
                binLeft,
                bin.Right);
            return bin.Accept(this);
        }

        public virtual Expression VisitPointerAddition(PointerAddition pa)
        {
            return pa;
        }

        public virtual Expression VisitProcedureConstant(ProcedureConstant pc)
        {
            return pc;
        }

        public virtual Expression VisitScopeResolution(ScopeResolution sc)
        {
            return sc;
        }

        public virtual Expression VisitSegmentedAccess(SegmentedAccess segMem)
        {
            var basePtr = segMem.BasePointer.Accept(this);
            var offset = segMem.EffectiveAddress.Accept(this);
            if (basePtr is Constant cBase && offset is Constant cOffset)
            {
                var addr = ctx.MakeSegmentedAddress(cBase, cOffset);
                var mem = new MemoryAccess(segMem.MemoryId, addr, segMem.DataType);
                return ctx.GetValue(mem, segmentMap);
            }
            segMem = new SegmentedAccess(segMem.MemoryId, basePtr, offset, segMem.DataType);
            if (sliceSegPtr.Match(segMem))
            {
                Changed = true;
                return sliceSegPtr.Transform();
            }
            return ctx.GetValue(segMem, segmentMap);
        }

        public virtual Expression VisitSlice(Slice slice)
        {
            var e = slice.Expression.Accept(this);
            // Is the slice the same size as the expression?
            if (slice.Offset == 0 && slice.DataType.BitSize == e.DataType.BitSize)
                return e;
            slice = new Slice(slice.DataType, e, slice.Offset);
            if (sliceConst.Match(slice))
            {
                Changed = true;
                return sliceConst.Transform();
            }
            if (sliceMem.Match(slice))
            {
                Changed = true;
                return sliceMem.Transform();
            }

            // (slice (shl e n) n) ==> e
            if (sliceShift.Match(slice))
            {
                Changed = true;
                return sliceShift.Transform();
            }
            if (sliceSeq.Match(slice))
            {
                Changed = true;
                return sliceSeq.Transform();
            }
            if (sliceConvert.Match(slice))
            {
                Changed = true;
                return sliceConvert.Transform();
            }
            if (e is Identifier id &&
                ctx.GetDefiningExpression(id) is MkSequence seq)
            {
                // If we are casting a SEQ, and the corresponding element is >= 
                // the size of the cast, then use deposited part directly.
                var lsbElem = seq.Expressions[seq.Expressions.Length - 1];
                int sizeDiff = lsbElem.DataType.Size - slice.DataType.Size;
                if (sizeDiff >= 0)
                {
                    foreach (var elem in seq.Expressions)
                    {
                        ctx.RemoveExpressionUse(elem);
                    }
                    ctx.UseExpression(lsbElem);
                    Changed = true;
                    if (sizeDiff > 0)
                    {
                        return new Slice(slice.DataType, lsbElem, slice.Offset);
                    }
                    else
                    {
                        return lsbElem;
                    }
                }
            }
            return slice;
        }

        public virtual Expression VisitTestCondition(TestCondition tc)
        {
            return new TestCondition(tc.ConditionCode, tc.Expression.Accept(this));
        }

        public virtual Expression VisitUnaryExpression(UnaryExpression unary)
        {
            unary = new UnaryExpression(unary.Operator, unary.DataType, unary.Expression.Accept(this));
            if (negSub.Match(unary))
            {
                Changed = true;
                return negSub.Transform();
            }

            // (!-exp) >= (!exp)
            if (logicalNotFollowedByNeg.Match(unary))
            {
                Changed = true;
                return logicalNotFollowedByNeg.Transform();
            }

            return unary;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(286,17): error CS0841: Cannot use local variable 'cRight' before it is declared,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(361,71): error CS0128: A local variable or function named 'cRight' is already defined in this scope,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(384,76): error CS0128: A local variable or function named 'cRight' is already defined in this scope,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(428,54): error CS0128: A local variable or function named 'cRight' is already defined in this scope,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(442,76): error CS0128: A local variable or function named 'cRight' is already defined in this scope,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(386,63): error CS8602: Dereference of a possibly null reference.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(387,18): error CS8602: Dereference of a possibly null reference.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(415,57): error CS8602: Dereference of a possibly null reference.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(418,58): error CS8604: Possible null reference argument for parameter 'c1' in 'Constant Operator.ApplyConstants(Constant c1, Constant c2)'.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(436,21): error CS8602: Dereference of a possibly null reference.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(448,21): error CS8602: Dereference of a possibly null reference.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(453,86): error CS8604: Possible null reference argument for parameter 'l' in 'Constant ExpressionSimplifier.SimplifyTwoConstants(BinaryOperator op, Constant l, Constant r)'.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(462,30): error CS8602: Dereference of a possibly null reference.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(463,75): error CS8604: Possible null reference argument for parameter 'l' in 'Constant ExpressionSimplifier.SimplifyTwoConstants(BinaryOperator op, Constant l, Constant r)'.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(365,74): error CS0165: Use of unassigned local variable 'cRight',D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(461,45): error CS0165: Use of unassigned local variable 'idLeft',D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Evaluation\ExpressionSimplifier.cs(23,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Decompiler\Scanning\Backwalker.cs
Description: Error: Unable to create valid SyntaxTree for document: Backwalker.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (bin.Left is Identifier idLeft && bin.Right is Identifier idRight)
            {
                // Can't handle [id1 + id2] yet.
                return null;
            }
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (bin.Left is Identifier idLeft && bin.Right is Identifier idRight)
            {
                // Can't handle [id1 + id2] yet.
                return null;
            }
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core;
using Reko.Core.Expressions;
using Reko.Core.Lib;
using Reko.Core.Operators;
using Reko.Core.Rtl;
using Reko.Core.Types;
using Reko.Evaluation;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Reko.Scanning
{
    /// <summary>
    /// Walks code backwards to find "dominating" comparisons against constants,
    /// which may provide vector table limits.
    /// </summary>
    /// <remarks>
    /// This is a godawful hack; a proper range analysis would be much
    /// better. Have a spare few months?
    /// </remarks>
    public class Backwalker<TBlock, TInstr>
        where TBlock : class
        where TInstr : class
	{
        private static readonly TraceSwitch trace = new TraceSwitch("BackWalker", "Traces the progress backward instruction walking");

        private readonly IBackWalkHost<TBlock, TInstr> host;
        private readonly ExpressionSimplifier eval;
        private Identifier? UsedAsFlag;
        private TBlock? startBlock;

        public Backwalker(IBackWalkHost<TBlock, TInstr> host, RtlTransfer xfer, ExpressionSimplifier eval)
		{
            this.host = host;
            this.eval = eval;
            var target = xfer.Target;
            if (xfer.Target is MkSequence seq && seq.Expressions.Length == 2)
            {
                target = seq.Expressions[1];
            }
            if (target is MemoryAccess mem)
            {
                Index = DetermineIndexRegister(mem);
            }
            else
            {
                Index = RegisterOf(target as Identifier);
            }
            Operations = new List<BackwalkOperation>();
            JumpSize = target.DataType.Size;
        }

        /// <summary>
        /// The register used to perform a table-dispatch switch.
        /// </summary>
        public RegisterStorage? Index { get; private set; }
        public Expression? IndexExpression { get; set; }
        public Identifier? UsedFlagIdentifier { get; set; }
        public int Stride { get; private set; }
        public Address? VectorAddress { get; private set; }
        public List<BackwalkOperation> Operations { get; private set; }
        public int JumpSize { get; set; }

        /// <summary>
        /// Walks backward along the <paramref name="block"/>, recording the operations 
        /// done to the idx register. The operations are used to reconstruct
        /// the indexing expression, which gives clues to its layout.
        /// </summary>
        /// <param name="block"></param>
        /// <returns></returns>
        public List<BackwalkOperation>? BackWalk(TBlock block)
        {
            this.startBlock = block;
            if (Stride > 1)
                Operations.Add(new BackwalkOperation(BackwalkOperator.mul, Stride));

            bool continueBackwalking = BackwalkInstructions(Index, block);
            if ((Index == null || Index == RegisterStorage.None) && IndexExpression == null)
                return null;	// unable to find guard.

            if (continueBackwalking)
            {
                block = host.GetSinglePredecessor(block);
                if (block == null)
                    return null;	// seems unguarded to me.

                BackwalkInstructions(Index, block);
                if (Index == null && IndexExpression == null)
                    return null;
            }
            Operations.Reverse();
            return Operations;
        }

        public bool BackwalkInstruction(TInstr instr)
        {
            var ass = host.AsAssignment(instr);
            if (ass != null)
            {
                var assSrc = ass.Item2.Accept(eval);
                var assDst = ass.Item1;
                var regSrc = RegisterOf(assSrc);
                if (assSrc is BinaryExpression binSrc)
                {
                    if (RegisterOf(assDst) == Index || assDst == IndexExpression)
                    {
                        regSrc = RegisterOf(binSrc.Left);
                        var immSrc = binSrc.Right as Constant;
                        if (binSrc.Operator == Operator.IAdd || binSrc.Operator == Operator.ISub)
                        {
                            Index = HandleAddition(Index, Index, regSrc, immSrc!, binSrc.Operator == Operator.IAdd);
                            return true;
                        }
                        if (binSrc.Operator == Operator.And)
                        {
                            if (immSrc != null && Bits.IsEvenPowerOfTwo(immSrc.ToInt32() + 1))
                            {
                                Operations.Add(new BackwalkOperation(BackwalkOperator.cmp, immSrc.ToInt32() + 1));
                            }
                            else
                            {
                                Index = null;
                            }
                            return false;
                        }
                        if (binSrc.Operator is IMulOperator && immSrc != null)
                        {
                            var m = immSrc.ToInt32();
                            Operations.Add(new BackwalkOperation(BackwalkOperator.mul, m));
                            Stride *= m;
                            return true;
                        }
                        if (binSrc.Operator is ShlOperator && immSrc != null)
                        {
                            var m = 1 << immSrc.ToInt32();
                            Operations.Add(new BackwalkOperation(BackwalkOperator.mul, m));
                            Stride *= m;
                            return true;
                        }
                    }
                    if (Index != null &&
                        binSrc.Operator == Operator.Xor &&
                        binSrc.Left == assDst &&
                        binSrc.Right == assDst &&
                        RegisterOf(assDst) == host.GetSubregister(Index, 8, 8))
                    {
                        Operations.Add(new BackwalkOperation(BackwalkOperator.and, 0xFF));
                        Index = host.GetSubregister(Index, 0, 8);
                    }
                }
                var cSrc = assSrc as Constant;
                if (Index != null &&
                    cSrc != null &&
                    cSrc.IsIntegerZero &&
                    RegisterOf(assDst) == host.GetSubregister(Index, 8, 8))
                {
                    // mov bh,0 ;; xor bh,bh
                    // jmp [bx...]
                    Operations.Add(new BackwalkOperation(BackwalkOperator.and, 0xFF));
                    Index = host.GetSubregister(Index, 0, 8);
                    return true;
                }
                if (assSrc is ConditionOf cof && UsedFlagIdentifier != null)
                {
                    var grfDef = (((Identifier)assDst).Storage as FlagGroupStorage)!.FlagGroupBits;
                    var grfUse = (UsedFlagIdentifier.Storage as FlagGroupStorage)!.FlagGroupBits;
                    if ((grfDef & grfUse) == 0)
                        return true;
                    var binCmp = cof.Expression as BinaryExpression;
                    binCmp = NegateRight(binCmp);
                    if (binCmp != null &&
                        (binCmp.Operator is ISubOperator ||
                         binCmp.Operator is USubOperator))
                    {
                        var idLeft = RegisterOf(binCmp.Left  as Identifier);
                        if (idLeft != null &&
                            (idLeft == Index || idLeft == host.GetSubregister(Index!, 0, 8)) ||
                           (IndexExpression != null && IndexExpression.ToString() == idLeft!.ToString()))    //$HACK: sleazy, but we don't appear to have an expression comparer
                        {
                            if (binCmp.Right is Constant immSrc)
                            {
                                // Found the bound of the table.
                                Operations.Add(new BackwalkOperation(BackwalkOperator.cmp, immSrc.ToInt32()));
                                return false;
                            }
                        }
                    }
                    if (cof.Expression is Identifier idCof)
                    {
                        IndexExpression = idCof;
                        Index = null;
                        UsedFlagIdentifier = null;
                        UsedAsFlag = idCof;
                        return true;
                    }
                }

                //$BUG: this is rubbish, the simplifier should _just_
                // perform simplification, no substitutions.
                var src = assSrc == Constant.Invalid ? ass.Item2 : assSrc;
                var cvtSrc = src as Conversion;
                if (cvtSrc != null)
                    src = cvtSrc.Expression;
                var regDst = RegisterOf(assDst);
                if (src is MemoryAccess memSrc &&
                    (regDst == Index ||
                     (Index != null && regDst != null && regDst.Name != "None" && regDst.IsSubRegisterOf(Index))))
                {
                    // R = Mem[xxx]
                    var rIdx = Index;
                    var rDst = RegisterOf(assDst);
                    if ((rDst != host.GetSubregister(rIdx, 0, 8) && cvtSrc == null) &&
                        rDst != rIdx)
                    {
                        Index = RegisterStorage.None;
                        IndexExpression = src;
                        return true;
                    }

                    if (!(memSrc.EffectiveAddress is BinaryExpression binEa))
                    {
                        Index = RegisterStorage.None;
                        IndexExpression = null;
                        return false;
                    }
                    var scale = GetMultiplier(binEa.Left);
                    var baseReg = GetBaseRegister(binEa.Left);
                    if (binEa.Right is Constant memOffset && binEa.Operator == Operator.IAdd)
                    {
                        var mOff = memOffset.ToInt32();
                        if (mOff > 0x200)
                        {
                            Operations.Add(new BackwalkDereference(memOffset.ToInt32(), scale));
                            Index = baseReg;
                            return true;
                        }
                    }

                    // Some architectures have pc-relative addressing, which the rewriters
                    // should convert to an _address_.
                    var addr = binEa.Left as Address;
                    baseReg = GetBaseRegister(binEa.Right);
                    if (!(addr is null || VectorAddress is null))
                    {
                        this.VectorAddress = addr;
                        Index = baseReg;
                        return true;
                    }
                    Index = RegisterStorage.None;
                    IndexExpression = ass.Item2;
                    return true;
                }

                if (regSrc != null && regDst == Index)
                {
                    Index = regSrc;
                    return true;
                }
                UsedAsFlag = null;
                return true;
            }

            var bra = host.AsBranch(instr);
            if (bra != null)
            {
                bool fallthrough = host.IsFallthrough(instr, startBlock!);
                return VisitBranch(bra, fallthrough);
            }

            Debug.WriteLine("Backwalking not supported: " + instr);
            return true;
        }

        private bool VisitBranch(Expression bra, bool fallthrough)
        {
            if (bra is TestCondition cond)
            {
                ConditionCode cc = cond.ConditionCode;
                switch (cc)
                {
                case ConditionCode.UGE:
                case ConditionCode.UGT:
                case ConditionCode.GT:
                    break;
                    //$TODO: verify the branch direction here.
                case ConditionCode.ULE:
                    fallthrough = !fallthrough;
                    cc = ConditionCode.UGT;
                    break;
                case ConditionCode.ULT:
                    fallthrough = !fallthrough;
                    cc = ConditionCode.UGE;
                    break;
                default: return true;
                }
                if (fallthrough)
                {
                    Operations.Add(new BackwalkBranch(cc));
                    UsedFlagIdentifier = (Identifier)cond.Expression;
                }
            }
            return true;
        }

        private BinaryExpression? NegateRight(BinaryExpression? bin)
        {
            if (bin != null &&
                (bin.Operator == Operator.IAdd) &&
                bin.Right is Constant cRight)
            {
                return new BinaryExpression(
                    Operator.ISub,
                    bin.Left.DataType,
                    bin.Left,
                    cRight.Negate());
            }
            return bin;
        }

        private RegisterStorage RegisterOf(Expression? e)
        {
            if (e is Conversion c)
                e = c.Expression;
            if (e is Identifier id && id.Storage is RegisterStorage reg)
                return reg;
                return RegisterStorage.None;
        }

        public bool BackwalkInstructions(
            RegisterStorage? regIdx,
            IEnumerable<TInstr> backwardStatementSequence)
        {
            foreach (var instr in backwardStatementSequence)
            {
                if (!BackwalkInstruction(instr))
                    return false;
            }
            return true;
        }

        public bool BackwalkInstructions(
            RegisterStorage? regIdx,
            TBlock block)
        {
            return BackwalkInstructions(regIdx, host.GetBlockInstructions(block).Reverse()!);
        }

        [Conditional("DEBUG")]
        public void DumpBlock(RegisterStorage regIdx, Block block)
        {
            Debug.Print("Backwalking register {0} through block: {1}", regIdx, block.DisplayName);
            foreach (var stm in block.Statements  )
            {
                Debug.Print("    {0}", stm.Instruction);
            }
        }

        private RegisterStorage? GetBaseRegister(Expression ea)
        {
            if (ea is Identifier id)
                return RegisterOf(id);
            var bin = ea as BinaryExpression;
            if (bin == null)
                return RegisterStorage.None;
            var e = bin.Left;
            while (e is Cast)
            {
                e = ((Cast)e).Expression;
            }
            if (e == null)
                return null;
            if (e is Identifier idBase)
                return RegisterOf(idBase);
            if (bin == null)
                return RegisterStorage.None;
            var scaledExpr = bin.Left as BinaryExpression;
            return RegisterOf(scaledExpr!.Left as Identifier);
        }

        private int GetMultiplier(Expression exp)
        {
            var bin = exp as BinaryExpression;
            if (bin == null)
                return 1;
            if (bin.Operator is IMulOperator)
            {
                var scale = bin.Right as Constant;
                if (scale == null)
                    return 1;
                return scale.ToInt32();
            }
            else
                return 1;
        }

        public bool CanBackwalk()
        {
            return Index != null;
        }

        [Conditional("DEBUG")]
        private void DumpInstructions(StatementList instrs, int idx)
        {
            for (int i = 0; i < instrs.Count; ++i)
            {
                Debug.WriteLineIf(trace.TraceInfo,
                    string.Format("{0} {1}",
                    idx == i ? '*' : ' ',
                    instrs[i]));
            }
        }
		
        /// <summary>
        /// Given a memory access, attempts to determine the index register.
        /// </summary>
        /// <param name="mem"></param>
        /// <returns></returns>
        public RegisterStorage? DetermineIndexRegister(MemoryAccess mem)
        {
            Stride = 0;
            // Mem[reg]
            if (mem.EffectiveAddress is Identifier id)
            {
                Stride = 1;
                return RegisterOf(id);
            }
            if (!(mem.EffectiveAddress is BinaryExpression bin))
                return null;

            var idLeft = bin.Left as Identifier;
            var idRight = bin.Right as Identifier;
            if (idRight != null && idLeft == null)
            {
                // Rearrange so that the effective address is [id + C]
                var t = idLeft;
                idLeft = idRight;
                idRight = t;
            }
            if (idLeft != null && idRight != null)
            {
                // Can't handle [id1 + id2] yet.
                return null;
            }
            if (idLeft != null)
            {
                // We have [id + C]
                Stride = 1;
                if (host.IsStackRegister(idLeft.Storage))
                    return null;
                DetermineVector(mem, bin.Right);
                if (!(VectorAddress is null) && host.IsValidAddress(VectorAddress))
                    return RegisterOf(idLeft);
                else
                    return null;
            }
            var binLeft = bin.Left as BinaryExpression;
            if (IsScaledIndex(binLeft))
            {
                // We have [(id * C1) + C2]
                return DetermineVectorWithScaledIndex(mem, bin.Right, binLeft!);
            }
            var binRight = bin.Right as BinaryExpression;
            if (IsScaledIndex(binRight))
            {
                // We may have [C1 + (id * C2)]
                return DetermineVectorWithScaledIndex(mem, bin.Left, binRight!);
            }
            return null;
        }

        private bool IsScaledIndex(BinaryExpression? bin)
        {
            return bin != null && bin.Operator is IMulOperator && bin.Right is Constant;
        }

        private RegisterStorage DetermineVectorWithScaledIndex(MemoryAccess mem, Expression possibleVector, BinaryExpression scaledIndex)
        {
            Stride = ((Constant)scaledIndex.Right).ToInt32();   // Mem[x + reg * C]
            DetermineVector(mem, possibleVector);
            return RegisterOf(scaledIndex.Left as Identifier);
        }

        private void DetermineVector(MemoryAccess mem, Expression possibleVector)
        {
            if (!(possibleVector is Constant vector))
                return;
            if (vector.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
                return;
            if (mem is SegmentedAccess segmem)
            {
                if (segmem.BasePointer.Accept(eval) is Constant selector)
                {
                    VectorAddress = host.MakeSegmentedAddress(selector, vector);
                }
            }
            else
            {
                VectorAddress = host.MakeAddressFromConstant(vector);   //$BUG: 32-bit only, what about 16- and 64-
            }
        }

        private RegisterStorage? HandleAddition(
			RegisterStorage? regIdx,
			RegisterStorage? ropDst,
			RegisterStorage? ropSrc, 
			Constant immSrc, 
			bool add)
		{
			if (ropSrc != null && immSrc == null)
			{
				if (ropSrc == ropDst && add)
				{
					Operations.Add(new BackwalkOperation(BackwalkOperator.mul, 2));
                    Stride *= 2;
					return ropSrc;
				}		
				else
				{
					return null;
				}
			} 
			
            if (immSrc != null)
			{
                if (!add && UsedAsFlag == IndexExpression)
                {
                    Operations.Add(
                        new BackwalkOperation(
                            BackwalkOperator.cmp,
                            immSrc.ToInt32()));
                }
                else
                {
                    Operations.Add(new BackwalkOperation(
                        add ? BackwalkOperator.add : BackwalkOperator.sub,
                        immSrc.ToInt32()));
                }
				return ropSrc;
			}
			else
				return null;
		}
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core.Expressions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Reko.Core;
using Reko.Core.Operators;
using Reko.Core.Types;

namespace Reko.Scanning
{
    /// <summary>
    /// Evaluates IR expressions using value sets. The result of evaluating 
    /// an expression is another value set.
    /// </summary>
    /// <remarks>
    /// As a side effect, this evaluator tracks memory accesses and generates
    /// type information about them.
    /// </remarks>
    public class ValueSetEvaluator : ExpressionVisitor<ValueSet, BitRange>
    {
        private const int MaxTransferTableEntries = 2000;

        private readonly IProcessorArchitecture arch;
        private readonly SegmentMap segmentMap;
        private readonly Dictionary<Expression, ValueSet> context;
        private readonly ProcessorState? state;
        private readonly ExpressionValueComparer cmp;
        private readonly Dictionary<Address, DataType> memAccesses;

        public ValueSetEvaluator(IProcessorArchitecture arch, SegmentMap segmentMap, Dictionary<Expression, ValueSet> context, ProcessorState? state = null)
        {
            this.arch = arch;
            this.segmentMap = segmentMap;
            this.context = context;
            this.state = state;
            this.cmp = new ExpressionValueComparer();
            this.memAccesses = new Dictionary<Address, DataType>();
        }

        public (ValueSet, Dictionary<Address,DataType>) Evaluate(Expression expr)
        {
            var bitrange = new BitRange(0, (short)expr.DataType.BitSize);
            var values = expr.Accept(this, bitrange);
            return (values, this.memAccesses);
        }

        public ValueSet VisitAddress(Address addr, BitRange bitRange)
        {
            return new ConcreteValueSet(addr.DataType, addr.ToConstant());
        }

        public ValueSet VisitApplication(Application appl, BitRange bitRange)
        {
            return IntervalValueSet.Any;
        }

        public ValueSet VisitArrayAccess(ArrayAccess acc, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitBinaryExpression(BinaryExpression binExp, BitRange bitRange)
        {
            var cLeft = binExp.Left as Constant;
            var cRight = binExp.Right as Constant;
            //$TODO: it would be great if Address were simply a Constant.
            // but we have segmented addresses which need special treatment
            // everywhere.
            if (binExp.Left is Address aLeft)
                cLeft = aLeft.ToConstant();
            if (binExp.Right is Address aRight)
                cRight = aRight.ToConstant();

            if (cLeft != null && cRight != null)
            {
                return new IntervalValueSet(
                    cLeft.DataType,
                    StridedInterval.Constant(
                        binExp.Operator.ApplyConstants(cLeft, cRight)));
            }

            if (cLeft == null && cRight != null)
            {
                var left = binExp.Left.Accept(this, bitRange);
                if (binExp.Operator == Operator.IAdd)
                {
                    return left.Add(cRight);
                }
                else if (binExp.Operator == Operator.And)
                {
                    return left.And(cRight);
                }
                else if (binExp.Operator == Operator.Shl)
                {
                    return left.Shl(cRight);
                }
                else if (binExp.Operator == Operator.IMul)
                {
                    return left.IMul(cRight);
                }
                else if (binExp.Operator == Operator.ISub)
                {
                    return left.Sub(cRight);
                }
            }
            if (cRight == null && cLeft != null)
            {
                var right = binExp.Right.Accept(this, bitRange);
                if (binExp.Operator == Operator.IAdd)
                {
                    return right.Add(cLeft);
                }
                else if (binExp.Operator == Operator.And)
                {
                    return right.And(cLeft);
                }
            }
            if (binExp.Operator == Operator.IAdd)
            {
                if (cmp.Equals(binExp.Left, binExp.Right))
                {
                    var left = binExp.Left.Accept(this, bitRange);
                    return left.Shl(Constant.Int32(1));
                }
            }
            return IntervalValueSet.Any;
        }

        public ValueSet VisitCast(Cast cast, BitRange bitRange)
        {
            if (this.context.TryGetValue(cast, out ValueSet vs))
                return vs;
            var bitRangeNarrow = new BitRange(0, (short)cast.DataType.BitSize);
            vs = cast.Expression.Accept(this, bitRangeNarrow);
            if (cast.DataType.BitSize == cast.Expression.DataType.BitSize)
            {
                // no-op!
                return vs;
            }
            if (cast.DataType.BitSize < cast.Expression.DataType.BitSize)
            {
                return vs.Truncate(cast.DataType);
            }
            if (cast.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
            {
                return vs.SignExtend(cast.DataType);
            }
            return vs.ZeroExtend(cast.DataType);
        }

        public ValueSet VisitConditionalExpression(ConditionalExpression cond, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitConditionOf(ConditionOf cof, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitConstant(Constant c, BitRange bitRange)
        {
            return new ConcreteValueSet(c.DataType, c);
        }

        public ValueSet VisitConversion(Conversion conversion, BitRange bitRange)
        {
            if (this.context.TryGetValue(conversion, out ValueSet vs))
                return vs;
            var bitRangeNarrow = new BitRange(0, (short) conversion.DataType.BitSize);
            vs = conversion.Expression.Accept(this, bitRangeNarrow);
            if (conversion.DataType.BitSize == conversion.Expression.DataType.BitSize)
            {
                // no-op!
                return vs;
            }
            if (conversion.DataType.BitSize < conversion.Expression.DataType.BitSize)
            {
                return vs.Truncate(conversion.DataType);
            }
            if (conversion.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
            {
                return vs.SignExtend(conversion.DataType);
            }
            return vs.ZeroExtend(conversion.DataType);
        }


        public ValueSet VisitDereference(Dereference deref, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitFieldAccess(FieldAccess acc, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitIdentifier(Identifier id, BitRange bitRange)
        {
            if (context.TryGetValue(id, out ValueSet vs))
                return vs;
            if (state != null && state.GetValue(id) is Constant c && c.IsValid)
                return new ConcreteValueSet(c.DataType, c);
            return new IntervalValueSet(id.DataType, StridedInterval.Empty);
        }

        public ValueSet VisitMemberPointerSelector(MemberPointerSelector mps, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Evaluating a memory access forces the creation of a 
        /// Concrete value set.
        /// </summary>
        /// <param name="access"></param>
        /// <returns></returns>
        public ValueSet VisitMemoryAccess(MemoryAccess access, BitRange bitRange)
        {
            if (context.TryGetValue(access, out ValueSet value))
            {
                return value;
            }
            var eaRange = new BitRange(0, (short)access.EffectiveAddress.DataType.BitSize);
            var vs = access.EffectiveAddress.Accept(this, eaRange);
            return new ConcreteValueSet(
                access.DataType,
                vs.Values
                    .Take(MaxTransferTableEntries)
                    .Select(v => ReadValue(access.DataType, v))
                    .ToArray());
        }

        private Constant ReadValue(DataType dt, Expression eAddr)
        {
            if (eAddr is Constant cAddr)
            {
                var addr = arch.MakeAddressFromConstant(cAddr, false)!;
                if (!segmentMap.TryFindSegment(addr, out ImageSegment seg))
                    return Constant.Invalid;
                var rdr = arch.CreateImageReader(seg.MemoryArea, addr);
                memAccesses[addr] = dt;
                if (!rdr.TryRead((PrimitiveType)dt, out var c))
                    return Constant.Invalid;
                else
                    return c;
            }
            throw new NotImplementedException();
        }

        private Expression ReadSegmentedValue(DataType dt, Constant seg, Expression eOff)
        {
            if (eOff is Constant off)
            {
                var addr = arch.MakeSegmentedAddress(seg, off);
                if (!segmentMap.TryFindSegment(addr, out ImageSegment segment))
                    return Constant.Invalid;
                var rdr = arch.CreateImageReader(segment.MemoryArea, addr);
                memAccesses[addr] = dt;
                if (dt == PrimitiveType.SegPtr32)
                {
                    var addrRead = arch.ReadCodeAddress(dt.Size, rdr, null);
                    if (addrRead != null)
                    {
                        return addrRead;
                    }
                    else
                    {
                        //$REVIEW we want a warning here. OR the caller.
                        return Constant.Invalid;
                    }
                }
                else
                {
                    if (!rdr.TryRead((PrimitiveType) dt, out var v))
                        return Constant.Invalid;
                    else
                        return v;
                }
            }
            throw new NotImplementedException();
        }

        public ValueSet VisitMkSequence(MkSequence seq, BitRange bitRange)
        {
            if (bitRange.Lsb > 0)
            {
                // We seldom encounter this. If we do, we write the code accordingly.
                return ValueSet.Any;
            }
            var valuesets = new List<ValueSet>();
            int nTotalBits = 0;
            for (int i = seq.Expressions.Length-1; i >= 0 && nTotalBits < bitRange.Msb; --i)
            {
                var elem = seq.Expressions[i];
                var elemRange = new BitRange(0, Math.Min((short) elem.DataType.BitSize, (short) (bitRange.Msb - nTotalBits)));
                var vs = elem.Accept(this, elemRange);
                valuesets.Add(vs);
                nTotalBits += elem.DataType.BitSize;
            }
            if (valuesets.Count == 1)
                return valuesets[0];

            valuesets.Reverse();
            var consts = new Expression[valuesets.Count];
            for (int i = 0; i < valuesets.Count - 1; ++i)
            {
                var va = valuesets[i];
                if (va == ValueSet.Any)
                    return va;
                var aVa = va.Values.ToArray();
                if (aVa.Length != 1)
                    return ValueSet.Any;
                if (aVa[0] is Constant c)
                    consts[i] = c;
                else
                    return ValueSet.Any;
            }

            var vsTail = valuesets[valuesets.Count - 1];
            return new ConcreteValueSet(
                vsTail.DataType,
                vsTail.Values
                      .Select(v => MakeSequence(seq.DataType, consts, v))
                      .ToArray());
        }

        private Expression MakeSequence(DataType dataType, Expression [] exps, Expression off)
        {
            if (exps.Length == 2 &&
                exps[0] is Constant cSeg &&
                cSeg.DataType == PrimitiveType.SegmentSelector)
            {
                // Special case for segmented pointers.
                //$TODO: we really need a special MkSegmentedPointer expression type.
                return arch.MakeSegmentedAddress(cSeg, (Constant) off); 
            }
            exps[exps.Length - 1] = (Constant) off;
            return new MkSequence(dataType, exps);
        }

        public ValueSet VisitOutArgument(OutArgument outArgument, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitPhiFunction(PhiFunction phi, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitPointerAddition(PointerAddition pa, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitProcedureConstant(ProcedureConstant pc, BitRange bitRange)
        {
            Address addr;
            switch (pc.Procedure)
            {
            case Procedure proc:
                addr = proc.EntryAddress;
                var cAddr = addr.ToConstant();
                return new ConcreteValueSet(pc.DataType, cAddr);
            default:
                return ValueSet.Any;
            }
        }

        public ValueSet VisitScopeResolution(ScopeResolution scopeResolution, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitSegmentedAccess(SegmentedAccess access, BitRange bitRange)
        {
            if (context.TryGetValue(access, out ValueSet value))
            {
                return value;
            }
            var vs = access.EffectiveAddress.Accept(this, bitRange);

            var vaSeg = access.BasePointer.Accept(this, bitRange);
            if (vaSeg == ValueSet.Any)
                return vaSeg;
            var segs = vaSeg.Values.ToArray();
            if (segs.Length != 1)
                return ValueSet.Any;
            if (!(segs[0] is Constant cSeg))
                return ValueSet.Any;

            var vsOff = access.EffectiveAddress.Accept(this, bitRange);
            return new ConcreteValueSet(
                vsOff.DataType,
                vsOff.Values
                    .Select(v => ReadSegmentedValue(access.DataType, cSeg, v))
                    .ToArray());
        }

        public ValueSet VisitSlice(Slice slice, BitRange bitRange)
        {
            if (slice.Offset != 0)
            {
                // This rarely occurs in real-world code. We punt the implementation to when
                // it becomes necessary.
                return ValueSet.Any;
            }
            var bitRangeNarrow = new BitRange((short)slice.Offset, (short) (slice.Offset + slice.DataType.BitSize));
            ValueSet vs = slice.Expression.Accept(this, bitRangeNarrow);

            if (slice.DataType.BitSize == slice.Expression.DataType.BitSize)
            {
                // no-op!
                return vs;
            }
            if (slice.DataType.BitSize < slice.Expression.DataType.BitSize)
            {
                return vs.Truncate(slice.DataType);
            }
            if (slice.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
            {
                return vs.SignExtend(slice.DataType);
            }
            return vs.ZeroExtend(slice.DataType);
        }

        public ValueSet VisitTestCondition(TestCondition tc, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitUnaryExpression(UnaryExpression unary, BitRange bitRange)
        {
            throw new NotImplementedException();
        }
    }
}

---- Transformed Tree ----
using Reko.Core.Expressions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Reko.Core;
using Reko.Core.Operators;
using Reko.Core.Types;

namespace Reko.Scanning
{
    /// <summary>
    /// Evaluates IR expressions using value sets. The result of evaluating 
    /// an expression is another value set.
    /// </summary>
    /// <remarks>
    /// As a side effect, this evaluator tracks memory accesses and generates
    /// type information about them.
    /// </remarks>
    public class ValueSetEvaluator : ExpressionVisitor<ValueSet, BitRange>
    {
        private const int MaxTransferTableEntries = 2000;

        private readonly IProcessorArchitecture arch;
        private readonly SegmentMap segmentMap;
        private readonly Dictionary<Expression, ValueSet> context;
        private readonly ProcessorState? state;
        private readonly ExpressionValueComparer cmp;
        private readonly Dictionary<Address, DataType> memAccesses;

        public ValueSetEvaluator(IProcessorArchitecture arch, SegmentMap segmentMap, Dictionary<Expression, ValueSet> context, ProcessorState? state = null)
        {
            this.arch = arch;
            this.segmentMap = segmentMap;
            this.context = context;
            this.state = state;
            this.cmp = new ExpressionValueComparer();
            this.memAccesses = new Dictionary<Address, DataType>();
        }

        public (ValueSet, Dictionary<Address,DataType>) Evaluate(Expression expr)
        {
            var bitrange = new BitRange(0, (short)expr.DataType.BitSize);
            var values = expr.Accept(this, bitrange);
            return (values, this.memAccesses);
        }

        public ValueSet VisitAddress(Address addr, BitRange bitRange)
        {
            return new ConcreteValueSet(addr.DataType, addr.ToConstant());
        }

        public ValueSet VisitApplication(Application appl, BitRange bitRange)
        {
            return IntervalValueSet.Any;
        }

        public ValueSet VisitArrayAccess(ArrayAccess acc, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitBinaryExpression(BinaryExpression binExp, BitRange bitRange)
        {
            //$TODO: it would be great if Address were simply a Constant.
            // but we have segmented addresses which need special treatment
            // everywhere.
            if (binExp.Left is Address aLeft)
                cLeft = aLeft.ToConstant();
            if (binExp.Right is Address aRight)
                cRight = aRight.ToConstant();

            if (binExp.Left is Constant cLeft && binExp.Right is Constant cRight)
            {
                return new IntervalValueSet(
                    cLeft.DataType,
                    StridedInterval.Constant(
                        binExp.Operator.ApplyConstants(cLeft, cRight)));
            }

            if (cLeft == null && binExp.Right is Constant cRight)
            {
                var left = binExp.Left.Accept(this, bitRange);
                if (binExp.Operator == Operator.IAdd)
                {
                    return left.Add(cRight);
                }
                else if (binExp.Operator == Operator.And)
                {
                    return left.And(cRight);
                }
                else if (binExp.Operator == Operator.Shl)
                {
                    return left.Shl(cRight);
                }
                else if (binExp.Operator == Operator.IMul)
                {
                    return left.IMul(cRight);
                }
                else if (binExp.Operator == Operator.ISub)
                {
                    return left.Sub(cRight);
                }
            }

            if (cRight == null && binExp.Left is Constant cLeft)
            {
                var right = binExp.Right.Accept(this, bitRange);
                if (binExp.Operator == Operator.IAdd)
                {
                    return right.Add(cLeft);
                }
                else if (binExp.Operator == Operator.And)
                {
                    return right.And(cLeft);
                }
            }
            if (binExp.Operator == Operator.IAdd)
            {
                if (cmp.Equals(binExp.Left, binExp.Right))
                {
                    var left = binExp.Left.Accept(this, bitRange);
                    return left.Shl(Constant.Int32(1));
                }
            }
            return IntervalValueSet.Any;
        }

        public ValueSet VisitCast(Cast cast, BitRange bitRange)
        {
            if (this.context.TryGetValue(cast, out ValueSet vs))
                return vs;
            var bitRangeNarrow = new BitRange(0, (short)cast.DataType.BitSize);
            vs = cast.Expression.Accept(this, bitRangeNarrow);
            if (cast.DataType.BitSize == cast.Expression.DataType.BitSize)
            {
                // no-op!
                return vs;
            }
            if (cast.DataType.BitSize < cast.Expression.DataType.BitSize)
            {
                return vs.Truncate(cast.DataType);
            }
            if (cast.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
            {
                return vs.SignExtend(cast.DataType);
            }
            return vs.ZeroExtend(cast.DataType);
        }

        public ValueSet VisitConditionalExpression(ConditionalExpression cond, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitConditionOf(ConditionOf cof, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitConstant(Constant c, BitRange bitRange)
        {
            return new ConcreteValueSet(c.DataType, c);
        }

        public ValueSet VisitConversion(Conversion conversion, BitRange bitRange)
        {
            if (this.context.TryGetValue(conversion, out ValueSet vs))
                return vs;
            var bitRangeNarrow = new BitRange(0, (short) conversion.DataType.BitSize);
            vs = conversion.Expression.Accept(this, bitRangeNarrow);
            if (conversion.DataType.BitSize == conversion.Expression.DataType.BitSize)
            {
                // no-op!
                return vs;
            }
            if (conversion.DataType.BitSize < conversion.Expression.DataType.BitSize)
            {
                return vs.Truncate(conversion.DataType);
            }
            if (conversion.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
            {
                return vs.SignExtend(conversion.DataType);
            }
            return vs.ZeroExtend(conversion.DataType);
        }


        public ValueSet VisitDereference(Dereference deref, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitFieldAccess(FieldAccess acc, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitIdentifier(Identifier id, BitRange bitRange)
        {
            if (context.TryGetValue(id, out ValueSet vs))
                return vs;
            if (state != null && state.GetValue(id) is Constant c && c.IsValid)
                return new ConcreteValueSet(c.DataType, c);
            return new IntervalValueSet(id.DataType, StridedInterval.Empty);
        }

        public ValueSet VisitMemberPointerSelector(MemberPointerSelector mps, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Evaluating a memory access forces the creation of a 
        /// Concrete value set.
        /// </summary>
        /// <param name="access"></param>
        /// <returns></returns>
        public ValueSet VisitMemoryAccess(MemoryAccess access, BitRange bitRange)
        {
            if (context.TryGetValue(access, out ValueSet value))
            {
                return value;
            }
            var eaRange = new BitRange(0, (short)access.EffectiveAddress.DataType.BitSize);
            var vs = access.EffectiveAddress.Accept(this, eaRange);
            return new ConcreteValueSet(
                access.DataType,
                vs.Values
                    .Take(MaxTransferTableEntries)
                    .Select(v => ReadValue(access.DataType, v))
                    .ToArray());
        }

        private Constant ReadValue(DataType dt, Expression eAddr)
        {
            if (eAddr is Constant cAddr)
            {
                var addr = arch.MakeAddressFromConstant(cAddr, false)!;
                if (!segmentMap.TryFindSegment(addr, out ImageSegment seg))
                    return Constant.Invalid;
                var rdr = arch.CreateImageReader(seg.MemoryArea, addr);
                memAccesses[addr] = dt;
                if (!rdr.TryRead((PrimitiveType)dt, out var c))
                    return Constant.Invalid;
                else
                    return c;
            }
            throw new NotImplementedException();
        }

        private Expression ReadSegmentedValue(DataType dt, Constant seg, Expression eOff)
        {
            if (eOff is Constant off)
            {
                var addr = arch.MakeSegmentedAddress(seg, off);
                if (!segmentMap.TryFindSegment(addr, out ImageSegment segment))
                    return Constant.Invalid;
                var rdr = arch.CreateImageReader(segment.MemoryArea, addr);
                memAccesses[addr] = dt;
                if (dt == PrimitiveType.SegPtr32)
                {
                    var addrRead = arch.ReadCodeAddress(dt.Size, rdr, null);
                    if (addrRead != null)
                    {
                        return addrRead;
                    }
                    else
                    {
                        //$REVIEW we want a warning here. OR the caller.
                        return Constant.Invalid;
                    }
                }
                else
                {
                    if (!rdr.TryRead((PrimitiveType) dt, out var v))
                        return Constant.Invalid;
                    else
                        return v;
                }
            }
            throw new NotImplementedException();
        }

        public ValueSet VisitMkSequence(MkSequence seq, BitRange bitRange)
        {
            if (bitRange.Lsb > 0)
            {
                // We seldom encounter this. If we do, we write the code accordingly.
                return ValueSet.Any;
            }
            var valuesets = new List<ValueSet>();
            int nTotalBits = 0;
            for (int i = seq.Expressions.Length-1; i >= 0 && nTotalBits < bitRange.Msb; --i)
            {
                var elem = seq.Expressions[i];
                var elemRange = new BitRange(0, Math.Min((short) elem.DataType.BitSize, (short) (bitRange.Msb - nTotalBits)));
                var vs = elem.Accept(this, elemRange);
                valuesets.Add(vs);
                nTotalBits += elem.DataType.BitSize;
            }
            if (valuesets.Count == 1)
                return valuesets[0];

            valuesets.Reverse();
            var consts = new Expression[valuesets.Count];
            for (int i = 0; i < valuesets.Count - 1; ++i)
            {
                var va = valuesets[i];
                if (va == ValueSet.Any)
                    return va;
                var aVa = va.Values.ToArray();
                if (aVa.Length != 1)
                    return ValueSet.Any;
                if (aVa[0] is Constant c)
                    consts[i] = c;
                else
                    return ValueSet.Any;
            }

            var vsTail = valuesets[valuesets.Count - 1];
            return new ConcreteValueSet(
                vsTail.DataType,
                vsTail.Values
                      .Select(v => MakeSequence(seq.DataType, consts, v))
                      .ToArray());
        }

        private Expression MakeSequence(DataType dataType, Expression [] exps, Expression off)
        {
            if (exps.Length == 2 &&
                exps[0] is Constant cSeg &&
                cSeg.DataType == PrimitiveType.SegmentSelector)
            {
                // Special case for segmented pointers.
                //$TODO: we really need a special MkSegmentedPointer expression type.
                return arch.MakeSegmentedAddress(cSeg, (Constant) off); 
            }
            exps[exps.Length - 1] = (Constant) off;
            return new MkSequence(dataType, exps);
        }

        public ValueSet VisitOutArgument(OutArgument outArgument, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitPhiFunction(PhiFunction phi, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitPointerAddition(PointerAddition pa, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitProcedureConstant(ProcedureConstant pc, BitRange bitRange)
        {
            Address addr;
            switch (pc.Procedure)
            {
            case Procedure proc:
                addr = proc.EntryAddress;
                var cAddr = addr.ToConstant();
                return new ConcreteValueSet(pc.DataType, cAddr);
            default:
                return ValueSet.Any;
            }
        }

        public ValueSet VisitScopeResolution(ScopeResolution scopeResolution, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitSegmentedAccess(SegmentedAccess access, BitRange bitRange)
        {
            if (context.TryGetValue(access, out ValueSet value))
            {
                return value;
            }
            var vs = access.EffectiveAddress.Accept(this, bitRange);

            var vaSeg = access.BasePointer.Accept(this, bitRange);
            if (vaSeg == ValueSet.Any)
                return vaSeg;
            var segs = vaSeg.Values.ToArray();
            if (segs.Length != 1)
                return ValueSet.Any;
            if (!(segs[0] is Constant cSeg))
                return ValueSet.Any;

            var vsOff = access.EffectiveAddress.Accept(this, bitRange);
            return new ConcreteValueSet(
                vsOff.DataType,
                vsOff.Values
                    .Select(v => ReadSegmentedValue(access.DataType, cSeg, v))
                    .ToArray());
        }

        public ValueSet VisitSlice(Slice slice, BitRange bitRange)
        {
            if (slice.Offset != 0)
            {
                // This rarely occurs in real-world code. We punt the implementation to when
                // it becomes necessary.
                return ValueSet.Any;
            }
            var bitRangeNarrow = new BitRange((short)slice.Offset, (short) (slice.Offset + slice.DataType.BitSize));
            ValueSet vs = slice.Expression.Accept(this, bitRangeNarrow);

            if (slice.DataType.BitSize == slice.Expression.DataType.BitSize)
            {
                // no-op!
                return vs;
            }
            if (slice.DataType.BitSize < slice.Expression.DataType.BitSize)
            {
                return vs.Truncate(slice.DataType);
            }
            if (slice.DataType is PrimitiveType pt && pt.Domain == Domain.SignedInt)
            {
                return vs.SignExtend(slice.DataType);
            }
            return vs.ZeroExtend(slice.DataType);
        }

        public ValueSet VisitTestCondition(TestCondition tc, BitRange bitRange)
        {
            throw new NotImplementedException();
        }

        public ValueSet VisitUnaryExpression(UnaryExpression unary, BitRange bitRange)
        {
            throw new NotImplementedException();
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(25,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(26,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(90,17): error CS0841: Cannot use local variable 'cLeft' before it is declared,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(92,17): error CS0841: Cannot use local variable 'cRight' before it is declared,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(102,59): error CS0128: A local variable or function named 'cRight' is already defined in this scope,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(127,59): error CS0128: A local variable or function named 'cLeft' is already defined in this scope,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(132,38): error CS8604: Possible null reference argument for parameter 'right' in 'ValueSet ValueSet.Add(Constant right)'.,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(136,38): error CS8604: Possible null reference argument for parameter 'cRight' in 'ValueSet ValueSet.And(Constant cRight)'.,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(102,17): error CS0165: Use of unassigned local variable 'cLeft',D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(107,37): error CS0165: Use of unassigned local variable 'cRight',D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(25,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Scanning\ValueSetEvaluator.cs(26,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Analysis;
using Reko.Core;
using Reko.Core.Code;
using Reko.Core.Expressions;
using Reko.Core.Operators;
using Reko.Core.Types;
using Reko.Scanning;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Reko.Typing
{
    /// <summary>
    /// Pushes type information down from the root of an expression to its leaves.
    /// </summary>
    /// <remarks>
    ///    root
    ///   /  \ 
    /// leaf  leaf
    /// </remarks>
    public class ExpressionTypeDescender : ExpressionVisitor<bool, TypeVariable>
    {
        // Matches the effective address of Mem[p + c] where c is a constant.
        private static readonly ExpressionMatcher fieldAccessPattern = new ExpressionMatcher(
            new BinaryExpression(
                Operator.IAdd,
                ExpressionMatcher.AnyDataType(null),
                ExpressionMatcher.AnyExpression("p"),
                ExpressionMatcher.AnyConstant("c")));
        private static readonly ExpressionMatcher segFieldAccessPattern = new ExpressionMatcher(
            new MkSequence(
                ExpressionMatcher.AnyDataType(null),
                ExpressionMatcher.AnyExpression("p"),
                ExpressionMatcher.AnyConstant("c")));

        private readonly IPlatform platform;
        private readonly TypeStore store;
        private readonly TypeFactory factory;
        private readonly Unifier unifier;
        private readonly Identifier globals;
        private readonly Dictionary<Identifier,LinearInductionVariable> ivs;

        public ExpressionTypeDescender(Program program, TypeStore store, TypeFactory factory)
        {
            this.platform = program.Platform;
            this.globals = program.Globals;
            this.ivs = program.InductionVariables;
            this.store = store;
            this.factory = factory;
            this.unifier = new DataTypeBuilderUnifier(factory, store);
        }

        public bool VisitAddress(Address addr, TypeVariable tv)
        {
            MeetDataType(addr, tv.DataType);
            return false;
        }

        public bool VisitApplication(Application appl, TypeVariable tv)
        {
            MeetDataType(appl, appl.TypeVariable!.DataType);

            appl.Procedure.Accept(this, appl.Procedure.TypeVariable!);
            TypeVariable[] paramTypes = new TypeVariable[appl.Arguments.Length];
            for (int i = 0; i < appl.Arguments.Length; ++i)
            {
                appl.Arguments[i].Accept(this, appl.Arguments[i].TypeVariable!);
                paramTypes[i] = appl.Arguments[i].TypeVariable!;
            }
            FunctionTrait(appl.Procedure, appl.Procedure.DataType.BitSize, appl.TypeVariable!, paramTypes);
            BindActualTypesToFormalTypes(appl);
            return false;
        }

        private FunctionType? MatchFunctionPointer(DataType dt)
        {
            if (dt is Pointer ptr)
                return ptr.Pointee as FunctionType;
            else
                return null;
        }

        private FunctionType? ExtractSignature(Expression proc)
        {
            if (proc is ProcedureConstant pc)
                return pc.Procedure.Signature;
            return MatchFunctionPointer(proc.TypeVariable!.DataType);
        }

        private void BindActualTypesToFormalTypes(Application appl)
        {
            var sig = ExtractSignature(appl.Procedure);
            if (sig == null)
                return;
            var parameters = sig.Parameters!;
            if (!sig.IsVariadic && appl.Arguments.Length != parameters.Length)
                throw new InvalidOperationException(
                    string.Format("Call to {0} had {1} arguments instead of the expected {2}.",
                    appl.Procedure, appl.Arguments.Length, parameters.Length));
            for (int i = 0; i < appl.Arguments.Length; ++i)
            {
                if (!sig.IsVariadic || i < parameters.Length)
                {
                    MeetDataType(appl.Arguments[i], parameters[i].DataType);
                    parameters[i].Accept(this, parameters[i].TypeVariable!);
                }
            }
        }

        public void FunctionTrait(Expression function, int funcPtrBitSize, TypeVariable ret, params TypeVariable[] actuals)
        {
            if (function is ProcedureConstant pc &&
                pc.Procedure is ExternalProcedure ep &&
                ep.Characteristics != null &&
                ep.Characteristics.Allocator)
            {
                // Allocation sites mustn't be tied to other allocation sites. Don't mutate
                // the existing signature. 
                //$TODO: In fact, no user- or environment-provided function types should
                // ever merge new FunctionTypes into the existing signature; the existing 
                // signature should be treated as correct.
                return;
            }

            Identifier[] parameters = actuals
                .Select(a => new Identifier("", a, null!))
                .ToArray();
            var fn = factory.CreateFunctionType(
                new Identifier("", ret, null!),
                parameters);
            var pfn = factory.CreatePointer(fn, funcPtrBitSize);
            MeetDataType(function, pfn);
        }

        public bool VisitArrayAccess(ArrayAccess acc, TypeVariable tv)
        {
            MeetDataType(acc, acc.DataType);
            Expression arr;
            int offset;
            if (fieldAccessPattern.Match(acc.Array))
            {
                arr = fieldAccessPattern.CapturedExpression("p")!;
                offset = OffsetOf((Constant)fieldAccessPattern.CapturedExpression("c")!);
            }
            else if (segFieldAccessPattern.Match(acc.Array))
            {
                arr = segFieldAccessPattern.CapturedExpression("p")!;
                offset = OffsetOf((Constant)segFieldAccessPattern.CapturedExpression("c")!);
            }
            else
            {
                arr = acc.Array;
                offset = 0;
            }
            int stride = 1;
            if (acc.Index is BinaryExpression bIndex && (bIndex.Operator == Operator.IMul || bIndex.Operator == Operator.SMul || bIndex.Operator == Operator.UMul))
            {
                if (bIndex.Right is Constant c)
                {
                    stride = c.ToInt32();
                }
            }
            var tvElement = ArrayField(null, arr, arr.DataType.BitSize, offset, stride, 0, acc.TypeVariable!);

            MeetDataType(acc.Array, factory.CreatePointer(tvElement, acc.Array.DataType.BitSize));
            acc.Array.Accept(this, acc.Array.TypeVariable!);
            acc.Index.Accept(this, acc.Index.TypeVariable!);
            return false;
        }

        /// <summary>
        /// Assert that there is an array field at offset <paramref name="offset"/>
        /// of the structure pointed at by <paramref name="expStruct"/>.
        /// </summary>
        /// <param name="expBase"></param>
        /// <param name="expStruct"></param>
        /// <param name="structPtrSize"></param>
        /// <param name="offset"></param>
        /// <param name="elementSize"></param>
        /// <param name="length"></param>
        /// <param name="tvField"></param>
        /// <returns>A type variable for the array type of the field.</returns>
        private TypeVariable ArrayField(Expression? expBase, Expression expStruct, int structPtrBitSize, int offset, int elementSize, int length, TypeVariable tvField)
        {
            var dtElement = factory.CreateStructureType(null, elementSize);
            dtElement.Fields.Add(0, tvField);
            var tvElement = store.CreateTypeVariable(factory);
            tvElement.DataType = dtElement;
            tvElement.OriginalDataType = dtElement;
            StructField(expBase, expStruct, offset, factory.CreateArrayType(tvElement, length), structPtrBitSize);
            return tvElement;
        }

        /// <summary>
        /// Assert that there is a structure field at offset <paramref name="offset" />
        /// of <paramref name="eStructPtr"/>, which is treated as a pointer to the struct.
        /// </summary>
        /// <param name="eBase">Optional base pointer used in segmented addressing.</param>
        /// <param name="eStructPtr">Expression that is a pointer to a structure.</param>
        /// <param name="offset">An offset within that structure.</param>
        /// <param name="dtField">The data type of the field being accessed.</param>
        /// <param name="structPtrBitSize">Side of eStructPtr in bits.</param>
        /// <returns>The union of <paramref name="eStructPtr" /> with a pointer to a structure
        /// containing a field at offset <paramref name="offset" />.
        /// </returns>
        public DataType StructField(Expression? eBase, Expression eStructPtr, int offset, DataType dtField, int structPtrBitSize)
        {
            var s = factory.CreateStructureType(null, 0);
            var field = new StructureField(offset, dtField);
            s.Fields.Add(field);

            var pointer = eBase != null && eBase != globals
                ? (DataType)factory.CreateMemberPointer(eBase.TypeVariable!, s, structPtrBitSize)
                : (DataType)factory.CreatePointer(s, structPtrBitSize);
            return MeetDataType(eStructPtr, pointer);
        }

        public bool VisitBinaryExpression(BinaryExpression binExp, TypeVariable tv)
        {
            var eLeft = binExp.Left;
            var eRight= binExp.Right;
            if (binExp.Operator == Operator.IAdd)
            {
                var dt = PushAddendDataType(binExp.TypeVariable!.DataType, eRight.TypeVariable!.DataType);
                if (dt != null)
                    MeetDataType(eLeft, dt);
                dt = PushAddendDataType(binExp.TypeVariable!.DataType, eLeft.TypeVariable!.DataType);
                if (dt != null)
                    MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.ISub)
            {
                var dt = PushMinuendDataType(binExp.TypeVariable!.DataType, eRight.TypeVariable!.DataType);
                MeetDataType(eLeft, dt);
                dt = PushSubtrahendDataType(binExp.TypeVariable!.DataType, eLeft.TypeVariable!.DataType);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.And || binExp.Operator == Operator.Or)
            {
                //$REVIEW: need a push-logical-Data type to push [[a & 3]] = char into its left and right halves.
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.Integer | Domain.Character);
                MeetDataType(eLeft, dt);
                MeetDataType(eRight, dt);
            }
            else if (
                binExp.Operator == Operator.IMul ||
                binExp.Operator == Operator.IMod)
            {
                var dt = PrimitiveType.CreateWord(DataTypeOf(eLeft).BitSize).MaskDomain(Domain.Boolean | Domain.Integer );
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(DataTypeOf(eRight).BitSize).MaskDomain(Domain.Boolean | Domain.Integer);
                MeetDataType(eRight, dt);
            }
            else if (
                binExp.Operator == Operator.SMul ||
                binExp.Operator == Operator.SDiv)
            {
                var dt = PrimitiveType.CreateWord(DataTypeOf(eLeft).BitSize).MaskDomain(Domain.Boolean | Domain.SignedInt);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(DataTypeOf(eRight).BitSize).MaskDomain(Domain.Boolean | Domain.SignedInt);
                MeetDataType(eRight, dt);
            }
            else if (
                binExp.Operator == Operator.UMul ||
                binExp.Operator == Operator.UDiv)
            {
                var dt = PrimitiveType.CreateWord(DataTypeOf(eLeft).BitSize).MaskDomain(Domain.Boolean | Domain.UnsignedInt);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(DataTypeOf(eRight).BitSize).MaskDomain(Domain.Boolean | Domain.UnsignedInt);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.FAdd ||
                    binExp.Operator == Operator.FSub ||
                    binExp.Operator == Operator.FMul ||
                    binExp.Operator == Operator.FDiv)
            {
                var dt = PrimitiveType.Create(Domain.Real, eLeft.DataType.BitSize);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Real, eRight.DataType.BitSize);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator is SignedIntOperator)
            {
                var dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.SignedInt | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.SignedInt | Domain.Character);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator is UnsignedIntOperator)
            {
                var dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.Pointer| Domain.UnsignedInt | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.Pointer | Domain.UnsignedInt|Domain.Character);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.Eq || binExp.Operator == Operator.Ne||
                binExp.Operator == Operator.Xor || binExp.Operator == Operator.Cand ||
                binExp.Operator == Operator.Cor)
            {
                // Not much can be deduced here, except that the operands should have the same size. Earlier passes
                // already did that work, so just continue with the operands.
            } 
            else if (binExp.Operator is RealConditionalOperator)
            {
                // We know leaves must be floats
                var dt = PrimitiveType.Create(Domain.Real, eLeft.DataType.BitSize);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Real, eLeft.DataType.BitSize);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.Shl)
            {
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.Integer | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Integer, DataTypeOf(eRight).BitSize);
            }
            else if (binExp.Operator == Operator.Shr)
            {
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.UnsignedInt| Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Integer, DataTypeOf(eRight).BitSize);
            }
            else if (binExp.Operator == Operator.Sar)
            {
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.SignedInt | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Integer, DataTypeOf(eRight).BitSize);
            }
            else
                throw new TypeInferenceException($"Unhandled binary operator {binExp.Operator} in expression {binExp}.");
            eLeft.Accept(this, eLeft.TypeVariable!);
            eRight.Accept(this, eRight.TypeVariable!);
            return false;
        }

        private DataType? PushAddendDataType(DataType dtSum, DataType dtOther)
        {
            var ptSum = dtSum as PrimitiveType;
            var ptOther = dtOther as PrimitiveType;
            if (ptSum != null && ptSum.Domain == Domain.Pointer || dtSum is Pointer)
            {
                if (ptOther != null && ptOther.Domain == Domain.Pointer || dtOther is Pointer)
                {
                    return PrimitiveType.Create(Domain.SignedInt, dtSum.BitSize);
                }
                if (ptOther != null && (ptOther.Domain & Domain.Integer) != 0)
                {
                    return PrimitiveType.Create(Domain.Pointer, dtSum.BitSize);
                }
            }
            if (dtSum is MemberPointer mpSum)
            {
                if (dtOther is MemberPointer)
                    return PrimitiveType.Create(Domain.SignedInt, dtOther.BitSize);
                if (ptOther != null && (ptOther.Domain & Domain.Integer) != 0)
                {
                    return factory.CreateMemberPointer(mpSum.BasePointer, factory.CreateUnknown(), mpSum.BitSize);
                }
            }
            if (ptSum != null && ptSum.IsIntegral)
            {
                // With integral types, type information flows only from leaves
                // to root.
                return null;
            }
            if (ptSum != null && ptSum.Domain == Domain.Pointer || dtSum is Pointer)
            {
                return PrimitiveType.Create(Domain.SignedInt, dtSum.BitSize);
            }
            return dtSum;
        }

        private DataType PushMinuendDataType(DataType dtDiff, DataType dtSub)
        {
            var ptDiff = dtDiff as PrimitiveType;
            var ptSub = dtSub.ResolveAs<PrimitiveType>();
            if (dtDiff is Pointer || ptDiff != null && ptDiff.Domain == Domain.Pointer)
            {
                if (ptSub != null && (ptSub.Domain & Domain.Integer) != 0)
                    return PrimitiveType.Create(Domain.Pointer, dtDiff.BitSize);
                throw new TypeInferenceException($"Not handling {dtDiff} and {dtSub} yet.");
            }
            if (dtDiff is MemberPointer || ptDiff != null && ptDiff.Domain == Domain.Offset)
            {
                if (ptSub != null && (ptSub.Domain & Domain.Integer) != 0)
                    return dtDiff;
                throw new TypeInferenceException($"Not handling {dtDiff} and {dtSub} yet.");
            }
            return dtDiff;
        }

        private DataType PushSubtrahendDataType(DataType dtDiff, DataType dtMin)
        {
            var ptDiff = dtDiff as PrimitiveType;
            var ptMin = dtMin as PrimitiveType;
            if (dtDiff is Pointer || ptDiff != null && ptDiff.Domain == Domain.Pointer)
            {
                if (dtMin is Pointer || ptMin != null && ptMin.Domain == Domain.Pointer)
                    return PrimitiveType.Create(Domain.Integer, dtDiff.BitSize);
                throw new TypeInferenceException(string.Format("Not handling {0} and {1} yet", dtDiff, dtMin));
            }
            if (dtDiff is MemberPointer || ptDiff != null && ptDiff.Domain == Domain.Offset)
            {
                if (dtMin is MemberPointer || ptMin != null && ptMin.Domain == Domain.Offset)
                    return PrimitiveType.Create(Domain.Integer, dtDiff.BitSize);
                throw new TypeInferenceException(string.Format("Not handling {0} and {1} yet", dtDiff, dtMin));
            }
            return dtMin;
        }

        public DataType MeetDataType(Expression exp, DataType dt)
        {
            if (exp is Conversion || exp is Cast)
                return exp.TypeVariable!.DataType;
            return MeetDataType(exp.TypeVariable!, dt);
        }

        public DataType MeetDataType(TypeVariable tvExp, DataType dt)
        { 
            if (dt == PrimitiveType.SegmentSelector)
            {
                var seg = factory.CreateStructureType(null, 0);
                seg.IsSegment = true;
                var ptr = factory.CreatePointer(seg, dt.BitSize);
                dt = ptr;
            } 
            tvExp.DataType = unifier.Unify(tvExp.DataType, dt)!;
            tvExp.OriginalDataType = unifier.Unify(tvExp.OriginalDataType, dt)!;
            return tvExp.DataType;
        }

        public bool VisitCast(Cast cast, TypeVariable? tv)
        {
            MeetDataType(cast, cast.DataType);
            cast.Expression.Accept(this, cast.Expression.TypeVariable!);
            return false;
        }

        public bool VisitConditionalExpression(ConditionalExpression c, TypeVariable tv)
        {
            MeetDataType(c.Condition, PrimitiveType.Bool);
            c.Condition.Accept(this, c.Condition.TypeVariable!);
            c.ThenExp.Accept(this, c.TypeVariable!);
            c.FalseExp.Accept(this, c.TypeVariable!);
            return false;
        }

        public bool VisitConditionOf(ConditionOf cof, TypeVariable tv)
        {
            MeetDataType(cof, cof.DataType);
            cof.Expression.Accept(this, cof.Expression.TypeVariable!);
            return false;
        }

        public bool VisitConstant(Constant c, TypeVariable tv)
        {
            MeetDataType(c, tv.DataType);
            if (c.DataType == PrimitiveType.SegmentSelector)
            {
                //$TODO: instead of pushing it into globals, it should 
                // allocate special types for each segment. This can be 
                // done at load time.
                StructField(
                    null,
                    globals, 
                    c.ToInt32() * 0x10,   //$REVIEW Platform-dependent: only valid for x86 real mode.
                    c.TypeVariable!,
                    platform.PointerType.BitSize);
            }
            return false;
        }

        public bool VisitConversion(Conversion conversion, TypeVariable tv)
        {
     //       MeetDataType(conversion, conversion.DataType);
            MeetDataType(conversion.Expression, conversion.SourceDataType);
            conversion.Expression.Accept(this, conversion.Expression.TypeVariable!);
            return false;
        }

        public bool VisitDereference(Dereference deref, TypeVariable tv)
        {
            //$BUG: push (ptr (typeof(deref)
            deref.Expression.Accept(this, deref.Expression.TypeVariable!);
            return false;
        }

        public bool VisitFieldAccess(FieldAccess acc, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitIdentifier(Identifier id, TypeVariable tv)
        {
            return false;
        }

        public bool VisitMemberPointerSelector(MemberPointerSelector mps, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitMemoryAccess(MemoryAccess access, TypeVariable tv)
        {
            return VisitMemoryAccess(null, access.TypeVariable!, access.EffectiveAddress, globals);
        }

        private bool VisitMemoryAccess(Expression? basePointer, TypeVariable tvAccess, Expression effectiveAddress, Expression globals)
        {
            MeetDataType(tvAccess, tvAccess.DataType);
            int eaBitSize = effectiveAddress.TypeVariable!.DataType.BitSize;
            Expression p;
            int offset;
            if (fieldAccessPattern.Match(effectiveAddress))
            {
                // Mem[p + c]
                p = fieldAccessPattern.CapturedExpression("p")!;
                var c = ToConstant(fieldAccessPattern.CapturedExpression("c")!)!;
                offset = OffsetOf(c);
                if (p is Conversion cvt && cvt.SourceDataType.BitSize < cvt.DataType.BitSize)
                {
                    // p some convert-extended thing and cannot be a pointer; c therefore must be treated as a
                    // pointer and p is the index.
                    // First do the array index.
                    p.Accept(this, p.TypeVariable!);

                    // Now treat c as an array pointer.
                    var cbElement = tvAccess.DataType.Size;
                    var tvElement = ArrayField(basePointer, c, c.DataType.BitSize, 0, cbElement, 0, tvAccess);
                    StructField(basePointer, c, 0, tvElement, eaBitSize);
                    return false;
                }
                else if (p is Cast cast && cast.Expression.DataType.BitSize < cast.DataType.BitSize)
                {
                    p.Accept(this, p.TypeVariable!);

                    var cbElement = tvAccess.DataType.Size;
                    var tvElement = ArrayField(basePointer, c, c.DataType.BitSize, 0, cbElement, 0, tvAccess);
                    StructField(basePointer, c, 0, tvElement, eaBitSize);
                    return false;
                }
                else
                {
                    var iv = GetInductionVariable(p);
                    if (iv != null)
                    {
                        VisitInductionVariable(globals, (Identifier) p, iv, offset, tvAccess);
                    }
                    StructField(basePointer, p, offset, tvAccess, eaBitSize);
                }
            }
            else if (effectiveAddress is Constant c)
            {
                // Mem[c]
                p = effectiveAddress;
                offset = 0;
                //$BUG: offsets should be long for 64-bit architectures.
                StructField(null, globals, OffsetOf(c), tvAccess, eaBitSize);
            }
            else if (effectiveAddress is Address addr && !addr.Selector.HasValue)
            {
                // Mem[addr]
                //$TODO: what to do about segmented addresses?
                p = effectiveAddress;
                offset = 0;
                //$BUG: offsets should be long for 64-bit architectures.
                StructField(null, globals, (int) addr.ToLinear(), tvAccess, eaBitSize);
            }
            else if (IsArrayAccess(effectiveAddress))
            {
                // Mem[p + i] where i is integer type.
                var binEa = (BinaryExpression) effectiveAddress;
                VisitPossibleArrayAccess(basePointer, tvAccess, binEa.Left, binEa.Right, globals, eaBitSize);
                StructField(basePointer, effectiveAddress, 0, tvAccess, eaBitSize);
                effectiveAddress.Accept(this, effectiveAddress.TypeVariable!);
                return false;
            }
            else
            {
                // Mem[anything]
                p = effectiveAddress;
                offset = 0;
            }
            StructField(basePointer, p, offset, tvAccess, eaBitSize);
            p.Accept(this, p.TypeVariable!);
            return false;
        }

        private Constant? ToConstant(Expression expression)
        {
            if (expression is Constant c)
                return c;
            if (expression is Address addr)
                return addr.ToConstant();
            return null;
        }

        private void VisitPossibleArrayAccess(Expression? basePointer, TypeVariable tvAccess, Expression left, Expression right, Expression globals, int eaBitSize)
        {

            // First do the array index.
            right.Accept(this, right.TypeVariable!);

            var cbElement = tvAccess.DataType.Size;
            var tvElement = ArrayField(basePointer, left, left.DataType.BitSize, 0, cbElement, 0, tvAccess);
            var dtArray = factory.CreateArrayType(tvElement, 0);

            var tvArray = store.CreateTypeVariable(factory);
            tvArray.DataType = dtArray;
            tvArray.OriginalDataType = dtArray;

            StructField(basePointer, left, 0, dtArray, eaBitSize);

            if (!(left is Identifier))
            {
                VisitMemoryAccess(basePointer, tvArray, left, globals);
            }
        }

        /// <summary>
        /// Returns true if the <paramref name="effectiveAddress"/> is an addition
        /// with an integral right-hand-side.
        /// </summary>
        private bool IsArrayAccess(Expression effectiveAddress)
        {
            if (!(effectiveAddress is BinaryExpression binEa) ||
                binEa.Operator != Operator.IAdd)
                return false;
            if (!(binEa.Right.TypeVariable!.DataType is PrimitiveType ptRight) ||
                !ptRight.IsIntegral)
                return false;
            return true;
        }

        public LinearInductionVariable? GetInductionVariable(Expression e)
		{
			if (!(e is Identifier id))
                return null;
            if (!ivs.TryGetValue(id, out var iv))
                return null;
            return iv;
		}

        /// <summary>
        /// Handle an expression of type 'id + offset', where id is a LinearInductionVariable.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="iv"></param>
        /// <param name="offset"></param>
        public void VisitInductionVariable(Expression eBase, Identifier id, LinearInductionVariable iv, int offset, TypeVariable tvField)
        {
            int delta = iv.Delta!.ToInt32();
            var stride = Math.Abs(delta);
            int init;
            if (delta < 0)
            {
                // induction variable is decremented, so the actual array begins at ivFinal - delta.
                if (iv.Final != null)
                {
                    init = iv.Final.ToInt32() - delta;
                    if (iv.IsSigned)
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                    else
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                }
            }
            else
            {
                if (iv.Initial != null)
                {
                    init = iv.Initial.ToInt32();
                    if (iv.IsSigned)
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                    else
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                }
            }
            if (iv.IsSigned)
            {
                if (offset != 0)
                {
                    SetSize(eBase, id, stride);
                    StructField(eBase, id, offset, tvField.DataType, platform.PointerType.BitSize);
                }
            }
            else
            {
                SetSize(eBase, id, stride);
                StructField(eBase, id, offset, tvField.DataType, platform.PointerType.BitSize);
            }
        }

        public DataType SetSize(Expression eBase, Expression tStruct, int size)
        {
            if (size <= 0)
                throw new ArgumentOutOfRangeException("size must be positive");
            var s = factory.CreateStructureType(null, size);
            var ptr = eBase != null && eBase != globals
                ? (DataType) factory.CreateMemberPointer(eBase.TypeVariable!, s, platform.FramePointerType.BitSize)
                : (DataType) factory.CreatePointer(s, platform.PointerType.BitSize);
            return MeetDataType(tStruct, ptr);
        }

        private int OffsetOf(Constant c)
        {
            if (c.DataType is PrimitiveType pt &&
                (pt.Domain & Domain.Integer) == Domain.SignedInt)
                return c.ToInt32();
            else
                return (int) c.ToUInt32();
        }

        private Pointer PointerTo(DataType dt)
        {
            return new Pointer(dt, platform.PointerType.BitSize);
        }

        private MemberPointer MemberPointerTo(DataType baseType, DataType fieldType, int bitSize)
        {
            return new MemberPointer(baseType, fieldType, bitSize);
        }

        private DataType DataTypeOf(Expression e)
        {
             return e.TypeVariable!.DataType;
        }

        private bool IsSelector(Expression e)
        {
            return
                DataTypeOf(e) is PrimitiveType pt &&
                pt.Domain == Domain.Selector;
        }


        public bool VisitMkSequence(MkSequence seq, TypeVariable tv)
        {
            if (seq.Expressions.Length == 2 && tv.DataType.IsPointer)
            {
                if (IsSelector(seq.Expressions[0]) || DataTypeOf(seq.Expressions[0]) is Pointer)
                {
                    var seg = seq.Expressions[0];
                    var off = seq.Expressions[1];
                    MeetDataType(seg, new Pointer(new StructureType { IsSegment = true }, DataTypeOf(seg).BitSize));
                    if (DataTypeOf(seq) is Pointer ptr)
                    {
                        MeetDataType(off, MemberPointerTo(seg.TypeVariable!, ptr.Pointee, DataTypeOf(off).BitSize));
                    }
                    seg.Accept(this, seg.TypeVariable!);
                    off.Accept(this, off.TypeVariable!);
                    return false;
                }
            }
            if (tv.DataType is PrimitiveType pt && pt.IsIntegral)
            {
                MeetDataType(seq.Expressions[0], PrimitiveType.Create(pt.Domain, seq.Expressions[0].DataType.BitSize));
                foreach (var e in seq.Expressions.Skip(1))
                {
                    MeetDataType(e, PrimitiveType.Create(Domain.UnsignedInt, e.DataType.BitSize));
                }
            }
            foreach (var e in seq.Expressions)
            {
                e.Accept(this, e.TypeVariable!);
            }
            return false;
        }

        private bool NYI(Expression e, TypeVariable tv)
        {
            throw new NotImplementedException(string.Format("Haven't implemented pushing {0} ({1}) into {2} yet.", tv, tv.DataType, e));
        }

        public bool VisitOutArgument(OutArgument outArgument, TypeVariable tv)
        {
            outArgument.Expression.Accept(this, outArgument.Expression.TypeVariable!);
            return false;
        }

        public bool VisitPhiFunction(PhiFunction phi, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitPointerAddition(PointerAddition pa, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitProcedureConstant(ProcedureConstant pc, TypeVariable tv)
        {
            //throw new NotImplementedException();
            return false;
        }

        public bool VisitScopeResolution(ScopeResolution scopeResolution, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitSegmentedAccess(SegmentedAccess access, TypeVariable tv)
        {
            var seg = factory.CreateStructureType(null, 0);
            seg.IsSegment = true;
            MeetDataType(access.BasePointer, factory.CreatePointer(seg, access.BasePointer.DataType.BitSize));
            access.BasePointer.Accept(this, access.BasePointer.TypeVariable!);

            return VisitMemoryAccess(access.BasePointer, access.TypeVariable!, access.EffectiveAddress, access.BasePointer);
        }

        public bool VisitSlice(Slice slice, TypeVariable tv)
        {
            slice.Expression.Accept(this, slice.Expression.TypeVariable!);
            return false;
        }

        public bool VisitTestCondition(TestCondition tc, TypeVariable tv)
        {
            MeetDataType(tc, tc.DataType);
            tc.Expression.Accept(this, tc.Expression.TypeVariable!);
            return false;
        }

        public bool VisitUnaryExpression(UnaryExpression unary, TypeVariable tv)
        {
            unary.Expression.Accept(this, unary.Expression.TypeVariable!);
            return false;
        }
    }
}

---- Transformed Tree ----
using Reko.Analysis;
using Reko.Core;
using Reko.Core.Code;
using Reko.Core.Expressions;
using Reko.Core.Operators;
using Reko.Core.Types;
using Reko.Scanning;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Reko.Typing
{
    /// <summary>
    /// Pushes type information down from the root of an expression to its leaves.
    /// </summary>
    /// <remarks>
    ///    root
    ///   /  \ 
    /// leaf  leaf
    /// </remarks>
    public class ExpressionTypeDescender : ExpressionVisitor<bool, TypeVariable>
    {
        // Matches the effective address of Mem[p + c] where c is a constant.
        private static readonly ExpressionMatcher fieldAccessPattern = new ExpressionMatcher(
            new BinaryExpression(
                Operator.IAdd,
                ExpressionMatcher.AnyDataType(null),
                ExpressionMatcher.AnyExpression("p"),
                ExpressionMatcher.AnyConstant("c")));
        private static readonly ExpressionMatcher segFieldAccessPattern = new ExpressionMatcher(
            new MkSequence(
                ExpressionMatcher.AnyDataType(null),
                ExpressionMatcher.AnyExpression("p"),
                ExpressionMatcher.AnyConstant("c")));

        private readonly IPlatform platform;
        private readonly TypeStore store;
        private readonly TypeFactory factory;
        private readonly Unifier unifier;
        private readonly Identifier globals;
        private readonly Dictionary<Identifier,LinearInductionVariable> ivs;

        public ExpressionTypeDescender(Program program, TypeStore store, TypeFactory factory)
        {
            this.platform = program.Platform;
            this.globals = program.Globals;
            this.ivs = program.InductionVariables;
            this.store = store;
            this.factory = factory;
            this.unifier = new DataTypeBuilderUnifier(factory, store);
        }

        public bool VisitAddress(Address addr, TypeVariable tv)
        {
            MeetDataType(addr, tv.DataType);
            return false;
        }

        public bool VisitApplication(Application appl, TypeVariable tv)
        {
            MeetDataType(appl, appl.TypeVariable!.DataType);

            appl.Procedure.Accept(this, appl.Procedure.TypeVariable!);
            TypeVariable[] paramTypes = new TypeVariable[appl.Arguments.Length];
            for (int i = 0; i < appl.Arguments.Length; ++i)
            {
                appl.Arguments[i].Accept(this, appl.Arguments[i].TypeVariable!);
                paramTypes[i] = appl.Arguments[i].TypeVariable!;
            }
            FunctionTrait(appl.Procedure, appl.Procedure.DataType.BitSize, appl.TypeVariable!, paramTypes);
            BindActualTypesToFormalTypes(appl);
            return false;
        }

        private FunctionType? MatchFunctionPointer(DataType dt)
        {
            if (dt is Pointer ptr)
                return ptr.Pointee as FunctionType;
            else
                return null;
        }

        private FunctionType? ExtractSignature(Expression proc)
        {
            if (proc is ProcedureConstant pc)
                return pc.Procedure.Signature;
            return MatchFunctionPointer(proc.TypeVariable!.DataType);
        }

        private void BindActualTypesToFormalTypes(Application appl)
        {
            var sig = ExtractSignature(appl.Procedure);
            if (sig == null)
                return;
            var parameters = sig.Parameters!;
            if (!sig.IsVariadic && appl.Arguments.Length != parameters.Length)
                throw new InvalidOperationException(
                    string.Format("Call to {0} had {1} arguments instead of the expected {2}.",
                    appl.Procedure, appl.Arguments.Length, parameters.Length));
            for (int i = 0; i < appl.Arguments.Length; ++i)
            {
                if (!sig.IsVariadic || i < parameters.Length)
                {
                    MeetDataType(appl.Arguments[i], parameters[i].DataType);
                    parameters[i].Accept(this, parameters[i].TypeVariable!);
                }
            }
        }

        public void FunctionTrait(Expression function, int funcPtrBitSize, TypeVariable ret, params TypeVariable[] actuals)
        {
            if (function is ProcedureConstant pc &&
                pc.Procedure is ExternalProcedure ep &&
                ep.Characteristics != null &&
                ep.Characteristics.Allocator)
            {
                // Allocation sites mustn't be tied to other allocation sites. Don't mutate
                // the existing signature. 
                //$TODO: In fact, no user- or environment-provided function types should
                // ever merge new FunctionTypes into the existing signature; the existing 
                // signature should be treated as correct.
                return;
            }

            Identifier[] parameters = actuals
                .Select(a => new Identifier("", a, null!))
                .ToArray();
            var fn = factory.CreateFunctionType(
                new Identifier("", ret, null!),
                parameters);
            var pfn = factory.CreatePointer(fn, funcPtrBitSize);
            MeetDataType(function, pfn);
        }

        public bool VisitArrayAccess(ArrayAccess acc, TypeVariable tv)
        {
            MeetDataType(acc, acc.DataType);
            Expression arr;
            int offset;
            if (fieldAccessPattern.Match(acc.Array))
            {
                arr = fieldAccessPattern.CapturedExpression("p")!;
                offset = OffsetOf((Constant)fieldAccessPattern.CapturedExpression("c")!);
            }
            else if (segFieldAccessPattern.Match(acc.Array))
            {
                arr = segFieldAccessPattern.CapturedExpression("p")!;
                offset = OffsetOf((Constant)segFieldAccessPattern.CapturedExpression("c")!);
            }
            else
            {
                arr = acc.Array;
                offset = 0;
            }
            int stride = 1;
            if (acc.Index is BinaryExpression bIndex && (bIndex.Operator == Operator.IMul || bIndex.Operator == Operator.SMul || bIndex.Operator == Operator.UMul))
            {
                if (bIndex.Right is Constant c)
                {
                    stride = c.ToInt32();
                }
            }
            var tvElement = ArrayField(null, arr, arr.DataType.BitSize, offset, stride, 0, acc.TypeVariable!);

            MeetDataType(acc.Array, factory.CreatePointer(tvElement, acc.Array.DataType.BitSize));
            acc.Array.Accept(this, acc.Array.TypeVariable!);
            acc.Index.Accept(this, acc.Index.TypeVariable!);
            return false;
        }

        /// <summary>
        /// Assert that there is an array field at offset <paramref name="offset"/>
        /// of the structure pointed at by <paramref name="expStruct"/>.
        /// </summary>
        /// <param name="expBase"></param>
        /// <param name="expStruct"></param>
        /// <param name="structPtrSize"></param>
        /// <param name="offset"></param>
        /// <param name="elementSize"></param>
        /// <param name="length"></param>
        /// <param name="tvField"></param>
        /// <returns>A type variable for the array type of the field.</returns>
        private TypeVariable ArrayField(Expression? expBase, Expression expStruct, int structPtrBitSize, int offset, int elementSize, int length, TypeVariable tvField)
        {
            var dtElement = factory.CreateStructureType(null, elementSize);
            dtElement.Fields.Add(0, tvField);
            var tvElement = store.CreateTypeVariable(factory);
            tvElement.DataType = dtElement;
            tvElement.OriginalDataType = dtElement;
            StructField(expBase, expStruct, offset, factory.CreateArrayType(tvElement, length), structPtrBitSize);
            return tvElement;
        }

        /// <summary>
        /// Assert that there is a structure field at offset <paramref name="offset" />
        /// of <paramref name="eStructPtr"/>, which is treated as a pointer to the struct.
        /// </summary>
        /// <param name="eBase">Optional base pointer used in segmented addressing.</param>
        /// <param name="eStructPtr">Expression that is a pointer to a structure.</param>
        /// <param name="offset">An offset within that structure.</param>
        /// <param name="dtField">The data type of the field being accessed.</param>
        /// <param name="structPtrBitSize">Side of eStructPtr in bits.</param>
        /// <returns>The union of <paramref name="eStructPtr" /> with a pointer to a structure
        /// containing a field at offset <paramref name="offset" />.
        /// </returns>
        public DataType StructField(Expression? eBase, Expression eStructPtr, int offset, DataType dtField, int structPtrBitSize)
        {
            var s = factory.CreateStructureType(null, 0);
            var field = new StructureField(offset, dtField);
            s.Fields.Add(field);

            var pointer = eBase != null && eBase != globals
                ? (DataType)factory.CreateMemberPointer(eBase.TypeVariable!, s, structPtrBitSize)
                : (DataType)factory.CreatePointer(s, structPtrBitSize);
            return MeetDataType(eStructPtr, pointer);
        }

        public bool VisitBinaryExpression(BinaryExpression binExp, TypeVariable tv)
        {
            var eLeft = binExp.Left;
            var eRight= binExp.Right;
            if (binExp.Operator == Operator.IAdd)
            {
                var dt = PushAddendDataType(binExp.TypeVariable!.DataType, eRight.TypeVariable!.DataType);
                if (dt != null)
                    MeetDataType(eLeft, dt);
                dt = PushAddendDataType(binExp.TypeVariable!.DataType, eLeft.TypeVariable!.DataType);
                if (dt != null)
                    MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.ISub)
            {
                var dt = PushMinuendDataType(binExp.TypeVariable!.DataType, eRight.TypeVariable!.DataType);
                MeetDataType(eLeft, dt);
                dt = PushSubtrahendDataType(binExp.TypeVariable!.DataType, eLeft.TypeVariable!.DataType);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.And || binExp.Operator == Operator.Or)
            {
                //$REVIEW: need a push-logical-Data type to push [[a & 3]] = char into its left and right halves.
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.Integer | Domain.Character);
                MeetDataType(eLeft, dt);
                MeetDataType(eRight, dt);
            }
            else if (
                binExp.Operator == Operator.IMul ||
                binExp.Operator == Operator.IMod)
            {
                var dt = PrimitiveType.CreateWord(DataTypeOf(eLeft).BitSize).MaskDomain(Domain.Boolean | Domain.Integer );
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(DataTypeOf(eRight).BitSize).MaskDomain(Domain.Boolean | Domain.Integer);
                MeetDataType(eRight, dt);
            }
            else if (
                binExp.Operator == Operator.SMul ||
                binExp.Operator == Operator.SDiv)
            {
                var dt = PrimitiveType.CreateWord(DataTypeOf(eLeft).BitSize).MaskDomain(Domain.Boolean | Domain.SignedInt);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(DataTypeOf(eRight).BitSize).MaskDomain(Domain.Boolean | Domain.SignedInt);
                MeetDataType(eRight, dt);
            }
            else if (
                binExp.Operator == Operator.UMul ||
                binExp.Operator == Operator.UDiv)
            {
                var dt = PrimitiveType.CreateWord(DataTypeOf(eLeft).BitSize).MaskDomain(Domain.Boolean | Domain.UnsignedInt);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(DataTypeOf(eRight).BitSize).MaskDomain(Domain.Boolean | Domain.UnsignedInt);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.FAdd ||
                    binExp.Operator == Operator.FSub ||
                    binExp.Operator == Operator.FMul ||
                    binExp.Operator == Operator.FDiv)
            {
                var dt = PrimitiveType.Create(Domain.Real, eLeft.DataType.BitSize);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Real, eRight.DataType.BitSize);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator is SignedIntOperator)
            {
                var dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.SignedInt | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.SignedInt | Domain.Character);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator is UnsignedIntOperator)
            {
                var dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.Pointer| Domain.UnsignedInt | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.CreateWord(eRight.TypeVariable!.DataType.BitSize).MaskDomain(Domain.Pointer | Domain.UnsignedInt|Domain.Character);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.Eq || binExp.Operator == Operator.Ne||
                binExp.Operator == Operator.Xor || binExp.Operator == Operator.Cand ||
                binExp.Operator == Operator.Cor)
            {
                // Not much can be deduced here, except that the operands should have the same size. Earlier passes
                // already did that work, so just continue with the operands.
            } 
            else if (binExp.Operator is RealConditionalOperator)
            {
                // We know leaves must be floats
                var dt = PrimitiveType.Create(Domain.Real, eLeft.DataType.BitSize);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Real, eLeft.DataType.BitSize);
                MeetDataType(eRight, dt);
            }
            else if (binExp.Operator == Operator.Shl)
            {
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.Integer | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Integer, DataTypeOf(eRight).BitSize);
            }
            else if (binExp.Operator == Operator.Shr)
            {
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.UnsignedInt| Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Integer, DataTypeOf(eRight).BitSize);
            }
            else if (binExp.Operator == Operator.Sar)
            {
                var dt = PrimitiveType.CreateWord(tv.DataType.BitSize).MaskDomain(Domain.Boolean | Domain.SignedInt | Domain.Character);
                MeetDataType(eLeft, dt);
                dt = PrimitiveType.Create(Domain.Integer, DataTypeOf(eRight).BitSize);
            }
            else
                throw new TypeInferenceException($"Unhandled binary operator {binExp.Operator} in expression {binExp}.");
            eLeft.Accept(this, eLeft.TypeVariable!);
            eRight.Accept(this, eRight.TypeVariable!);
            return false;
        }

        private DataType? PushAddendDataType(DataType dtSum, DataType dtOther)
        {
            if (dtSum is PrimitiveType ptSum && ptSum.Domain == Domain.Pointer || dtSum is Pointer)
            {
                if (dtOther is PrimitiveType ptOther && ptOther.Domain == Domain.Pointer || dtOther is Pointer)
                {
                    return PrimitiveType.Create(Domain.SignedInt, dtSum.BitSize);
                }

                if (dtOther is PrimitiveType ptOther && (ptOther.Domain & Domain.Integer) != 0)
                {
                    return PrimitiveType.Create(Domain.Pointer, dtSum.BitSize);
                }
            }
            if (dtSum is MemberPointer mpSum)
            {
                if (dtOther is MemberPointer)
                    return PrimitiveType.Create(Domain.SignedInt, dtOther.BitSize);

                if (dtOther is PrimitiveType ptOther && (ptOther.Domain & Domain.Integer) != 0)
                {
                    return factory.CreateMemberPointer(mpSum.BasePointer, factory.CreateUnknown(), mpSum.BitSize);
                }
            }

            if (dtSum is PrimitiveType ptSum && ptSum.IsIntegral)
            {
                // With integral types, type information flows only from leaves
                // to root.
                return null;
            }
            if (dtSum is PrimitiveType ptSum && ptSum.Domain == Domain.Pointer || dtSum is Pointer)
            {
                return PrimitiveType.Create(Domain.SignedInt, dtSum.BitSize);
            }
            return dtSum;
        }

        private DataType PushMinuendDataType(DataType dtDiff, DataType dtSub)
        {
            var ptSub = dtSub.ResolveAs<PrimitiveType>();
            if (dtDiff is Pointer || dtDiff is PrimitiveType ptDiff && ptDiff.Domain == Domain.Pointer)
            {
                if (ptSub != null && (ptSub.Domain & Domain.Integer) != 0)
                    return PrimitiveType.Create(Domain.Pointer, dtDiff.BitSize);
                throw new TypeInferenceException($"Not handling {dtDiff} and {dtSub} yet.");
            }
            if (dtDiff is MemberPointer || dtDiff is PrimitiveType ptDiff && ptDiff.Domain == Domain.Offset)
            {
                if (ptSub != null && (ptSub.Domain & Domain.Integer) != 0)
                    return dtDiff;
                throw new TypeInferenceException($"Not handling {dtDiff} and {dtSub} yet.");
            }
            return dtDiff;
        }

        private DataType PushSubtrahendDataType(DataType dtDiff, DataType dtMin)
        {
            if (dtDiff is Pointer || dtDiff is PrimitiveType ptDiff && ptDiff.Domain == Domain.Pointer)
            {
                if (dtMin is Pointer || dtMin is PrimitiveType ptMin && ptMin.Domain == Domain.Pointer)
                    return PrimitiveType.Create(Domain.Integer, dtDiff.BitSize);
                throw new TypeInferenceException(string.Format("Not handling {0} and {1} yet", dtDiff, dtMin));
            }
            if (dtDiff is MemberPointer || dtDiff is PrimitiveType ptDiff && ptDiff.Domain == Domain.Offset)
            {
                if (dtMin is MemberPointer || dtMin is PrimitiveType ptMin && ptMin.Domain == Domain.Offset)
                    return PrimitiveType.Create(Domain.Integer, dtDiff.BitSize);
                throw new TypeInferenceException(string.Format("Not handling {0} and {1} yet", dtDiff, dtMin));
            }
            return dtMin;
        }

        public DataType MeetDataType(Expression exp, DataType dt)
        {
            if (exp is Conversion || exp is Cast)
                return exp.TypeVariable!.DataType;
            return MeetDataType(exp.TypeVariable!, dt);
        }

        public DataType MeetDataType(TypeVariable tvExp, DataType dt)
        { 
            if (dt == PrimitiveType.SegmentSelector)
            {
                var seg = factory.CreateStructureType(null, 0);
                seg.IsSegment = true;
                var ptr = factory.CreatePointer(seg, dt.BitSize);
                dt = ptr;
            } 
            tvExp.DataType = unifier.Unify(tvExp.DataType, dt)!;
            tvExp.OriginalDataType = unifier.Unify(tvExp.OriginalDataType, dt)!;
            return tvExp.DataType;
        }

        public bool VisitCast(Cast cast, TypeVariable? tv)
        {
            MeetDataType(cast, cast.DataType);
            cast.Expression.Accept(this, cast.Expression.TypeVariable!);
            return false;
        }

        public bool VisitConditionalExpression(ConditionalExpression c, TypeVariable tv)
        {
            MeetDataType(c.Condition, PrimitiveType.Bool);
            c.Condition.Accept(this, c.Condition.TypeVariable!);
            c.ThenExp.Accept(this, c.TypeVariable!);
            c.FalseExp.Accept(this, c.TypeVariable!);
            return false;
        }

        public bool VisitConditionOf(ConditionOf cof, TypeVariable tv)
        {
            MeetDataType(cof, cof.DataType);
            cof.Expression.Accept(this, cof.Expression.TypeVariable!);
            return false;
        }

        public bool VisitConstant(Constant c, TypeVariable tv)
        {
            MeetDataType(c, tv.DataType);
            if (c.DataType == PrimitiveType.SegmentSelector)
            {
                //$TODO: instead of pushing it into globals, it should 
                // allocate special types for each segment. This can be 
                // done at load time.
                StructField(
                    null,
                    globals, 
                    c.ToInt32() * 0x10,   //$REVIEW Platform-dependent: only valid for x86 real mode.
                    c.TypeVariable!,
                    platform.PointerType.BitSize);
            }
            return false;
        }

        public bool VisitConversion(Conversion conversion, TypeVariable tv)
        {
     //       MeetDataType(conversion, conversion.DataType);
            MeetDataType(conversion.Expression, conversion.SourceDataType);
            conversion.Expression.Accept(this, conversion.Expression.TypeVariable!);
            return false;
        }

        public bool VisitDereference(Dereference deref, TypeVariable tv)
        {
            //$BUG: push (ptr (typeof(deref)
            deref.Expression.Accept(this, deref.Expression.TypeVariable!);
            return false;
        }

        public bool VisitFieldAccess(FieldAccess acc, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitIdentifier(Identifier id, TypeVariable tv)
        {
            return false;
        }

        public bool VisitMemberPointerSelector(MemberPointerSelector mps, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitMemoryAccess(MemoryAccess access, TypeVariable tv)
        {
            return VisitMemoryAccess(null, access.TypeVariable!, access.EffectiveAddress, globals);
        }

        private bool VisitMemoryAccess(Expression? basePointer, TypeVariable tvAccess, Expression effectiveAddress, Expression globals)
        {
            MeetDataType(tvAccess, tvAccess.DataType);
            int eaBitSize = effectiveAddress.TypeVariable!.DataType.BitSize;
            Expression p;
            int offset;
            if (fieldAccessPattern.Match(effectiveAddress))
            {
                // Mem[p + c]
                p = fieldAccessPattern.CapturedExpression("p")!;
                var c = ToConstant(fieldAccessPattern.CapturedExpression("c")!)!;
                offset = OffsetOf(c);
                if (p is Conversion cvt && cvt.SourceDataType.BitSize < cvt.DataType.BitSize)
                {
                    // p some convert-extended thing and cannot be a pointer; c therefore must be treated as a
                    // pointer and p is the index.
                    // First do the array index.
                    p.Accept(this, p.TypeVariable!);

                    // Now treat c as an array pointer.
                    var cbElement = tvAccess.DataType.Size;
                    var tvElement = ArrayField(basePointer, c, c.DataType.BitSize, 0, cbElement, 0, tvAccess);
                    StructField(basePointer, c, 0, tvElement, eaBitSize);
                    return false;
                }
                else if (p is Cast cast && cast.Expression.DataType.BitSize < cast.DataType.BitSize)
                {
                    p.Accept(this, p.TypeVariable!);

                    var cbElement = tvAccess.DataType.Size;
                    var tvElement = ArrayField(basePointer, c, c.DataType.BitSize, 0, cbElement, 0, tvAccess);
                    StructField(basePointer, c, 0, tvElement, eaBitSize);
                    return false;
                }
                else
                {
                    var iv = GetInductionVariable(p);
                    if (iv != null)
                    {
                        VisitInductionVariable(globals, (Identifier) p, iv, offset, tvAccess);
                    }
                    StructField(basePointer, p, offset, tvAccess, eaBitSize);
                }
            }
            else if (effectiveAddress is Constant c)
            {
                // Mem[c]
                p = effectiveAddress;
                offset = 0;
                //$BUG: offsets should be long for 64-bit architectures.
                StructField(null, globals, OffsetOf(c), tvAccess, eaBitSize);
            }
            else if (effectiveAddress is Address addr && !addr.Selector.HasValue)
            {
                // Mem[addr]
                //$TODO: what to do about segmented addresses?
                p = effectiveAddress;
                offset = 0;
                //$BUG: offsets should be long for 64-bit architectures.
                StructField(null, globals, (int) addr.ToLinear(), tvAccess, eaBitSize);
            }
            else if (IsArrayAccess(effectiveAddress))
            {
                // Mem[p + i] where i is integer type.
                var binEa = (BinaryExpression) effectiveAddress;
                VisitPossibleArrayAccess(basePointer, tvAccess, binEa.Left, binEa.Right, globals, eaBitSize);
                StructField(basePointer, effectiveAddress, 0, tvAccess, eaBitSize);
                effectiveAddress.Accept(this, effectiveAddress.TypeVariable!);
                return false;
            }
            else
            {
                // Mem[anything]
                p = effectiveAddress;
                offset = 0;
            }
            StructField(basePointer, p, offset, tvAccess, eaBitSize);
            p.Accept(this, p.TypeVariable!);
            return false;
        }

        private Constant? ToConstant(Expression expression)
        {
            if (expression is Constant c)
                return c;
            if (expression is Address addr)
                return addr.ToConstant();
            return null;
        }

        private void VisitPossibleArrayAccess(Expression? basePointer, TypeVariable tvAccess, Expression left, Expression right, Expression globals, int eaBitSize)
        {

            // First do the array index.
            right.Accept(this, right.TypeVariable!);

            var cbElement = tvAccess.DataType.Size;
            var tvElement = ArrayField(basePointer, left, left.DataType.BitSize, 0, cbElement, 0, tvAccess);
            var dtArray = factory.CreateArrayType(tvElement, 0);

            var tvArray = store.CreateTypeVariable(factory);
            tvArray.DataType = dtArray;
            tvArray.OriginalDataType = dtArray;

            StructField(basePointer, left, 0, dtArray, eaBitSize);

            if (!(left is Identifier))
            {
                VisitMemoryAccess(basePointer, tvArray, left, globals);
            }
        }

        /// <summary>
        /// Returns true if the <paramref name="effectiveAddress"/> is an addition
        /// with an integral right-hand-side.
        /// </summary>
        private bool IsArrayAccess(Expression effectiveAddress)
        {
            if (!(effectiveAddress is BinaryExpression binEa) ||
                binEa.Operator != Operator.IAdd)
                return false;
            if (!(binEa.Right.TypeVariable!.DataType is PrimitiveType ptRight) ||
                !ptRight.IsIntegral)
                return false;
            return true;
        }

        public LinearInductionVariable? GetInductionVariable(Expression e)
		{
			if (!(e is Identifier id))
                return null;
            if (!ivs.TryGetValue(id, out var iv))
                return null;
            return iv;
		}

        /// <summary>
        /// Handle an expression of type 'id + offset', where id is a LinearInductionVariable.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="iv"></param>
        /// <param name="offset"></param>
        public void VisitInductionVariable(Expression eBase, Identifier id, LinearInductionVariable iv, int offset, TypeVariable tvField)
        {
            int delta = iv.Delta!.ToInt32();
            var stride = Math.Abs(delta);
            int init;
            if (delta < 0)
            {
                // induction variable is decremented, so the actual array begins at ivFinal - delta.
                if (iv.Final != null)
                {
                    init = iv.Final.ToInt32() - delta;
                    if (iv.IsSigned)
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                    else
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                }
            }
            else
            {
                if (iv.Initial != null)
                {
                    init = iv.Initial.ToInt32();
                    if (iv.IsSigned)
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                    else
                    {
                        ArrayField(null, eBase, id.DataType.BitSize, init + offset, stride, iv.IterationCount, tvField);
                    }
                }
            }
            if (iv.IsSigned)
            {
                if (offset != 0)
                {
                    SetSize(eBase, id, stride);
                    StructField(eBase, id, offset, tvField.DataType, platform.PointerType.BitSize);
                }
            }
            else
            {
                SetSize(eBase, id, stride);
                StructField(eBase, id, offset, tvField.DataType, platform.PointerType.BitSize);
            }
        }

        public DataType SetSize(Expression eBase, Expression tStruct, int size)
        {
            if (size <= 0)
                throw new ArgumentOutOfRangeException("size must be positive");
            var s = factory.CreateStructureType(null, size);
            var ptr = eBase != null && eBase != globals
                ? (DataType) factory.CreateMemberPointer(eBase.TypeVariable!, s, platform.FramePointerType.BitSize)
                : (DataType) factory.CreatePointer(s, platform.PointerType.BitSize);
            return MeetDataType(tStruct, ptr);
        }

        private int OffsetOf(Constant c)
        {
            if (c.DataType is PrimitiveType pt &&
                (pt.Domain & Domain.Integer) == Domain.SignedInt)
                return c.ToInt32();
            else
                return (int) c.ToUInt32();
        }

        private Pointer PointerTo(DataType dt)
        {
            return new Pointer(dt, platform.PointerType.BitSize);
        }

        private MemberPointer MemberPointerTo(DataType baseType, DataType fieldType, int bitSize)
        {
            return new MemberPointer(baseType, fieldType, bitSize);
        }

        private DataType DataTypeOf(Expression e)
        {
             return e.TypeVariable!.DataType;
        }

        private bool IsSelector(Expression e)
        {
            return
                DataTypeOf(e) is PrimitiveType pt &&
                pt.Domain == Domain.Selector;
        }


        public bool VisitMkSequence(MkSequence seq, TypeVariable tv)
        {
            if (seq.Expressions.Length == 2 && tv.DataType.IsPointer)
            {
                if (IsSelector(seq.Expressions[0]) || DataTypeOf(seq.Expressions[0]) is Pointer)
                {
                    var seg = seq.Expressions[0];
                    var off = seq.Expressions[1];
                    MeetDataType(seg, new Pointer(new StructureType { IsSegment = true }, DataTypeOf(seg).BitSize));
                    if (DataTypeOf(seq) is Pointer ptr)
                    {
                        MeetDataType(off, MemberPointerTo(seg.TypeVariable!, ptr.Pointee, DataTypeOf(off).BitSize));
                    }
                    seg.Accept(this, seg.TypeVariable!);
                    off.Accept(this, off.TypeVariable!);
                    return false;
                }
            }
            if (tv.DataType is PrimitiveType pt && pt.IsIntegral)
            {
                MeetDataType(seq.Expressions[0], PrimitiveType.Create(pt.Domain, seq.Expressions[0].DataType.BitSize));
                foreach (var e in seq.Expressions.Skip(1))
                {
                    MeetDataType(e, PrimitiveType.Create(Domain.UnsignedInt, e.DataType.BitSize));
                }
            }
            foreach (var e in seq.Expressions)
            {
                e.Accept(this, e.TypeVariable!);
            }
            return false;
        }

        private bool NYI(Expression e, TypeVariable tv)
        {
            throw new NotImplementedException(string.Format("Haven't implemented pushing {0} ({1}) into {2} yet.", tv, tv.DataType, e));
        }

        public bool VisitOutArgument(OutArgument outArgument, TypeVariable tv)
        {
            outArgument.Expression.Accept(this, outArgument.Expression.TypeVariable!);
            return false;
        }

        public bool VisitPhiFunction(PhiFunction phi, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitPointerAddition(PointerAddition pa, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitProcedureConstant(ProcedureConstant pc, TypeVariable tv)
        {
            //throw new NotImplementedException();
            return false;
        }

        public bool VisitScopeResolution(ScopeResolution scopeResolution, TypeVariable tv)
        {
            throw new NotImplementedException();
        }

        public bool VisitSegmentedAccess(SegmentedAccess access, TypeVariable tv)
        {
            var seg = factory.CreateStructureType(null, 0);
            seg.IsSegment = true;
            MeetDataType(access.BasePointer, factory.CreatePointer(seg, access.BasePointer.DataType.BitSize));
            access.BasePointer.Accept(this, access.BasePointer.TypeVariable!);

            return VisitMemoryAccess(access.BasePointer, access.TypeVariable!, access.EffectiveAddress, access.BasePointer);
        }

        public bool VisitSlice(Slice slice, TypeVariable tv)
        {
            slice.Expression.Accept(this, slice.Expression.TypeVariable!);
            return false;
        }

        public bool VisitTestCondition(TestCondition tc, TypeVariable tv)
        {
            MeetDataType(tc, tc.DataType);
            tc.Expression.Accept(this, tc.Expression.TypeVariable!);
            return false;
        }

        public bool VisitUnaryExpression(UnaryExpression unary, TypeVariable tv)
        {
            unary.Expression.Accept(this, unary.Expression.TypeVariable!);
            return false;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(27,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(21,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(367,46): error CS0128: A local variable or function named 'ptOther' is already defined in this scope,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(383,40): error CS0128: A local variable or function named 'ptSum' is already defined in this scope,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(389,40): error CS0128: A local variable or function named 'ptSum' is already defined in this scope,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(367,58): error CS0165: Use of unassigned local variable 'ptOther',D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(383,49): error CS0165: Use of unassigned local variable 'ptSum',D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(405,68): error CS0128: A local variable or function named 'ptDiff' is already defined in this scope,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(405,78): error CS0165: Use of unassigned local variable 'ptDiff',D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(422,68): error CS0128: A local variable or function named 'ptDiff' is already defined in this scope,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(422,78): error CS0165: Use of unassigned local variable 'ptDiff',D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Decompiler\Typing\ExpressionTypeDescender.cs(27,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core;
using Reko.Core.Expressions;
using Reko.Core.Machine;
using Reko.Core.Operators;
using Reko.Core.Rtl;
using Reko.Core.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Reko.Arch.PowerPC
{
    public partial class PowerPcRewriter
    {
        private void RewriteB()
        {
            var dst = RewriteOperand(instr.Operands[0]);
            m.Goto(dst);
        }

        private void RewriteBc(bool linkRegister)
        {
            throw new NotImplementedException();
        }

        private void RewriteBcctr(bool linkRegister)
        {
            RewriteBranch(linkRegister, binder.EnsureRegister(arch.ctr));
        }

        private void RewriteBl()
        {
            var dst = RewriteOperand(instr.Operands[0]);
            var addrDst = dst as Address;
            if (addrDst != null && instr.Address.ToLinear() + 4 == addrDst.ToLinear())
            {
                // PowerPC idiom to get the current instruction pointer in the lr register
                iclass = InstrClass.Linear;
                m.Assign(binder.EnsureRegister(arch.lr), addrDst);
            }
            else
            {
                m.Call(dst, 0);
            }
        }

        private void RewriteBlr()
        {
            m.Return(0, 0);
        }

        private void RewriteBranch(bool updateLinkregister, bool toLinkRegister, ConditionCode cc)
        {
            Expression cr;
            var ccrOp = instr.Operands[0] as RegisterOperand;
            if (ccrOp != null)
            {
                cr = RewriteOperand(instr.Operands[0]);
            }
            else 
            {
                cr = binder.EnsureFlagGroup(arch.GetCcFieldAsFlagGroup(arch.CrRegisters[0])!);
            }
            if (toLinkRegister)
            {
                m.BranchInMiddleOfInstruction(
                    m.Test(cc, cr).Invert(),
                    instr.Address + instr.Length,
                    InstrClass.ConditionalTransfer);
                var dst = binder.EnsureRegister(arch.lr);
                if (updateLinkregister)
                {
                    m.Call(dst, 0);
                }
                else
                {
                    m.Return(0, 0);
                }
            }
            else
            {
                var dst = RewriteOperand(ccrOp != null ? instr.Operands[1] : instr.Operands[0]);
                if (updateLinkregister)
                {
                    m.BranchInMiddleOfInstruction(
                        m.Test(cc, cr).Invert(),
                        instr.Address + instr.Length,
                        InstrClass.ConditionalTransfer);
                    m.Call(dst, 0);
                }
                else
                {
                    m.Branch(m.Test(cc, cr), (Address)dst, InstrClass.ConditionalTransfer);
                }
            }
        }

        private ConditionCode CcFromOperand(ConditionOperand ccOp)
        {
            switch (ccOp.condition & 3)
            {
            case 0: return ConditionCode.LT;
            case 1: return ConditionCode.GT;
            case 2: return ConditionCode.EQ;
            case 3: return ConditionCode.OV;
            default: throw new NotImplementedException();
            }
        }

        private RegisterStorage CrFromOperand(ConditionOperand ccOp)
        {
            return arch.CrRegisters[(int)ccOp.condition >> 2];
        }
        
        private void RewriteCtrBranch(bool updateLinkRegister, bool toLinkRegister, Func<Expression,Expression,Expression> decOp, bool ifSet)
        {
            var ctr = binder.EnsureRegister(arch.ctr);
            Expression dest;

            Expression cond = decOp(ctr, Constant.Zero(ctr.DataType));

            if (instr.Operands[0] is ConditionOperand ccOp)
            {
                Expression test = m.Test(
                    CcFromOperand(ccOp),
                    binder.EnsureRegister(CrFromOperand(ccOp)));
                if (!ifSet)
                    test = test.Invert();
                cond = m.Cand(cond, test);
                dest = RewriteOperand(instr.Operands[1]);
            }
            else
            {
                dest = RewriteOperand(instr.Operands[0]);
            }
            
            m.Assign(ctr, m.ISub(ctr, 1));
            if (updateLinkRegister)
            {
                m.BranchInMiddleOfInstruction(
                    cond.Invert(),
                    instr.Address + instr.Length,
                    InstrClass.ConditionalTransfer);
                m.Call(dest, 0);
            }
            else
            {
                m.Branch(
                    cond,
                    (Address)dest,
                    InstrClass.ConditionalTransfer);
            }
        }

        private void RewriteBranch(bool linkRegister, Expression destination)
        {
            var ctr = binder.EnsureRegister(arch.ctr);
            var bo = ((Constant) RewriteOperand(instr.Operands[0])).ToByte();
            var bi = ((Constant) RewriteOperand(instr.Operands[1])).ToByte();
            switch (bo)
            {
            case 0x00:
            case 0x01:
                // throw new NotImplementedException("dec ctr");
                EmitUnitTest();
                iclass = InstrClass.Invalid;
                m.Invalid();
                break;
            case 0x02:
            case 0x03:
                // throw new NotImplementedException("dec ctr");
                EmitUnitTest();
                iclass = InstrClass.Invalid;
                m.Invalid();
                break;
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
                // Bit 0 = LT
                // Bit 1 = GT
                // Bit 2 = EQ
                // Bit 3 = SO
                ConditionCode cc;
                switch (bi)
                {
                // Fixed arithmetic flags.
                case 0: cc = ConditionCode.GE; break;
                case 1: cc = ConditionCode.LE; break;
                case 2: cc = ConditionCode.NE; break;
                case 3: cc = ConditionCode.NO; break;
                // Floating point flags.
                case 4: cc = ConditionCode.GE; break;
                case 5: cc = ConditionCode.LE; break;
                case 6: cc = ConditionCode.NE; break;
                case 7: cc = ConditionCode.NO; break;
                default:
                    EmitUnitTest();
                    iclass = InstrClass.Invalid;
                    m.Invalid();
                    return;
                }
                EmitBranch(destination, bi, cc);
                break;
            case 0x08:
            case 0x09:
                throw new NotImplementedException("dec ctr; condition false");
            case 0x0A:
            case 0x0B:
                {
                    if (destination is Address addr)
                    {
                        //$TODO implement this
                        EmitUnitTest();
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                    else
                    {
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                }
                break;
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
                switch (bi)
                {
                // Fixed arithmetic flags.
                case 0: cc = ConditionCode.LT; break;
                case 1: cc = ConditionCode.GT; break;
                case 2: cc = ConditionCode.EQ; break;
                case 3: cc = ConditionCode.OV; break;
                // Floating point flags
                case 4: cc = ConditionCode.LT; break;
                case 5: cc = ConditionCode.GT; break;
                case 6: cc = ConditionCode.EQ; break;
                case 7: cc = ConditionCode.OV; break;
                default:
                    EmitUnitTest();
                    iclass = InstrClass.Invalid;
                    m.Invalid();
                    return;
                }
                EmitBranch(destination, bi, cc);
                break;
            case 0x10:
            case 0x11:
            case 0x18:
            case 0x19:
                {
                    if (destination is Address addr)
                    {
                        m.Assign(ctr, m.ISub(ctr, 1));
                        m.Branch(m.Eq0(ctr), addr);
                    }
                    else
                    {
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                }
                break;
            case 0x12:
            case 0x13:
            case 0x1A:
            case 0x1B:
                {
                    if (destination is Address addr)
                    {
                        m.Assign(ctr, m.ISub(ctr, 1));
                        m.Branch(m.Eq0(ctr), addr);
                    }
                    else
                    {
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                }
                break;
            default:
                if (linkRegister)
                    m.Call(ctr, 0);
                else
                    m.Goto(ctr);
                return;
            }
        }

        private void EmitBranch(Expression destination, byte bi, ConditionCode cc)
        {
            var flag = binder.EnsureFlagGroup(arch.GetFlagGroup(arch.cr, 1u << bi));
            if (destination is Address addrDst)
            {
                m.Branch(m.Test(cc, flag), addrDst);
            }
            else
            {
                m.BranchInMiddleOfInstruction(m.Test(cc.Invert(), flag), instr.Address + instr.Length, InstrClass.ConditionalTransfer);
                m.Goto(destination);
            }
        }

        private void RewriteSc()
        {
            m.SideEffect(host.Intrinsic(IntrinsicProcedure.Syscall, false, arch.WordWidth));
        }
    }
}

---- Transformed Tree ----
using Reko.Core;
using Reko.Core.Expressions;
using Reko.Core.Machine;
using Reko.Core.Operators;
using Reko.Core.Rtl;
using Reko.Core.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Reko.Arch.PowerPC
{
    public partial class PowerPcRewriter
    {
        private void RewriteB()
        {
            var dst = RewriteOperand(instr.Operands[0]);
            m.Goto(dst);
        }

        private void RewriteBc(bool linkRegister)
        {
            throw new NotImplementedException();
        }

        private void RewriteBcctr(bool linkRegister)
        {
            RewriteBranch(linkRegister, binder.EnsureRegister(arch.ctr));
        }

        private void RewriteBl()
        {
            var dst = RewriteOperand(instr.Operands[0]);

            if (dst is Address addrDst && instr.Address.ToLinear() + 4 == addrDst.ToLinear())
            {
                // PowerPC idiom to get the current instruction pointer in the lr register
                iclass = InstrClass.Linear;
                m.Assign(binder.EnsureRegister(arch.lr), addrDst);
            }
            else
            {
                m.Call(dst, 0);
            }
        }

        private void RewriteBlr()
        {
            m.Return(0, 0);
        }

        private void RewriteBranch(bool updateLinkregister, bool toLinkRegister, ConditionCode cc)
        {
            Expression cr;

            if (instr.Operands[0] is RegisterOperand ccrOp)
            {
                cr = RewriteOperand(instr.Operands[0]);
            }
            else 
            {
                cr = binder.EnsureFlagGroup(arch.GetCcFieldAsFlagGroup(arch.CrRegisters[0])!);
            }
            if (toLinkRegister)
            {
                m.BranchInMiddleOfInstruction(
                    m.Test(cc, cr).Invert(),
                    instr.Address + instr.Length,
                    InstrClass.ConditionalTransfer);
                var dst = binder.EnsureRegister(arch.lr);
                if (updateLinkregister)
                {
                    m.Call(dst, 0);
                }
                else
                {
                    m.Return(0, 0);
                }
            }
            else
            {
                var dst = RewriteOperand(instr.Operands[0] is RegisterOperand ccrOp ? instr.Operands[1] : instr.Operands[0]);
                if (updateLinkregister)
                {
                    m.BranchInMiddleOfInstruction(
                        m.Test(cc, cr).Invert(),
                        instr.Address + instr.Length,
                        InstrClass.ConditionalTransfer);
                    m.Call(dst, 0);
                }
                else
                {
                    m.Branch(m.Test(cc, cr), (Address)dst, InstrClass.ConditionalTransfer);
                }
            }
        }

        private ConditionCode CcFromOperand(ConditionOperand ccOp)
        {
            switch (ccOp.condition & 3)
            {
            case 0: return ConditionCode.LT;
            case 1: return ConditionCode.GT;
            case 2: return ConditionCode.EQ;
            case 3: return ConditionCode.OV;
            default: throw new NotImplementedException();
            }
        }

        private RegisterStorage CrFromOperand(ConditionOperand ccOp)
        {
            return arch.CrRegisters[(int)ccOp.condition >> 2];
        }
        
        private void RewriteCtrBranch(bool updateLinkRegister, bool toLinkRegister, Func<Expression,Expression,Expression> decOp, bool ifSet)
        {
            var ctr = binder.EnsureRegister(arch.ctr);
            Expression dest;

            Expression cond = decOp(ctr, Constant.Zero(ctr.DataType));

            if (instr.Operands[0] is ConditionOperand ccOp)
            {
                Expression test = m.Test(
                    CcFromOperand(ccOp),
                    binder.EnsureRegister(CrFromOperand(ccOp)));
                if (!ifSet)
                    test = test.Invert();
                cond = m.Cand(cond, test);
                dest = RewriteOperand(instr.Operands[1]);
            }
            else
            {
                dest = RewriteOperand(instr.Operands[0]);
            }
            
            m.Assign(ctr, m.ISub(ctr, 1));
            if (updateLinkRegister)
            {
                m.BranchInMiddleOfInstruction(
                    cond.Invert(),
                    instr.Address + instr.Length,
                    InstrClass.ConditionalTransfer);
                m.Call(dest, 0);
            }
            else
            {
                m.Branch(
                    cond,
                    (Address)dest,
                    InstrClass.ConditionalTransfer);
            }
        }

        private void RewriteBranch(bool linkRegister, Expression destination)
        {
            var ctr = binder.EnsureRegister(arch.ctr);
            var bo = ((Constant) RewriteOperand(instr.Operands[0])).ToByte();
            var bi = ((Constant) RewriteOperand(instr.Operands[1])).ToByte();
            switch (bo)
            {
            case 0x00:
            case 0x01:
                // throw new NotImplementedException("dec ctr");
                EmitUnitTest();
                iclass = InstrClass.Invalid;
                m.Invalid();
                break;
            case 0x02:
            case 0x03:
                // throw new NotImplementedException("dec ctr");
                EmitUnitTest();
                iclass = InstrClass.Invalid;
                m.Invalid();
                break;
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
                // Bit 0 = LT
                // Bit 1 = GT
                // Bit 2 = EQ
                // Bit 3 = SO
                ConditionCode cc;
                switch (bi)
                {
                // Fixed arithmetic flags.
                case 0: cc = ConditionCode.GE; break;
                case 1: cc = ConditionCode.LE; break;
                case 2: cc = ConditionCode.NE; break;
                case 3: cc = ConditionCode.NO; break;
                // Floating point flags.
                case 4: cc = ConditionCode.GE; break;
                case 5: cc = ConditionCode.LE; break;
                case 6: cc = ConditionCode.NE; break;
                case 7: cc = ConditionCode.NO; break;
                default:
                    EmitUnitTest();
                    iclass = InstrClass.Invalid;
                    m.Invalid();
                    return;
                }
                EmitBranch(destination, bi, cc);
                break;
            case 0x08:
            case 0x09:
                throw new NotImplementedException("dec ctr; condition false");
            case 0x0A:
            case 0x0B:
                {
                    if (destination is Address addr)
                    {
                        //$TODO implement this
                        EmitUnitTest();
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                    else
                    {
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                }
                break;
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
                switch (bi)
                {
                // Fixed arithmetic flags.
                case 0: cc = ConditionCode.LT; break;
                case 1: cc = ConditionCode.GT; break;
                case 2: cc = ConditionCode.EQ; break;
                case 3: cc = ConditionCode.OV; break;
                // Floating point flags
                case 4: cc = ConditionCode.LT; break;
                case 5: cc = ConditionCode.GT; break;
                case 6: cc = ConditionCode.EQ; break;
                case 7: cc = ConditionCode.OV; break;
                default:
                    EmitUnitTest();
                    iclass = InstrClass.Invalid;
                    m.Invalid();
                    return;
                }
                EmitBranch(destination, bi, cc);
                break;
            case 0x10:
            case 0x11:
            case 0x18:
            case 0x19:
                {
                    if (destination is Address addr)
                    {
                        m.Assign(ctr, m.ISub(ctr, 1));
                        m.Branch(m.Eq0(ctr), addr);
                    }
                    else
                    {
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                }
                break;
            case 0x12:
            case 0x13:
            case 0x1A:
            case 0x1B:
                {
                    if (destination is Address addr)
                    {
                        m.Assign(ctr, m.ISub(ctr, 1));
                        m.Branch(m.Eq0(ctr), addr);
                    }
                    else
                    {
                        iclass = InstrClass.Invalid;
                        m.Invalid();
                    }
                }
                break;
            default:
                if (linkRegister)
                    m.Call(ctr, 0);
                else
                    m.Goto(ctr);
                return;
            }
        }

        private void EmitBranch(Expression destination, byte bi, ConditionCode cc)
        {
            var flag = binder.EnsureFlagGroup(arch.GetFlagGroup(arch.cr, 1u << bi));
            if (destination is Address addrDst)
            {
                m.Branch(m.Test(cc, flag), addrDst);
            }
            else
            {
                m.BranchInMiddleOfInstruction(m.Test(cc.Invert(), flag), instr.Address + instr.Length, InstrClass.ConditionalTransfer);
                m.Goto(destination);
            }
        }

        private void RewriteSc()
        {
            m.SideEffect(host.Intrinsic(IntrinsicProcedure.Syscall, false, arch.WordWidth));
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(26,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(28,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(24,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(29,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(25,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(103,79): error CS0136: A local or parameter named 'ccrOp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(24,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(29,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(25,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(26,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\PowerPC\PowerPcRewriter.Control.cs(28,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Arch.X86;
using Reko.Core;
using Reko.Core.Assemblers;
using Reko.Core.Expressions;
using Reko.Core.Machine;
using Reko.Core.Types;
using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Linq;
using Reko.Core.Memory;

namespace Reko.Arch.X86.Assembler
{
    /// <summary>
    /// A crude MASM-style assembler for x86 instructions.
    /// </summary>
    public class X86Assembler
    {
        enum StringInstructionBaseOps : byte
        {
            Move = 0xA4,
            Compare = 0xA6,
            Store = 0xAA,
            Load = 0xAC,
            Scan = 0xAE,
        }
        private readonly Address addrBase;
        private readonly PrimitiveType defaultWordSize;
        private readonly AssembledSegment unknownSegment;
        private readonly SymbolTable symtab;
        private readonly List<ImageSymbol> entryPoints;
        private readonly Dictionary<Address, ImportReference> importReferences;
        private readonly List<AssembledSegment> segments;
        private readonly Dictionary<string, AssembledSegment> mpNameToSegment;
        private readonly Dictionary<Symbol, AssembledSegment> symbolSegments;        // The segment to which a symbol belongs.
        private IProcessorArchitecture arch;
        private ModRmBuilder modRm;
        private IEmitter emitter;
        private AssembledSegment currentSegment;

#nullable disable
        public X86Assembler(IntelArchitecture arch, Address addrBase, List<ImageSymbol> entryPoints)
        {
            this.arch = arch;
            this.addrBase = addrBase;
            this.entryPoints = entryPoints;
            this.defaultWordSize = arch.WordWidth;
            this.textEncoding = Encoding.GetEncoding("ISO_8859-1");
            symtab = new SymbolTable();
            importReferences = new Dictionary<Address, ImportReference>();
            segments = new List<AssembledSegment>();
            mpNameToSegment = new Dictionary<string, AssembledSegment>();
            symbolSegments = new Dictionary<Symbol, AssembledSegment>();
            this.SegmentOverride = RegisterStorage.None;

            unknownSegment = new AssembledSegment(new Emitter(), symtab.DefineSymbol("", 0));
            segments.Add(unknownSegment);

            SwitchSegment(unknownSegment);

            SetDefaultWordWidth(defaultWordSize);
        }

        /// <summary>
        /// This constructor makes an X86Assembler that modifies an existing chunk of memory.
        /// It is intended for small mutations of code (like patching NOPs over unwanted code).
        /// It should not be used for generation of large amounts of code.
        /// </summary>
        /// <param name="program">Program to mutate.</param>
        /// <param name="addrStart">The address at which to start mutating.</param>
        public X86Assembler(Program program, Address addrStart)
        {
            this.arch = (IntelArchitecture) program.Architecture;
            this.addrBase = program.SegmentMap.BaseAddress;
            this.entryPoints = program.EntryPoints.Values.ToList();
            this.defaultWordSize = arch.WordWidth;
            this.textEncoding = Encoding.GetEncoding("ISO_8859-1");
            symtab = new SymbolTable();
            importReferences = program.ImportReferences;
            mpNameToSegment = new Dictionary<string, AssembledSegment>();
            symbolSegments = new Dictionary<Symbol, AssembledSegment>();
            this.SegmentOverride = RegisterStorage.None;
            segments = program.SegmentMap.Segments.Values
                .Select(seg => new AssembledSegment(new Emitter(seg.MemoryArea), new Symbol(seg.Name)))
                .ToList();
            if (!program.SegmentMap.TryFindSegment(addrStart, out var segmentToMutate))
                throw new InvalidOperationException($"Address {addrStart} is not a valid location in the program.");
            var offset = addrStart - segmentToMutate.MemoryArea.BaseAddress;
            var asmSeg = this.segments.Single(seg => seg.Symbol!.sym == segmentToMutate.Name);
            asmSeg.Emitter.Position = (int)offset;
            SwitchSegment(asmSeg);
            SetDefaultWordWidth(defaultWordSize);
        }
#nullable enable

        public int CurrentPosition => this.emitter.Position;

        public Dictionary<Address, ImportReference> ImportReferences
        {
            get { return importReferences; }
        }

        /// <summary>
        /// Extracts the assembled machine code into a <see cref="Program"/> instance.
        /// </summary>
        /// <remarks>
        /// Callers must provide their own <see cref="IPlatform"/> instance.
        /// </remarks>
        public Program GetImage()
        {
            var stm = new MemoryStream();
            LoadSegments(stm);
            var mem = new ByteMemoryArea(addrBase, stm.ToArray());
            RelocateSegmentReferences(mem);
            return new Program(
                new SegmentMap(
                    mem.BaseAddress,
                    new ImageSegment("code", mem, AccessMode.ReadWriteExecute)),
                arch,
                null);
        }

        private void LoadSegments(MemoryStream stm)
        {
            foreach (var seg in segments)
            {
                while ((stm.Position & 0xF) != 0)
                {
                    stm.WriteByte(0x90);        // 1-byte NOP instruction.
                }
                
                ushort sel;
                if (addrBase.Selector.HasValue)
                    sel = (ushort)(this.addrBase.Selector.Value + (stm.Position >> 4));
                else
                    sel = 0;
                seg.Selector = sel;
                var ab = seg.Emitter.GetBytes();
                stm.Write(ab, 0, ab.Length);
            }
        }

        private void RelocateSegmentReferences(ByteMemoryArea bmem)
        {
            foreach (var seg in segments)
            {
                foreach (var reloc in seg.Relocations)
                {
                    bmem.WriteLeUInt16((uint)((reloc.Segment.Selector - addrBase.Selector!.Value) * 16u + reloc.Offset), seg.Selector);
                }
            }
        }

        public void Align(int alignment)
        {
            emitter.Align(0, alignment);
        }

        public void Mov(ParsedOperand op, int constant)
        {
            ProcessMov(
                op,
                Imm(op.Operand.Width, constant));
        }


        public void Mov(ParsedOperand dst, ParsedOperand src)
        {
            ProcessMov(dst, src);
        }

        public void Rcl(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x02, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Rcr(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x03, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Rol(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x00, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Ror(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x01, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Sahf()
        {
            emitter.EmitByte(0x9E);
        }

        public void Sar(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x07, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Sar(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessShiftRotation(0x7, op1, op2);
        }

        public void Shl(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x04, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Shr(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x05, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Shr(ParsedOperand dst, ParsedOperand sh)
        {
            ProcessShiftRotation(0x05, dst, sh);
        }

        public void Shld(ParsedOperand op1, ParsedOperand op2, ParsedOperand op3)
        {
            ProcessDoubleShift(0, op1, op2, op3);
        }

        public void Shrd(ParsedOperand op1, ParsedOperand op2, byte count)
        {
            ProcessDoubleShift(8, op1, op2, new ParsedOperand(ImmediateOperand.Byte(count)));
        }

        public void Sub(ParsedOperand op, int constant)
        {
            Sub(op, Imm(op.Operand.Width, constant));
        }

        public void Sub(ParsedOperand minuend, ParsedOperand subtrahend)
        {
            ProcessBinop(0x05, minuend, subtrahend);
        }

        public void Test(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessTest( op1, op2 );
        }

        public void Test(ParsedOperand op1, int imm)
        {
            ProcessTest(op1, Imm(imm));
        }

        public ParsedOperand BytePtr(int offset)
        {
            AddressWidth = SegmentAddressWidth;
            return new ParsedOperand(
                new MemoryOperand(PrimitiveType.Byte, Constant.Create(AddressWidth, offset)));
        }

        internal PrimitiveType? EnsureValidOperandSize(ParsedOperand op)
        {
            PrimitiveType w = op.Operand.Width;
            if (w is null)
                Error("Width of the operand is unknown");
            return w;
        }

        internal void ProcessComm(string sym)
        {
            DefineSymbol(sym);
            emitter.EmitLeUInt32(0);
        }

        internal void ProcessFpuCommon(int opcodeFreg, int opcodeMem, int fpuOperation, bool isPop, bool fixedOrder, params ParsedOperand[] ops)
        {
            if (ops.Length == 0)
            {
                ops = new ParsedOperand[] { new ParsedOperand(new FpuOperand(0)), new ParsedOperand(new FpuOperand(1)) };
            }
            else if (ops.Length == 1 && ops[0].Operand is FpuOperand)
            {
                ops = new ParsedOperand[] { new ParsedOperand(new FpuOperand(0)), ops[0] };
            }

            FpuOperand? fop1 = ops[0].Operand as FpuOperand;
            FpuOperand? fop2 = ops.Length > 1 ? ops[1].Operand as FpuOperand : null;
            MemoryOperand? mop = ops[0].Operand as MemoryOperand;
            if (mop == null && ops.Length > 1)
                mop = ops[1].Operand as MemoryOperand;
            if (mop != null)
            {
                EmitOpcode(opcodeMem | (mop.Width == PrimitiveType.Word64 ? 4 : 0), null);
                EmitModRM(fpuOperation, mop, null);
                return;
            }
            if (isPop)
            {
                if (fop1 is null)
                {
                    Error("First operand must be of type ST(n)");
                    return;
                }
                EmitOpcode(opcodeFreg, null);
                if (fixedOrder)
                    fpuOperation ^= 1;
                if (fop1.StNumber == 0)
                    EmitModRM(fpuOperation, new ParsedOperand(fop2!, null));
                else
                    EmitModRM(fpuOperation, new ParsedOperand(fop1, null));
                return;
            }
            if (fop1 != null)
            {
                fop2 = (FpuOperand) ops[1].Operand;
                if (fop1.StNumber != 0)
                {
                    if (fop2.StNumber != 0)
                        Error("at least one of the floating point stack arguments must be ST(0)");
                    if (fixedOrder)
                        fpuOperation ^= 1;
                    fop2 = fop1;
                }
                EmitOpcode(opcodeFreg, null);
                EmitModRM(fpuOperation, new ParsedOperand(fop2, null));
                return;
            }
            throw new NotImplementedException("NYI");
        }

        internal void ProcessFst(bool pop, ParsedOperand operand)
        {
            int regBits = pop ? 3 : 2;
            if (operand.Operand is MemoryOperand mop)
            {
                switch (mop.Width.Size)
                {
                case 4: EmitOpcode(0xD9, null); break;
                case 8: EmitOpcode(0xDD, null); break;
                default: Error("Unexpected operator width"); break;
                }
                EmitModRM(regBits, operand);
            }
            else if (operand.Operand is FpuOperand fop)
            {
                EmitOpcode(0xDD, null);
                EmitModRM(regBits, new ParsedOperand(fop, null));
            }
            else
                Error("Unexpected operator type");
        }


        public void ProcessImul(params ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth;
            if (ops.Length == 1)
            {
                dataWidth = EnsureValidOperandSize(ops[0]);
                EmitOpcode(0xF6 | IsWordWidth(ops[0].Operand), dataWidth);
                EmitModRM(0x05, ops[0]);
            }
            else
            {
                dataWidth = EnsureValidOperandSizes(ops, 2);
                if (dataWidth is null)
                    return;
                if (!(ops[0].Operand is RegisterOperand regOp))
                    throw new ApplicationException("First operand must be a register");
                if (IsWordWidth(regOp) == 0)
                    throw new ApplicationException("Destination register must be word-width");

                if (ops.Length == 2)
                {
                    EmitOpcode(0x0F, dataWidth);
                    emitter.EmitByte(0xAF);
                    EmitModRM(RegisterEncoding(regOp.Register), ops[1]);
                }
                else
                {
                    if (!(ops[2].Operand is ImmediateOperand op3))
                        throw new ApplicationException("Third operand must be an immediate value");
                    if (IsSignedByte(op3.Value.ToInt32()))
                    {
                        EmitOpcode(0x6B, dataWidth);
                        EmitModRM(RegisterEncoding(regOp.Register), ops[1]);
                        emitter.EmitByte(op3.Value.ToInt32());
                    }
                    else
                    {
                        EmitOpcode(0x69, dataWidth);
                        EmitModRM(RegisterEncoding(regOp.Register), ops[1]);
                        emitter.EmitLeImmediate(op3.Value, dataWidth);
                    }
                }
            }
        }

        internal void ProcessIncDec(bool fDec, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            if (op.Operand is RegisterOperand regOp)
            {
                if (IsWordWidth(dataWidth) != 0)
                {
                    EmitOpcode((fDec ? 0x48 : 0x40) | RegisterEncoding(regOp.Register), dataWidth);
                }
                else
                {
                    EmitOpcode(0xFE | IsWordWidth(dataWidth), dataWidth);
                    EmitModRM(fDec ? 1 : 0, op);
                }
                return;
            }

            if (op.Operand is MemoryOperand memOp)
            {
                EmitOpcode(0xFE | IsWordWidth(dataWidth), dataWidth);
                EmitModRM(fDec ? 1 : 0, op);
            }
            else
            {
                throw new ApplicationException("constant operator illegal");
            }
        }

        public void ProcessInOut(bool fOut, params ParsedOperand[] ops)
        {
            ParsedOperand opPort;
            ParsedOperand opData;

            if (fOut)
            {
                opPort = ops[0];
                opData = ops[1];
            }
            else
            {
                opData = ops[0];
                opPort = ops[1];
            }

            if (!(opData.Operand is RegisterOperand regOpData) || IsAccumulator(regOpData.Register) == 0)
                throw new ApplicationException("Invalid register for in or out instruction.");

            int opcode = IsWordWidth(regOpData) | (fOut ? 0xE6 : 0xE4);

            if (opPort.Operand is RegisterOperand regOpPort)
            {
                if (regOpPort.Register == Registers.dx || regOpPort.Register == Registers.edx)
                {
                    EmitOpcode(8 | opcode, regOpPort.Width);
                }
                else
                    throw new ApplicationException("port must be specified with 'immediate', dx, or edx register");
                return;
            }

            if (opPort.Operand is ImmediateOperand immOp)
            {
                if (immOp.Value.ToUInt32() > 0xFF)
                {
                    throw new ApplicationException("port number must be between 0 and 255");
                }
                else
                {
                    emitter.EmitByte(opcode);
                    emitter.EmitByte(immOp.Value.ToInt32());
                }
            }
            else
            {
                throw new ApplicationException("port must be specified with 'immediate', dx, or edx register");
            }
        }

        internal void ProcessInt(ParsedOperand vector)
        {
            ImmediateOperand op = (ImmediateOperand) vector.Operand;
            EmitOpcode(0xCD, null);
            emitter.EmitByte(op.Value.ToInt32());
        }


        internal void ProcessLongBranch(int cc, string destination)
        {
            EmitOpcode(0x0F, null);
            emitter.EmitByte(0x80 | cc);
            EmitRelativeTarget(destination, SegmentAddressWidth);
        }

        internal void ProcessLoop(int opcode, string destination)
        {
            EmitOpcode(0xE0 | opcode, null);
            emitter.EmitByte(-(emitter.Position + 1));
            ReferToSymbol(symtab.CreateSymbol(destination),
                emitter.Position - 1, PrimitiveType.Byte);
        }

        public void ProcessLxs(int prefix, int b, params ParsedOperand[] ops)
        {
            RegisterOperand opDst = (RegisterOperand) ops[0].Operand;

            if (prefix > 0)
            {
                EmitOpcode(prefix, opDst.Width);
                emitter.EmitByte(b);
            }
            else
                EmitOpcode(b, SegmentDataWidth);
            EmitModRM(RegisterEncoding(opDst.Register), ops[1]);
        }

        internal void ProcessMov(params ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;

            RegisterOperand? regOpSrc = ops[1].Operand as RegisterOperand;
            RegisterOperand? regOpDst = ops[0].Operand as RegisterOperand;
            if (regOpDst != null)	//$BUG: what about segment registers?
            {
                byte reg = RegisterEncoding(regOpDst.Register);
                if (IsSegmentRegister(regOpDst.Register))
                {
                    if (regOpSrc != null)
                    {
                        if (IsSegmentRegister(regOpSrc.Register ))
                            Error("Cannot assign between two segment registers");
                        if (ops[1].Operand.Width != PrimitiveType.Word16)
                            Error(string.Format("Values assigned to/from segment registers must be 16 bits wide"));
                        EmitOpcode(0x8E, PrimitiveType.Word16);
                        EmitModRM(reg, ops[1]);
                        return;
                    }
                    if (ops[1].Operand is MemoryOperand mopSrc)
                    {
                        EmitOpcode(0x8E, PrimitiveType.Word16);
                        EmitModRM(reg, mopSrc, ops[1].Symbol);
                        return;
                    }
                }

                if (regOpSrc != null && IsSegmentRegister(regOpSrc.Register))
                {
                    if (IsSegmentRegister(regOpDst.Register))
                        Error("Cannot assign between two segment registers");
                    if (ops[0].Operand.Width != PrimitiveType.Word16)
                        Error(string.Format("Values assigned to/from segment registers must be 16 bits wide"));
                    EmitOpcode(0x8C, PrimitiveType.Word16);
                    EmitModRM(RegisterEncoding(regOpSrc.Register), ops[0]);
                    return;
                }

                int isWord = IsWordWidth(regOpDst);
                if (regOpSrc != null)
                {
                    if (regOpSrc.Width != regOpDst.Width)
                        this.Error(string.Format("size mismatch between {0} and {1}", regOpSrc.Register, regOpDst.Register));
                    EmitOpcode(0x8A | (isWord & 1), dataWidth);
                    modRm.EmitModRM(reg, regOpSrc);
                    return;
                }

                if (ops[1].Operand is MemoryOperand memOpSrc)
                {
                    EmitOpcode(0x8A | (isWord & 1), dataWidth);
                    EmitModRM(reg, memOpSrc, ops[1].Symbol);
                    return;
                }

                if (ops[1].Operand is ImmediateOperand immOpSrc)
                {
                    EmitOpcode(0xB0 | (isWord << 3) | reg, dataWidth);
                    if (isWord != 0)
                        emitter.EmitLe(dataWidth, immOpSrc.Value.ToInt32());
                    else
                        emitter.EmitByte(immOpSrc.Value.ToInt32());

                    if (ops[1].Symbol != null && isWord != 0)
                    {
                        ReferToSymbol(ops[1].Symbol!, emitter.Position - (int) immOpSrc.Width.Size, immOpSrc.Width);
                    }
                    return;
                }
                throw new ApplicationException("unexpected");
            }

            MemoryOperand memOpDst = (MemoryOperand) ops[0].Operand;
            regOpSrc = ops[1].Operand as RegisterOperand;
            if (regOpSrc != null)
            {
                if (IsSegmentRegister(regOpSrc.Register))
                {
                    EmitOpcode(0x8C, PrimitiveType.Word16);
                }
                else
                {
                    EmitOpcode(0x88 | IsWordWidth(ops[1].Operand), dataWidth);
                }
                EmitModRM(RegisterEncoding(regOpSrc.Register), memOpDst, ops[0].Symbol);
            }
            else
            {
                ImmediateOperand immOpSrc = (ImmediateOperand) ops[1].Operand;
                int isWord = (dataWidth != PrimitiveType.Byte) ? 1 : 0;
                EmitOpcode(0xC6 | IsWordWidth(dataWidth), dataWidth);
                EmitModRM(0, memOpDst, ops[0].Symbol);
                emitter.EmitLeImmediate(immOpSrc.Value, dataWidth);
            }
        }

        public static bool IsSegmentRegister(RegisterStorage seg)
        {
            return seg.Domain == Registers.cs.Domain ||
                   seg.Domain == Registers.ds.Domain ||
                   seg.Domain == Registers.es.Domain ||
                   seg.Domain == Registers.fs.Domain ||
                   seg.Domain == Registers.gs.Domain ||
                   seg.Domain == Registers.ss.Domain;
        }

        internal void ProcessMovx(int opcode, ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(ops[1]);
            if (dataWidth is null)
                return;

            if (!(ops[0].Operand is RegisterOperand regDst))
            {
                Error("First operand must be a register");
                return;
            }
            EmitOpcode(0x0F, regDst.Width);
            emitter.EmitByte(opcode | IsWordWidth(dataWidth));
            EmitModRM(RegisterEncoding(regDst.Register), ops[1]);
        }

        public void Mul(ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;

            // Single operand doesn't accept immediate values.
            if (op.Operand is ImmediateOperand)
                Error("Immediate operand not allowed for single-argument multiplication");

            EmitOpcode(0xF6 | IsWordWidth(dataWidth), dataWidth);
            EmitModRM(4, op);
        }

        internal void ProcessPushPop(bool fPop, ParsedOperand op)
        {
            int imm;
            if (op.Operand is ImmediateOperand immOp)
            {
                if (fPop)
                    throw new ApplicationException("Can't pop an immediate value");
                imm = immOp.Value.ToInt32();
                if (IsSignedByte(imm))
                {
                    EmitOpcode(0x6A, PrimitiveType.Byte);
                    emitter.EmitByte(imm);
                }
                else
                {
                    EmitOpcode(0x68, SegmentDataWidth);
                    emitter.EmitLe(SegmentDataWidth, imm);
                }
                return;
            }

            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;

            if (op.Operand is RegisterOperand regOp)
            {
                var rrr = regOp.Register;
                if (IsBaseRegister(rrr))
                {
                    EmitOpcode(0x50 | (fPop ? 8 : 0) | RegisterEncoding(regOp.Register), dataWidth);
                }
                else
                {
                    int mask = (fPop ? 1 : 0);
                    if (regOp.Register == Registers.es) emitter.EmitByte(0x06 | mask);
                    else if (regOp.Register == Registers.cs) emitter.EmitByte(0x0E | mask);
                    else if (regOp.Register == Registers.ss) emitter.EmitByte(0x16 | mask);
                    else if (regOp.Register == Registers.ds) emitter.EmitByte(0x1E | mask);
                    else if (regOp.Register == Registers.fs) { emitter.EmitByte(0x0F); emitter.EmitByte(0xA0 | mask); }
                    else if (regOp.Register == Registers.gs) { emitter.EmitByte(0x0F); emitter.EmitByte(0xA8 | mask); }
                }
                return;
            }

            EmitOpcode(fPop ? 0x8F : 0xFF, dataWidth);
            EmitModRM(fPop ? 0 : 6, op);
        }

        private bool IsBaseRegister(RegisterStorage reg)
        {
            var r = (int)reg.Domain;
            return (int)Registers.eax.Domain <= r && r <= (int)Registers.edi.Domain;
        }

        internal void ProcessSetCc(byte bits, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            if (dataWidth != PrimitiveType.Byte)
                Error("Instruction takes only a byte operand");
            EmitOpcode(0x0F, dataWidth);
            emitter.EmitByte(0x90 | (bits & 0xF));
            EmitModRM(0, op);
        }


        internal void ProcessShiftRotation(byte subOpcode, ParsedOperand dst, ParsedOperand count)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(dst);
            if (dataWidth is null)
                return;
            if (count.Operand is ImmediateOperand immOp)
            {
                int imm = immOp.Value.ToInt32();
                if (imm == 1)
                {
                    EmitOpcode(0xD0 | IsWordWidth(dataWidth), dataWidth);
                    EmitModRM(subOpcode, dst);
                }
                else
                {
                    EmitOpcode(0xC0 | IsWordWidth(dataWidth), dataWidth);
                    EmitModRM(subOpcode, dst, (byte) immOp.Value.ToInt32());
                }
                return;
            }

            if (count.Operand is RegisterOperand regOp &&
                regOp.Register == Registers.cl)
            {
                EmitOpcode(0xD2 | IsWordWidth(dataWidth), dataWidth);
                EmitModRM(subOpcode, dst);
                return;
            }

            throw new ApplicationException("Shift/rotate instructions must be followed by a constant or CL");
        }

        internal void ProcessShortBranch(int cc, string destination)
        {
            EmitOpcode(0x70 | cc, null);
            EmitRelativeTarget(destination, PrimitiveType.Byte);
        }

        internal void ProcessStringInstruction(byte opcode, PrimitiveType width)
        {
            EmitOpcode(opcode | IsWordWidth(width), width);
        }

        internal void ProcessTest(params ParsedOperand[] ops)
        {
            var dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;

            byte isWord = (byte) ((dataWidth != PrimitiveType.Byte) ? 0xFF : 0);

            if (ops[0].Operand is RegisterOperand regOpDst)	//$BUG: what about segment registers?
            {
                byte reg = RegisterEncoding(regOpDst.Register);
                if (ops[1].Operand is RegisterOperand regOpSrc)
                {
                    if (regOpSrc.Width != regOpDst.Width)
                        Error("Operand size mismatch");
                    EmitOpcode(0x84 | (isWord & 1), dataWidth);
                    modRm.EmitModRM(reg, regOpSrc);
                    return;
                }

                if (ops[1].Operand is MemoryOperand memOpSrc)
                {
                    EmitOpcode(0x84 | (isWord & 1), dataWidth);
                    EmitModRM(reg, ops[1]);
                    return;
                }
                else if (ops[1].Operand is ImmediateOperand immOpSrc)
                {
                    EmitOpcode(0xF6 | (isWord & 1), dataWidth);
                    EmitModRM(0, ops[0]);
                    if (isWord != 0)
                        emitter.EmitLe(dataWidth, immOpSrc.Value.ToInt32());
                    else
                        emitter.EmitByte(immOpSrc.Value.ToInt32());

                    var sym = ops[1].Symbol;
                    if (sym != null && isWord != 0)
                    {
                        Debug.Assert(immOpSrc.Value.ToUInt32() == 0);
                        ReferToSymbol(sym, emitter.Position - 2, PrimitiveType.Word16);
                    }
                    return;
                }
                throw new ApplicationException("unexpected");
            }

            ImmediateOperand immOp = (ImmediateOperand) ops[1].Operand;
            EmitOpcode(0xF6 | (isWord & 1), dataWidth);
            EmitModRM(0, ops[0]);
            if (isWord != 0)
                emitter.EmitLeImmediate(immOp.Value, dataWidth);
            else
                emitter.EmitByte(immOp.Value.ToInt32());

            if (ops[1].Symbol != null && isWord != 0)
            {
                ReferToSymbol(ops[1].Symbol!, emitter.Position - 2, PrimitiveType.Word16);
            }
        }

        internal void ProcessUnary(int operation, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            EmitOpcode(0xF6 | IsWordWidth(dataWidth), dataWidth);
            EmitModRM(operation, op);
        }

        private void DefineSymbol(string pstr)
        {
            var sym = symtab.DefineSymbol(pstr, emitter.Position);
            sym.ResolveLe(emitter);
            ResolveSegmentForwardReferences(sym);
            symbolSegments[sym] = currentSegment;
        }

        private void ResolveSegmentForwardReferences(Symbol sym)
        {
            if (symbolSegments.TryGetValue(sym, out AssembledSegment asmSeg))
            {
                currentSegment.Relocations.AddRange(asmSeg.Relocations);
            }
        }

        internal void EmitModRM(int reg, ParsedOperand op)
        {
            switch (op.Operand)
            {
            case RegisterOperand regOp:
                modRm.EmitModRM(reg, regOp);
                return;
            case FpuOperand fpuOp:
                modRm.EmitModRM(reg, fpuOp);
                return;
            case MemoryOperand mem:
                EmitModRM(reg, mem, op.Symbol);
                break;
            default:
                throw new NotImplementedException();
            }
        }

        internal void EmitModRM(int reg, ParsedOperand op, byte b)
        {
            if (op.Operand is RegisterOperand regOp)
            {
                modRm.EmitModRM(reg, regOp);
                emitter.EmitByte(b);
            }
            else
            {
                EmitModRM(reg, (MemoryOperand) op.Operand, b, op.Symbol);
            }
        }

        internal void EmitModRM(int reg, MemoryOperand memOp, Symbol? sym)
        {
            Constant? offset = modRm.EmitModRMPrefix(reg, memOp);
            if (offset is null)
                return;
            int offsetPosition = emitter.Position;
            EmitOffset(offset);
            if (sym != null)
                ReferToSymbol(sym, offsetPosition, offset.DataType);
        }

        internal void EmitModRM(int reg, MemoryOperand memOp, byte b, Symbol? sym)
        {
            Constant? offset = modRm.EmitModRMPrefix(reg, memOp);
            if (offset is null)
                return;
            emitter.EmitByte(b);
            int offsetPosition = emitter.Position;
            EmitOffset(offset);
            if (sym != null)
                ReferToSymbol(sym, emitter.Position, offset.DataType);
        }

        // width of the address of this opcode.
        public PrimitiveType? AddressWidth { get; set; }

        // Default address width for this segment.
        public PrimitiveType SegmentAddressWidth { get; set; }

        // Default data width for this segment.
        public PrimitiveType SegmentDataWidth { get; set; }

        public RegisterStorage SegmentOverride { get; set; }

        private bool IsDataWidthOverridden(PrimitiveType? dataWidth)
        {
            return dataWidth != null &&
                dataWidth.Domain != Domain.Real &&
                dataWidth.Size != 1 &&
                dataWidth != SegmentDataWidth;
        }

		public void EmitOpcode(int b, PrimitiveType? dataWidth)
		{
			if (SegmentOverride != RegisterStorage.None)
			{
				byte bOv;
				if (SegmentOverride == Registers.es) bOv = 0x26; else
				if (SegmentOverride == Registers.cs) bOv = 0x2E; else
				if (SegmentOverride == Registers.ss) bOv = 0x36; else
				if (SegmentOverride == Registers.ds) bOv = 0x3E; else
				if (SegmentOverride == Registers.fs) bOv = 0x64; else
				if (SegmentOverride == Registers.gs) bOv = 0x65; else
				throw new ArgumentOutOfRangeException(string.Format("Invalid segment register {0}." , SegmentOverride));
				emitter.EmitByte(bOv);
				SegmentOverride = RegisterStorage.None;
			}
			if (IsDataWidthOverridden(dataWidth))
			{
				emitter.EmitByte(0x66);
			}
			if (AddressWidth != null && AddressWidth != SegmentAddressWidth)
			{
				emitter.EmitByte(0x67);
			}
			emitter.EmitByte(b);
		}

        private void EmitOffset(Constant v)
        {
            if (v == null)
                return;
            emitter.EmitLe((PrimitiveType) v.DataType, v.ToInt32());
        }

        private Symbol EmitRelativeTarget(string target, PrimitiveType offsetSize)
        {
            int offBytes = (int) offsetSize.Size;
            switch (offBytes)
            {
            case 1: emitter.EmitByte(-(emitter.Position + 1)); break;
            case 2: emitter.EmitLeUInt16(-(emitter.Position + 2)); break;
            case 4: emitter.EmitLeUInt32((uint)-(emitter.Position + 4)); break;
            }
            var sym = symtab.CreateSymbol(target);
            sym.ReferToLe(emitter.Position - offBytes, offsetSize, emitter);
            return sym;
        }

        private void EmitReferenceToSymbolSegment(Symbol sym)
        {
            var seg = GetSymbolSegmentReference(sym);
            seg.Relocations.Add(new AssembledSegment.Relocation(currentSegment, (uint) emitter.Position));
            emitter.EmitLeUInt16(0);            // make space for the segment selector, will be overwritten at relocation time.
        }

        private AssembledSegment GetSymbolSegmentReference(Symbol sym)
        {
            if (symbolSegments.TryGetValue(sym, out AssembledSegment seg))
                return seg;
            seg = new AssembledSegment(emitter, null);
            symbolSegments.Add(sym, seg);
            return seg;
        }

        private PrimitiveType? EnsureValidOperandSizes(ParsedOperand[] ops, int count)
        {
            PrimitiveType? w = ops[0].Operand.Width;
            if (count == 1 && ops[0].Operand.Width == null)
            {
                Error("Width of the first operand is unknown");
                return null;
            }
            if (count == 2)
            {
                if (w is null)
                {
                    w = ops[1].Operand.Width;
                    if (w == null)
                        Error("Width of the first operand is unknown");
                    else
                        ops[0].Operand.Width = w;
                }
                else
                {
                    if (ops[1].Operand.Width == null)
                        ops[1].Operand.Width = w;
                    else if (ops[0].Operand.Width != ops[0].Operand.Width)
                        Error("Operand widths don't match");
                }
            }
            return w;
        }

        private int IsAccumulator(RegisterStorage reg)
        {
            return (reg == Registers.eax || reg == Registers.ax || reg == Registers.al) ? 1 : 0;
        }

        private bool IsSignedByte(int n)
        {
            return -128 <= n && n < 128;
        }


        private int IsWordWidth(MachineOperand op)
        {
            return IsWordWidth(op.Width);
        }

        internal void SetDefaultWordWidth(PrimitiveType width)
        {
            SegmentDataWidth = width;
            SegmentAddressWidth = width;
            modRm = new ModRmBuilder(width, emitter);
            modRm.Error += modRm_Error;
        }

        private void SwitchSegment(AssembledSegment newSegment)
        {
            currentSegment = newSegment;
            emitter = newSegment.Emitter;
            modRm = new ModRmBuilder(defaultWordSize, emitter);
        }


        private int IsWordWidth(PrimitiveType? width)
        {
            if (width is null)
                Error("Operand width is undefined");
            else if (width.Size == 1)
                return 0;
            return 1;
        }

        private bool Error(string pstr)
        {
            throw new ApplicationException(pstr);
        }

        private void ReferToSymbol(Symbol psym, int off, DataType width)
        {
            if (psym.fResolved)
            {
                emitter.PatchLe(off, psym.offset, width);
            }
            else
            {
                psym.AddForwardReference(off, width, 1);
            }
        }

        public static byte RegisterEncoding(RegisterStorage reg)
        {
            return registerEncodings[reg];
        }

        public static Constant IntegralConstant(int i, PrimitiveType? width)
        {
            if (-0x80 <= i && i < 0x80)
                width = PrimitiveType.SByte;
            else if (width == null)
            {
                if (-0x8000 <= i && i < 0x8000)
                    width = PrimitiveType.Word16;
                else
                    width = PrimitiveType.Word32;
            }
            return Constant.Create(width, i);
        }

        public static Constant IntegralConstant(int i)
        {
            PrimitiveType width;
            if (-0x80 <= i && i < 0x80)
                width = PrimitiveType.SByte;
            else if (-0x8000 <= i && i < 0x8000)
                width = PrimitiveType.Word16;
            else
                width = PrimitiveType.Word32;
            return Constant.Create(width, i);
        }


        private void modRm_Error(object sender, ErrorEventArgs args)
        {
            Error(args.Message);
        }

        private static readonly Dictionary<RegisterStorage, byte> registerEncodings = 
            new Dictionary<RegisterStorage, byte>
		{
			{ Registers.eax, 0x00 },
			{ Registers.ecx, 0x01 },
			{ Registers.edx, 0x02 },
			{ Registers.ebx, 0x03 },
			{ Registers.esp, 0x04 },
			{ Registers.ebp, 0x05 },
			{ Registers.esi, 0x06 },
			{ Registers.edi, 0x07 },

			{ Registers.ax, 0x00 },
			{ Registers.cx, 0x01 },
			{ Registers.dx, 0x02 },
			{ Registers.bx, 0x03 },
			{ Registers.sp, 0x04 },
			{ Registers.bp, 0x05 },
			{ Registers.si, 0x06 },
			{ Registers.di, 0x07 },

			{ Registers.al, 0x00 },
			{ Registers.cl, 0x01 },
			{ Registers.dl, 0x02 },
			{ Registers.bl, 0x03 },
			{ Registers.ah, 0x04 },
			{ Registers.ch, 0x05 },
			{ Registers.dh, 0x06 },
			{ Registers.bh, 0x07 },

			{ Registers.es, 0x00 },
			{ Registers.cs, 0x01 },
			{ Registers.ss, 0x02 },
			{ Registers.ds, 0x03 },
			{ Registers.fs, 0x04 },
			{ Registers.gs, 0x05 },
		};
        private Encoding textEncoding;

        public void i386()
        {
            arch = new X86ArchitectureFlat32(arch.Services, "x86-protected-32", new Dictionary<string, object>());
            SetDefaultWordWidth(PrimitiveType.Word32);
        }

        public void i86()
        {
            arch = new X86ArchitectureReal(arch.Services, "x86-real-16", new Dictionary<string, object>());
            SetDefaultWordWidth(PrimitiveType.Word16);
        }

        public void Aaa()
        {
            emitter.EmitByte(0x37);
        }

        public void Aam()
        {
            emitter.EmitByte(0xD4);
            emitter.EmitByte(0x0A);
        }

        public void Call(string destination)
        {
            ProcessCallJmp(false, 0xE8, destination);
        }


        public void Call(ParsedOperand parsedOperand)
        {
            var far = (parsedOperand.Operand is MemoryOperand && parsedOperand.Operand.Width.Size == 4);
            ProcessCallJmp(far, 0x02, parsedOperand);
        }


        public void CallF(string destination)
        {
            ProcessCallJmp(true, 0x9A, destination);
        }


        public void CallF(ParsedOperand parsedOperand)
        {
            ProcessCallJmp(true, 0x03, parsedOperand);
        }

        public void Fadd(ParsedOperand op)
        {
            ProcessFpuCommon(0xD8, 0xD8, 0, false, false, op);
        }

        public void Fiadd(ParsedOperand operand)
        {
            var dataWidth = EnsureValidOperandSize(operand);
            if (dataWidth is null)
                return;
            int opcode;
            switch (dataWidth.Size)
            {
            case 2: opcode = 0xDE; break;
            case 4: opcode = 0xDA; break;
            default: Error(string.Format("Instruction doesn't support {0}-byte operands.", dataWidth.Size)); return;
            }
            EmitOpcode(opcode, dataWidth);
            EmitModRM(0, operand);
        }

        public void Fild(ParsedOperand op)
        {
            var dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            int opCode;
            int reg;
            switch (dataWidth.Size)
            {
            case 2: opCode = 0xDF; reg = 0x00; break;
            case 4: opCode = 0xDB; reg = 0x00; break;
            case 8: opCode = 0xDF; reg = 0x05; break;
            default: Error(string.Format("Instruction doesn't support {0}-byte operands", dataWidth.Size)); return;
            }
            EmitOpcode(opCode, dataWidth);
            EmitModRM(reg, op);
        }

        public void Fistp(ParsedOperand src)
        {
            var dataWidth = EnsureValidOperandSize(src);
            if (dataWidth is null)
                return;
            int opCode;
            int reg;
            switch (dataWidth.Size)
            {
            case 2: opCode = 0xDF; reg = 0x03; break;
            case 4: opCode = 0xDB; reg = 0x03; break;
            case 8: opCode = 0xDF; reg = 0x07; break;
            default: Error(string.Format("Instruction doesn't support {0}-byte operands", dataWidth.Size)); return;
            }
            EmitOpcode(opCode, null);
            EmitModRM(reg, src);
        }

        public void Fld1()
        {
            emitter.EmitByte(0xD9);
            emitter.EmitByte(0xE8);
        }

        public void Fldz()
        {
            EmitOpcode(0xD9, null);
            emitter.EmitByte(0xEE);
        }

        public void Fmul(ParsedOperand op)
        {
            ProcessFpuCommon(0xD8, 0xD8, 1, false, false, op);
        }

        public void Fstsw(ParsedOperand dst)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(dst);
            if (dataWidth is null)
                return;
            if (dst.Operand is RegisterOperand regOp)
            {
                if (regOp.Register != Registers.ax)
                    Error("Register operand must be AX");
                EmitOpcode(0xDF, dataWidth);
                emitter.EmitByte(0xE0);
            }
            if (dst.Operand is MemoryOperand)
            {
                if (dataWidth != PrimitiveType.Word16)
                    Error("Destination must be two bytes");
                EmitOpcode(0xDD, dataWidth);
                EmitModRM(0x07, dst);
            }
        }

        public void Fst(ParsedOperand parsedOperand)
        {
            ProcessFst(false, parsedOperand);
        }

        public void Fstp(ParsedOperand parsedOperand)
        {
            ProcessFst(true, parsedOperand);
        }

        public void Ret()
        {
            EmitOpcode(0xC3, null);
        }

        public void Ret(int n)
        {
            if (n == 0)
            {
                Ret();
            }
            else
            {
                EmitOpcode(0xC2, null);
                emitter.EmitLeUInt16(n);
            }
        }

        public void Retf()
        {
            EmitOpcode(0xCB, null);
        }

        public void Retf(int n)
        {
            if (n == 0)
                Retf();
            else
            {
                EmitOpcode(0xCA, null);
                emitter.EmitLeUInt16(n);
            }
        }

        public void Proc(string procName)
        {
            DefineSymbol(procName);
            //$BUG: should be symbols. the ORG directive specifies the start symbol.
            if (entryPoints != null && entryPoints.Count == 0)
            {
                entryPoints.Add(
                    ImageSymbol.Procedure(arch, addrBase + emitter.Position));
            }
        }

        public void Push(ParsedOperand op)
        {
            ProcessPushPop(false, op);
        }

        public void Pusha()
        {
            emitter.EmitByte(0x60);
        }

        public void Pushf()
        {
            emitter.EmitByte(0x9C);
        }

        public void Popf()
        {
            emitter.EmitByte(0x9D);
        }

        public void Adc(ParsedOperand op, int constant)
        {
            Adc(op, new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant))));
        }

        public void Adc(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessBinop(0x02, op1, op2);
        }

        public void Add(RegisterStorage reg, int constant)
        {
            ProcessBinop(
                0x00,
                new ParsedOperand(new RegisterOperand(reg)),
                new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant))));
        }

        public void Add(ParsedOperand op, int constant)
        {
            ProcessBinop(
                0x00,
                op,
                new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant))));
        }


        public void And(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0x04, dst, src);
        }

        public ParsedOperand Imm( uint constant)
        {
            return Imm((int)constant);
        }

        public ParsedOperand Imm(PrimitiveType width, int constant)
        {
            return new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant, width)));
        }

        public ParsedOperand Imm(int constant)
        {
            return new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant)));
        }

        public ParsedOperand WordPtr(int directOffset)
        {
            return new ParsedOperand(new MemoryOperand(
                PrimitiveType.Word16,
                IntegralConstant(directOffset, AddressWidth)));
        }

        public ParsedOperand WordPtr(ParsedOperand reg, int offset)
        {
            return new ParsedOperand(new MemoryOperand(
                PrimitiveType.Word16,
                ((RegisterOperand) reg.Operand).Register,
                IntegralConstant(offset, AddressWidth)));
        }

        public ParsedOperand DwordPtr(ParsedOperand reg, int offset)
        {
            return new ParsedOperand(new MemoryOperand(
                PrimitiveType.Word32,
                ((RegisterOperand)reg.Operand).Register,
                IntegralConstant(offset, AddressWidth)));
        }

        public void Lea(ParsedOperand dst, ParsedOperand addr)
        {
            RegisterOperand ropLhs = (RegisterOperand) dst.Operand;
            EmitOpcode(0x8D, ropLhs.Width);
            EmitModRM(RegisterEncoding(ropLhs.Register), addr);
        }

        public void ProcessCwd(PrimitiveType width)
        {
            EmitOpcode(0x99, width);
        }

        public void Add(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0, dst, src);
        }

        public void Bswap(ParsedOperand op)
        {
            var reg = ((RegisterOperand)op.Operand).Register;
            EmitOpcode(0x0F, op.Operand.Width);
            emitter.EmitByte(0xC8 | RegisterEncoding(reg));
        }

        public void Dec(ParsedOperand op)
        {
            ProcessIncDec(true, op);
        }

        public void Div(ParsedOperand op)
        {
            ProcessDiv(0x06, op);
        }

        public void Idiv(ParsedOperand op)
        {
            ProcessDiv(0x07, op);
        }

        public void Import(string symbolName, string fnName, string dllName)
        {
            DefineSymbol(symbolName);
            AddImport(dllName, fnName, PrimitiveType.Word32);
        }

        public void Imul(ParsedOperand op)
        {
            ProcessImul(op);
        }

        public void Hlt()
        {
            emitter.EmitByte(0xF4);
        }

        public void Int(int serviceVector)
        {
            ProcessInt(Const(serviceVector));
        }

        public void In(ParsedOperand dst, ParsedOperand port)
        {
            ProcessInOut(false, dst, port);
        }

        public void Inc(ParsedOperand op)
        {
            ProcessIncDec(false, op);
        }

        public void Ja(string destination)
        {
            ProcessShortBranch(0x07, destination);
        }

        public void Jc(string destination)
        {
            ProcessShortBranch(0x02, destination);
        }

        public void Jcxz(string destination)
        {
            EmitOpcode(0xE3, null);
            EmitRelativeTarget(destination, PrimitiveType.Byte);
        }

        public void Jns(string destination)
        {
            ProcessShortBranch(0x09, destination);
        }

        public void Jnz(string destination)
        {
            ProcessShortBranch(0x05, destination);
        }

        public void Jpe(string destination)
        {
            ProcessShortBranch(0x0A, destination);
        }

        public void Jpo(string destination)
        {
            ProcessShortBranch(0x0B, destination);
        }

        public void Jz(string destination)
        {
            ProcessShortBranch(0x04, destination);
        }

        public void Jmp(string destination)
        {
            ProcessCallJmp(false, 0xE9, destination);
        }

        public void Jmp(ParsedOperand parsedOperand)
        {
            ProcessCallJmp(false, 0x04, parsedOperand);
        }

        public void JmpF(Address address)
        {
            emitter.EmitByte(0xEA);
            emitter.EmitLeUInt16((ushort)address.Offset);
            emitter.EmitLeUInt16(address.Selector!.Value);
        }

        public X86Assembler Label(string label)
        {
            DefineSymbol(label);
            return this;
        }

        public void Endp(string p)
        {
        }

        public void Ends()
        {
            SwitchSegment(unknownSegment);
        }


        public void Enter(int cbStack, int nLevel)
        {
            EmitOpcode(0xC8, null);
            emitter.EmitLeUInt16(cbStack);
            emitter.EmitByte(nLevel);
        }

        public void Equ(string s, int value)
        {
            symtab.Equates[s] = value;
        }

        internal void Extern(string externSymbol, PrimitiveType size)
        {
            DefineSymbol(externSymbol);
            AddImport(null, externSymbol, size);
        }

        public void Neg(ParsedOperand op)
        {
            ProcessUnary(0x03, op);
        }

        public void Not(ParsedOperand op)
        {
            ProcessUnary(0x02, op);
        }

        public void Or(ParsedOperand opDst, ParsedOperand opSrc)
        {
            ProcessBinop(0x01, opDst, opSrc);
        }

        public void Out(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessInOut(true, op1, op2);
        }

        public void Pop(ParsedOperand op)
        {
            ProcessPushPop(true, op);
        }

        internal void ProcessBinop(int binop, params ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;
            if (ops[1].Operand is ImmediateOperand immOp)
            {
                int imm = immOp.Value.ToInt32();
                if (ops[0].Operand is RegisterOperand regOpDst && IsAccumulator(regOpDst.Register) != 0)
                {
                    EmitOpcode((binop << 3) | 0x04 | IsWordWidth(ops[0].Operand), dataWidth);
                    emitter.EmitLeImmediate(immOp.Value, dataWidth);
                    return;
                }

                switch (dataWidth.Size)
                {
                default:
                    Error("Must specify operand width");
                    return;
                case 1:
                    EmitOpcode(0x80, dataWidth);
                    EmitModRM(binop, ops[0]);
                    emitter.EmitByte(imm);
                    break;
                case 2:
                case 4:
                    if (IsSignedByte(imm))
                    {
                        EmitOpcode(0x83, dataWidth);
                        EmitModRM(binop, ops[0]);
                        emitter.EmitByte(imm);
                    }
                    else
                    {
                        EmitOpcode(0x81, dataWidth);
                        EmitModRM(binop, ops[0]);
                        emitter.EmitLeImmediate(immOp.Value, dataWidth);
                    }
                    break;
                }
                return;
            }

            if (ops[0].Operand is MemoryOperand)
            {
                RegisterOperand regOpSrc = (RegisterOperand) ops[1].Operand;
                EmitOpcode((binop << 3) | 0x00 | IsWordWidth(ops[1].Operand), dataWidth);
                EmitModRM(RegisterEncoding(regOpSrc.Register), ops[0]);
            }
            else
            {
                RegisterOperand regOpDst = (RegisterOperand) ops[0].Operand;
                EmitOpcode((binop << 3) | 0x02 | IsWordWidth(regOpDst), dataWidth);
                EmitModRM(RegisterEncoding(regOpDst.Register), ops[1]);
            }
        }

        internal void ProcessBitOp(ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(ops[0]);
            if (dataWidth is null)
                return;

            if (ops[1].Operand is ImmediateOperand imm2)
            {
                EmitOpcode(0x0F, dataWidth);
                emitter.EmitByte(0xBA);
                EmitModRM(0x04, ops[0]);
                emitter.EmitByte(imm2.Value.ToInt32());
            }
            else
            {
                EmitOpcode(0x0F, dataWidth);
                emitter.EmitByte(0xA3);
                EmitModRM(RegisterEncoding(((RegisterOperand) ops[1].Operand).Register), ops[0]);
            }
        }

        internal void ProcessBitScan(byte opCode, ParsedOperand dst, ParsedOperand src)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(src);
            if (dataWidth is null)
                return;

            if (!(dst.Operand is RegisterOperand regDst))
            {
                Error("First operand of bit scan instruction must be a register");
                return;
            }
            EmitOpcode(0x0F, dataWidth);
            emitter.EmitByte(opCode);
            EmitModRM(RegisterEncoding(regDst.Register), src);
        }

        internal void ProcessCallJmp(bool far, int direct, string destination)
        {
            EmitOpcode(direct, null);
            if (far)
            {
                var sym = symtab.CreateSymbol(destination);
                sym.ReferToLe(emitter.Position, SegmentAddressWidth, emitter);

                emitter.EmitLe(SegmentAddressWidth, 0);

                EmitReferenceToSymbolSegment(sym);
            }
            else
            {
                EmitRelativeTarget(destination, SegmentAddressWidth);
            }
        }

        internal void ProcessCallJmp(bool far, int indirect, ParsedOperand op)
        {
            if (far) indirect |= 1;
            EmitOpcode(0xFF, SegmentDataWidth);
            EmitModRM(indirect, op);
        }

        internal void ProcessDiv(int operation, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;

            EmitOpcode(0xF6 | IsWordWidth(dataWidth), dataWidth);
            EmitModRM(operation, op);
        }

        internal void ProcessDoubleShift(byte bits, ParsedOperand op0, ParsedOperand op1, ParsedOperand count)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op0);
            if (dataWidth is null)
                return;

            if (!(op1.Operand is RegisterOperand regSrc))
            {
                Error("Second operand of SHLD/SHRD must be a register");
                return;
            }

            ImmediateOperand? immShift = count.Operand as ImmediateOperand;
            if (count.Operand is RegisterOperand regShift && regShift.Register == Registers.cl)
            {
                bits |= 0x01;
            }
            else if (immShift is null)
            {
                Error("SHLD/SHRD instruction must be followed by a constant or CL");
            }

            EmitOpcode(0x0F, dataWidth);
            emitter.EmitByte(0xA4 | bits);
            EmitModRM(RegisterEncoding(regSrc.Register), op0);
            if (immShift != null)
                emitter.EmitByte((byte) immShift.Value.ToUInt32());
        }

        public void AddImport(string? moduleName, string fnName,  PrimitiveType size)
        {
            Address u =  (addrBase + emitter.Position);
            ImportReferences.Add(u, new NamedImportReference(u, Path.GetFileNameWithoutExtension(moduleName), fnName, SymbolType.ExternalProcedure));
            emitter.EmitLe(size, 0);
        }

        internal OperandParser CreateOperandParser(Lexer lexer)
        {
            return new OperandParser(lexer, symtab, addrBase, SegmentDataWidth, SegmentAddressWidth);
        }


        internal void DefineWord(PrimitiveType width, string symbolText)
        {
            Symbol sym = symtab.CreateSymbol(symbolText);
            emitter.EmitLe(width, (int)addrBase.Offset);
            ReferToSymbol(sym, emitter.Position - (int) width.Size, SegmentAddressWidth);
        }

        internal void DefineWord(PrimitiveType width, int value)
        {
            emitter.EmitLe(width, value);
        }

        internal void ReportUnresolvedSymbols()
        {
            Symbol[] s = symtab.GetUndefinedSymbols();
            if (s.Length > 0)
            {
                StringWriter writer = new StringWriter();
                writer.WriteLine("The following symbols were undefined:");
                for (int i = 0; i < s.Length; ++i)
                {
                    writer.WriteLine("  {0}", s[i].ToString());
                }
                throw new ApplicationException(writer.ToString());
            }
        }

        public void Bsr(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBitScan(0xBD, dst, src);
        }

        public void Clc()
        {
            EmitOpcode(0xF8, null);
        }

        public void Cld()
        {
            EmitOpcode(0xFC, null);
        }

        public void Cmc()
        {
            EmitOpcode(0xF5, null);
        }

        public void Cmp(ParsedOperand dst, int src)
        {
            ProcessBinop(0x7, dst, Imm(src));
        }

        public void Cmp(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0x7, dst, src);
        }

        public void Db(params byte[] bytes)
        {
            for (int i = 0; i < bytes.Length; ++i)
            {
                emitter.EmitByte(bytes[i]);
            }
        }

        public void Db(int b)
        {
            emitter.EmitByte(b);
        }

        internal void Dstring(string str)
        {
            emitter.EmitString(str, textEncoding);
        }

        public void Dw(int w)
        {
            emitter.EmitByte(w & 0xFF);
            emitter.EmitByte(w >> 8);
        }

        public void Dw(string symbolText)
        {
            DefineWord(PrimitiveType.Word16, symbolText);
        }

        public void Dd(params string[] symbols)
        {
            foreach (string sym in symbols)
            {
                DefineWord(PrimitiveType.Word32, sym);
            }
        }

        public void Dd(params int[] values)
        {
            foreach (int n in values)
            {
                DefineWord(PrimitiveType.Word32, n);
            }
        }

        public void Repeat(int count, Action<X86Assembler> action)
        {
            for (int i = 0; i < count; ++i)
                action(this);
        }

        internal void Leave()
        {
            EmitOpcode(0xC9, null);
        }

        public void Les(ParsedOperand dst, ParsedOperand src)
        {
            ProcessLxs(-1, 0xC4, dst, src);
        }

        public void Loop(string target)
        {
            ProcessLoop(2, target);
        }

        public void Loope(string target)
        {
            ProcessLoop(1, target);
        }

        public void Loopne(string target)
        {
            ProcessLoop(0, target);
        }

        public void Rep()
        {
            emitter.EmitByte(0xF3);
        }

        public void Repne()
        {
            emitter.EmitByte(0xF2);
        }

        public void Lodsb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Load, PrimitiveType.Byte);
        }
        public void Lodsw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Load, PrimitiveType.Word16);
        }
        public void Lodsd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Load, PrimitiveType.Word32);
        }

        public void Stosb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Store, PrimitiveType.Byte);
        }
        public void Stosw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Store, PrimitiveType.Word16);
        }
        public void Stosd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Store, PrimitiveType.Word32);
        }

        public void Movsb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Move, PrimitiveType.Byte);
        }
        public void Movsw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Move, PrimitiveType.Word16);
        }
        public void Movsd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Move, PrimitiveType.Word32);
        }

        public void Scasb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Scan, PrimitiveType.Byte);
        }
        public void Scasw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Scan, PrimitiveType.Word16);
        }
        public void Scasd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Scan, PrimitiveType.Word32);
        }

        public void Cmpsb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Compare, PrimitiveType.Byte);
        }
        public void Cmpsw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Compare, PrimitiveType.Word16);
        }
        public void Cmpsd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Compare, PrimitiveType.Word32);
        }

        public ParsedOperand St(int n)
        {
            return new ParsedOperand(new FpuOperand(n));
        }

        public void Stc()
        {
            EmitOpcode(0xF9, null);
        }

        public void Std()
        {
            EmitOpcode(0xFD, null);
        }

        public void Fcompp()
        {
            emitter.EmitByte(0xDE);
            emitter.EmitByte(0xD9);
        }


        internal void DbDup(int by, int count)
        {
            emitter.EmitBytes((byte) by, count);
        }

        internal void Xchg(ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;
            ParsedOperand otherOp = ops[1];
            if (!(ops[0].Operand is RegisterOperand regOp))
            {
                if (!(ops[1].Operand is RegisterOperand regOp2))
                {
                    Error("One operand must be a register.");
                    return;
                }
                regOp = regOp2;
                otherOp = ops[0];
            }
            EmitOpcode(0x86 | IsWordWidth(regOp), dataWidth);
            EmitModRM(RegisterEncoding(regOp.Register), otherOp);
        }

        public void Xor(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0x06, dst, src);
        }

        public ParsedOperand ax
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ax)); }
        }

        public ParsedOperand bx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bx)); }
        }

        public ParsedOperand cx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.cx)); }
        }

        public ParsedOperand dx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.dx)); }
        }

        public ParsedOperand si
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.si)); }
        }

        public ParsedOperand di
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.di)); }
        }

        public ParsedOperand sp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.sp)); }
        }

        public ParsedOperand bp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bp)); }
        }

        public ParsedOperand al
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.al)); }
        }

        public ParsedOperand cl
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.cl)); }
        }

        public ParsedOperand dl
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.dl)); }
        }

        public ParsedOperand bl
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bl)); }
        }

        public ParsedOperand ah
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ah)); }
        }

        public ParsedOperand bh
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bh)); }
        }

        public ParsedOperand eax
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.eax)); }
        }

        public ParsedOperand ebx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ebx)); }
        }

        public ParsedOperand ecx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ecx)); }
        }

        public ParsedOperand edx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.edx)); }
        }

        public ParsedOperand ebp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ebp)); }
        }

        public ParsedOperand esp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.esp)); }
        }

        public ParsedOperand esi
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.esi)); }
        }

        public ParsedOperand edi
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.edi)); }
        }

        public ParsedOperand cs
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.cs)); }
        }

        public ParsedOperand ds
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ds)); }
        }

        public ParsedOperand es
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.es)); }
        }

        public ParsedOperand Const(int n)
        {
            return new ParsedOperand(new ImmediateOperand(IntegralConstant(n, this.defaultWordSize)));
        }

        public ParsedOperand MemW(RegisterStorage seg, RegisterStorage @base, int offset)
        {
            var mem = new MemoryOperand(PrimitiveType.Word16);
            mem.Base = @base;
            mem.Offset = IntegralConstant(offset);
            mem.SegOverride = seg;
            return new ParsedOperand(mem);
        }


        public ParsedOperand MemDw(RegisterStorage @base, int scale, string offset)
        {
            return Mem(PrimitiveType.Word32, null, @base, null, scale, offset);
        }

        public ParsedOperand MemDw(RegisterStorage @base, RegisterStorage index, int scale, string offset)
        {
            return Mem(PrimitiveType.Word32, null, @base, index, scale, offset);
        }

        public ParsedOperand MemDw(string offset)
        {
            return Mem(PrimitiveType.Word32, null, null, null, 1, offset);
        }

        public ParsedOperand MemDw(object @base, string offset)
        {
            RegisterStorage reg = ExpectRegister(@base);
            return Mem(PrimitiveType.Word32, null, reg, null, 1, offset);
        }

        private static RegisterStorage ExpectRegister(object @base)
        {
            var reg = @base as RegisterStorage;
            if (reg == null)
            {
                var op = (ParsedOperand)@base;
                reg = ((RegisterOperand)op.Operand).Register;
            }
            return reg;
        }

        public ParsedOperand MemW(RegisterStorage @base, string offset)
        {
            return Mem(PrimitiveType.Word16, null, @base, null, 1, offset);
        }

        public ParsedOperand MemB(RegisterStorage @base, string offset)
        {
            return Mem(PrimitiveType.Byte, null, @base, null, 1, offset);
        }

        public ParsedOperand MemW(RegisterStorage seg, RegisterStorage @base, string offset)
        {
            return Mem(PrimitiveType.Word16, seg, @base, null, 1, offset);
        }

        public ParsedOperand MemDw(object @base, int offset)
        {
            return Mem(PrimitiveType.Word32, ExpectRegister(@base), offset);
        }

        public ParsedOperand MemW(RegisterStorage @base, int offset)
        {
            return Mem(PrimitiveType.Word16, @base, offset);
        }

        public ParsedOperand MemB(RegisterStorage @base, int offset)
        {
            return Mem(PrimitiveType.Byte, @base, offset);
        }

        public ParsedOperand MemB(int offset)
        {
            return Mem(PrimitiveType.Byte, RegisterStorage.None, offset);
        }

        private ParsedOperand Mem(
            PrimitiveType width, 
            RegisterStorage? seg, 
            RegisterStorage? @base,  
            RegisterStorage? index, 
            int scale, 
            string offset)
        {
            MemoryOperand mem;
            Symbol? sym = null;
            if (offset != null)
            {
                if (symtab.Equates.TryGetValue(offset, out int val))
                {
                    mem = new MemoryOperand(width, @base ?? RegisterStorage.None, IntegralConstant(val, @base!.DataType));
                    sym = null;
                }
                else
                {
                    sym = symtab.CreateSymbol(offset);
                    val = (int)this.addrBase.Offset;
                    Constant off = Constant.Create(@base == null
                        ? seg != null ? PrimitiveType.Word16 : PrimitiveType.Word32
                        : @base.DataType,
                        val);
                    mem = new MemoryOperand(width, @base ?? RegisterStorage.None, off);
                }
            }
            else
            {
                mem = new MemoryOperand(width)
                {
                };
            }
            if (seg != null)
            {
                mem.SegOverride = seg;
                this.SegmentOverride = seg;
            }
            mem.Scale = (byte)scale;
            if (scale > 1)
            {
                if (index is null)
                {
                    mem.Index = mem.Base;
                    mem.Base = RegisterStorage.None;
                }
                else
                {
                    mem.Index = index;
                    mem.Base = @base!;
                }
            }
            return new ParsedOperand(mem, sym);
        }

        private ParsedOperand Mem(PrimitiveType width, RegisterStorage @base, int offset)
        {
            return new ParsedOperand(
                new MemoryOperand(width, @base, IntegralConstant(offset)));
        }

        public void Segment(string segmentName)
        {
            AssembledSegment seg;
            if (!mpNameToSegment.TryGetValue(segmentName, out seg))
            {
                var sym = symtab.DefineSymbol(segmentName, 0);
                seg = new AssembledSegment(new Emitter(), sym);
                segments.Add(seg);
            }
            SwitchSegment(seg);
        }

        public void Xlat()
        {
            emitter.EmitByte(0xD7);
        }
    }
}


---- Transformed Tree ----
using Reko.Arch.X86;
using Reko.Core;
using Reko.Core.Assemblers;
using Reko.Core.Expressions;
using Reko.Core.Machine;
using Reko.Core.Types;
using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Linq;
using Reko.Core.Memory;

namespace Reko.Arch.X86.Assembler
{
    /// <summary>
    /// A crude MASM-style assembler for x86 instructions.
    /// </summary>
    public class X86Assembler
    {
        enum StringInstructionBaseOps : byte
        {
            Move = 0xA4,
            Compare = 0xA6,
            Store = 0xAA,
            Load = 0xAC,
            Scan = 0xAE,
        }
        private readonly Address addrBase;
        private readonly PrimitiveType defaultWordSize;
        private readonly AssembledSegment unknownSegment;
        private readonly SymbolTable symtab;
        private readonly List<ImageSymbol> entryPoints;
        private readonly Dictionary<Address, ImportReference> importReferences;
        private readonly List<AssembledSegment> segments;
        private readonly Dictionary<string, AssembledSegment> mpNameToSegment;
        private readonly Dictionary<Symbol, AssembledSegment> symbolSegments;        // The segment to which a symbol belongs.
        private IProcessorArchitecture arch;
        private ModRmBuilder modRm;
        private IEmitter emitter;
        private AssembledSegment currentSegment;

#nullable disable
        public X86Assembler(IntelArchitecture arch, Address addrBase, List<ImageSymbol> entryPoints)
        {
            this.arch = arch;
            this.addrBase = addrBase;
            this.entryPoints = entryPoints;
            this.defaultWordSize = arch.WordWidth;
            this.textEncoding = Encoding.GetEncoding("ISO_8859-1");
            symtab = new SymbolTable();
            importReferences = new Dictionary<Address, ImportReference>();
            segments = new List<AssembledSegment>();
            mpNameToSegment = new Dictionary<string, AssembledSegment>();
            symbolSegments = new Dictionary<Symbol, AssembledSegment>();
            this.SegmentOverride = RegisterStorage.None;

            unknownSegment = new AssembledSegment(new Emitter(), symtab.DefineSymbol("", 0));
            segments.Add(unknownSegment);

            SwitchSegment(unknownSegment);

            SetDefaultWordWidth(defaultWordSize);
        }

        /// <summary>
        /// This constructor makes an X86Assembler that modifies an existing chunk of memory.
        /// It is intended for small mutations of code (like patching NOPs over unwanted code).
        /// It should not be used for generation of large amounts of code.
        /// </summary>
        /// <param name="program">Program to mutate.</param>
        /// <param name="addrStart">The address at which to start mutating.</param>
        public X86Assembler(Program program, Address addrStart)
        {
            this.arch = (IntelArchitecture) program.Architecture;
            this.addrBase = program.SegmentMap.BaseAddress;
            this.entryPoints = program.EntryPoints.Values.ToList();
            this.defaultWordSize = arch.WordWidth;
            this.textEncoding = Encoding.GetEncoding("ISO_8859-1");
            symtab = new SymbolTable();
            importReferences = program.ImportReferences;
            mpNameToSegment = new Dictionary<string, AssembledSegment>();
            symbolSegments = new Dictionary<Symbol, AssembledSegment>();
            this.SegmentOverride = RegisterStorage.None;
            segments = program.SegmentMap.Segments.Values
                .Select(seg => new AssembledSegment(new Emitter(seg.MemoryArea), new Symbol(seg.Name)))
                .ToList();
            if (!program.SegmentMap.TryFindSegment(addrStart, out var segmentToMutate))
                throw new InvalidOperationException($"Address {addrStart} is not a valid location in the program.");
            var offset = addrStart - segmentToMutate.MemoryArea.BaseAddress;
            var asmSeg = this.segments.Single(seg => seg.Symbol!.sym == segmentToMutate.Name);
            asmSeg.Emitter.Position = (int)offset;
            SwitchSegment(asmSeg);
            SetDefaultWordWidth(defaultWordSize);
        }
#nullable enable

        public int CurrentPosition => this.emitter.Position;

        public Dictionary<Address, ImportReference> ImportReferences
        {
            get { return importReferences; }
        }

        /// <summary>
        /// Extracts the assembled machine code into a <see cref="Program"/> instance.
        /// </summary>
        /// <remarks>
        /// Callers must provide their own <see cref="IPlatform"/> instance.
        /// </remarks>
        public Program GetImage()
        {
            var stm = new MemoryStream();
            LoadSegments(stm);
            var mem = new ByteMemoryArea(addrBase, stm.ToArray());
            RelocateSegmentReferences(mem);
            return new Program(
                new SegmentMap(
                    mem.BaseAddress,
                    new ImageSegment("code", mem, AccessMode.ReadWriteExecute)),
                arch,
                null);
        }

        private void LoadSegments(MemoryStream stm)
        {
            foreach (var seg in segments)
            {
                while ((stm.Position & 0xF) != 0)
                {
                    stm.WriteByte(0x90);        // 1-byte NOP instruction.
                }
                
                ushort sel;
                if (addrBase.Selector.HasValue)
                    sel = (ushort)(this.addrBase.Selector.Value + (stm.Position >> 4));
                else
                    sel = 0;
                seg.Selector = sel;
                var ab = seg.Emitter.GetBytes();
                stm.Write(ab, 0, ab.Length);
            }
        }

        private void RelocateSegmentReferences(ByteMemoryArea bmem)
        {
            foreach (var seg in segments)
            {
                foreach (var reloc in seg.Relocations)
                {
                    bmem.WriteLeUInt16((uint)((reloc.Segment.Selector - addrBase.Selector!.Value) * 16u + reloc.Offset), seg.Selector);
                }
            }
        }

        public void Align(int alignment)
        {
            emitter.Align(0, alignment);
        }

        public void Mov(ParsedOperand op, int constant)
        {
            ProcessMov(
                op,
                Imm(op.Operand.Width, constant));
        }


        public void Mov(ParsedOperand dst, ParsedOperand src)
        {
            ProcessMov(dst, src);
        }

        public void Rcl(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x02, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Rcr(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x03, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Rol(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x00, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Ror(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x01, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Sahf()
        {
            emitter.EmitByte(0x9E);
        }

        public void Sar(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x07, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Sar(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessShiftRotation(0x7, op1, op2);
        }

        public void Shl(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x04, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Shr(ParsedOperand dst, byte c)
        {
            ProcessShiftRotation(0x05, dst, new ParsedOperand(new ImmediateOperand(Constant.Byte(c))));
        }

        public void Shr(ParsedOperand dst, ParsedOperand sh)
        {
            ProcessShiftRotation(0x05, dst, sh);
        }

        public void Shld(ParsedOperand op1, ParsedOperand op2, ParsedOperand op3)
        {
            ProcessDoubleShift(0, op1, op2, op3);
        }

        public void Shrd(ParsedOperand op1, ParsedOperand op2, byte count)
        {
            ProcessDoubleShift(8, op1, op2, new ParsedOperand(ImmediateOperand.Byte(count)));
        }

        public void Sub(ParsedOperand op, int constant)
        {
            Sub(op, Imm(op.Operand.Width, constant));
        }

        public void Sub(ParsedOperand minuend, ParsedOperand subtrahend)
        {
            ProcessBinop(0x05, minuend, subtrahend);
        }

        public void Test(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessTest( op1, op2 );
        }

        public void Test(ParsedOperand op1, int imm)
        {
            ProcessTest(op1, Imm(imm));
        }

        public ParsedOperand BytePtr(int offset)
        {
            AddressWidth = SegmentAddressWidth;
            return new ParsedOperand(
                new MemoryOperand(PrimitiveType.Byte, Constant.Create(AddressWidth, offset)));
        }

        internal PrimitiveType? EnsureValidOperandSize(ParsedOperand op)
        {
            PrimitiveType w = op.Operand.Width;
            if (w is null)
                Error("Width of the operand is unknown");
            return w;
        }

        internal void ProcessComm(string sym)
        {
            DefineSymbol(sym);
            emitter.EmitLeUInt32(0);
        }

        internal void ProcessFpuCommon(int opcodeFreg, int opcodeMem, int fpuOperation, bool isPop, bool fixedOrder, params ParsedOperand[] ops)
        {
            if (ops.Length == 0)
            {
                ops = new ParsedOperand[] { new ParsedOperand(new FpuOperand(0)), new ParsedOperand(new FpuOperand(1)) };
            }
            else if (ops.Length == 1 && ops[0].Operand is FpuOperand)
            {
                ops = new ParsedOperand[] { new ParsedOperand(new FpuOperand(0)), ops[0] };
            }
            FpuOperand? fop2 = ops.Length > 1 ? ops[1].Operand as FpuOperand : null;
            if (mop == null && ops.Length > 1)
                mop = ops[1].Operand as MemoryOperand;

            if (ops[0].Operand is MemoryOperand mop)
            {
                EmitOpcode(opcodeMem | (mop.Width == PrimitiveType.Word64 ? 4 : 0), null);
                EmitModRM(fpuOperation, mop, null);
                return;
            }
            if (isPop)
            {
                if (fop1 is null)
                {
                    Error("First operand must be of type ST(n)");
                    return;
                }
                EmitOpcode(opcodeFreg, null);
                if (fixedOrder)
                    fpuOperation ^= 1;
                if (fop1.StNumber == 0)
                    EmitModRM(fpuOperation, new ParsedOperand(fop2!, null));
                else
                    EmitModRM(fpuOperation, new ParsedOperand(fop1, null));
                return;
            }

            if (ops[0].Operand is FpuOperand fop1)
            {
                fop2 = (FpuOperand) ops[1].Operand;
                if (fop1.StNumber != 0)
                {
                    if (fop2.StNumber != 0)
                        Error("at least one of the floating point stack arguments must be ST(0)");
                    if (fixedOrder)
                        fpuOperation ^= 1;
                    fop2 = fop1;
                }
                EmitOpcode(opcodeFreg, null);
                EmitModRM(fpuOperation, new ParsedOperand(fop2, null));
                return;
            }
            throw new NotImplementedException("NYI");
        }

        internal void ProcessFst(bool pop, ParsedOperand operand)
        {
            int regBits = pop ? 3 : 2;
            if (operand.Operand is MemoryOperand mop)
            {
                switch (mop.Width.Size)
                {
                case 4: EmitOpcode(0xD9, null); break;
                case 8: EmitOpcode(0xDD, null); break;
                default: Error("Unexpected operator width"); break;
                }
                EmitModRM(regBits, operand);
            }
            else if (operand.Operand is FpuOperand fop)
            {
                EmitOpcode(0xDD, null);
                EmitModRM(regBits, new ParsedOperand(fop, null));
            }
            else
                Error("Unexpected operator type");
        }


        public void ProcessImul(params ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth;
            if (ops.Length == 1)
            {
                dataWidth = EnsureValidOperandSize(ops[0]);
                EmitOpcode(0xF6 | IsWordWidth(ops[0].Operand), dataWidth);
                EmitModRM(0x05, ops[0]);
            }
            else
            {
                dataWidth = EnsureValidOperandSizes(ops, 2);
                if (dataWidth is null)
                    return;
                if (!(ops[0].Operand is RegisterOperand regOp))
                    throw new ApplicationException("First operand must be a register");
                if (IsWordWidth(regOp) == 0)
                    throw new ApplicationException("Destination register must be word-width");

                if (ops.Length == 2)
                {
                    EmitOpcode(0x0F, dataWidth);
                    emitter.EmitByte(0xAF);
                    EmitModRM(RegisterEncoding(regOp.Register), ops[1]);
                }
                else
                {
                    if (!(ops[2].Operand is ImmediateOperand op3))
                        throw new ApplicationException("Third operand must be an immediate value");
                    if (IsSignedByte(op3.Value.ToInt32()))
                    {
                        EmitOpcode(0x6B, dataWidth);
                        EmitModRM(RegisterEncoding(regOp.Register), ops[1]);
                        emitter.EmitByte(op3.Value.ToInt32());
                    }
                    else
                    {
                        EmitOpcode(0x69, dataWidth);
                        EmitModRM(RegisterEncoding(regOp.Register), ops[1]);
                        emitter.EmitLeImmediate(op3.Value, dataWidth);
                    }
                }
            }
        }

        internal void ProcessIncDec(bool fDec, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            if (op.Operand is RegisterOperand regOp)
            {
                if (IsWordWidth(dataWidth) != 0)
                {
                    EmitOpcode((fDec ? 0x48 : 0x40) | RegisterEncoding(regOp.Register), dataWidth);
                }
                else
                {
                    EmitOpcode(0xFE | IsWordWidth(dataWidth), dataWidth);
                    EmitModRM(fDec ? 1 : 0, op);
                }
                return;
            }

            if (op.Operand is MemoryOperand memOp)
            {
                EmitOpcode(0xFE | IsWordWidth(dataWidth), dataWidth);
                EmitModRM(fDec ? 1 : 0, op);
            }
            else
            {
                throw new ApplicationException("constant operator illegal");
            }
        }

        public void ProcessInOut(bool fOut, params ParsedOperand[] ops)
        {
            ParsedOperand opPort;
            ParsedOperand opData;

            if (fOut)
            {
                opPort = ops[0];
                opData = ops[1];
            }
            else
            {
                opData = ops[0];
                opPort = ops[1];
            }

            if (!(opData.Operand is RegisterOperand regOpData) || IsAccumulator(regOpData.Register) == 0)
                throw new ApplicationException("Invalid register for in or out instruction.");

            int opcode = IsWordWidth(regOpData) | (fOut ? 0xE6 : 0xE4);

            if (opPort.Operand is RegisterOperand regOpPort)
            {
                if (regOpPort.Register == Registers.dx || regOpPort.Register == Registers.edx)
                {
                    EmitOpcode(8 | opcode, regOpPort.Width);
                }
                else
                    throw new ApplicationException("port must be specified with 'immediate', dx, or edx register");
                return;
            }

            if (opPort.Operand is ImmediateOperand immOp)
            {
                if (immOp.Value.ToUInt32() > 0xFF)
                {
                    throw new ApplicationException("port number must be between 0 and 255");
                }
                else
                {
                    emitter.EmitByte(opcode);
                    emitter.EmitByte(immOp.Value.ToInt32());
                }
            }
            else
            {
                throw new ApplicationException("port must be specified with 'immediate', dx, or edx register");
            }
        }

        internal void ProcessInt(ParsedOperand vector)
        {
            ImmediateOperand op = (ImmediateOperand) vector.Operand;
            EmitOpcode(0xCD, null);
            emitter.EmitByte(op.Value.ToInt32());
        }


        internal void ProcessLongBranch(int cc, string destination)
        {
            EmitOpcode(0x0F, null);
            emitter.EmitByte(0x80 | cc);
            EmitRelativeTarget(destination, SegmentAddressWidth);
        }

        internal void ProcessLoop(int opcode, string destination)
        {
            EmitOpcode(0xE0 | opcode, null);
            emitter.EmitByte(-(emitter.Position + 1));
            ReferToSymbol(symtab.CreateSymbol(destination),
                emitter.Position - 1, PrimitiveType.Byte);
        }

        public void ProcessLxs(int prefix, int b, params ParsedOperand[] ops)
        {
            RegisterOperand opDst = (RegisterOperand) ops[0].Operand;

            if (prefix > 0)
            {
                EmitOpcode(prefix, opDst.Width);
                emitter.EmitByte(b);
            }
            else
                EmitOpcode(b, SegmentDataWidth);
            EmitModRM(RegisterEncoding(opDst.Register), ops[1]);
        }

        internal void ProcessMov(params ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;

            if (ops[0].Operand is RegisterOperand regOpDst)	//$BUG: what about segment registers?
            {
                byte reg = RegisterEncoding(regOpDst.Register);
                if (IsSegmentRegister(regOpDst.Register))
                {
                    if (ops[1].Operand is RegisterOperand regOpSrc)
                    {
                        if (IsSegmentRegister(regOpSrc.Register ))
                            Error("Cannot assign between two segment registers");
                        if (ops[1].Operand.Width != PrimitiveType.Word16)
                            Error(string.Format("Values assigned to/from segment registers must be 16 bits wide"));
                        EmitOpcode(0x8E, PrimitiveType.Word16);
                        EmitModRM(reg, ops[1]);
                        return;
                    }
                    if (ops[1].Operand is MemoryOperand mopSrc)
                    {
                        EmitOpcode(0x8E, PrimitiveType.Word16);
                        EmitModRM(reg, mopSrc, ops[1].Symbol);
                        return;
                    }
                }

                if (ops[1].Operand is RegisterOperand regOpSrc && IsSegmentRegister(regOpSrc.Register))
                {
                    if (IsSegmentRegister(regOpDst.Register))
                        Error("Cannot assign between two segment registers");
                    if (ops[0].Operand.Width != PrimitiveType.Word16)
                        Error(string.Format("Values assigned to/from segment registers must be 16 bits wide"));
                    EmitOpcode(0x8C, PrimitiveType.Word16);
                    EmitModRM(RegisterEncoding(regOpSrc.Register), ops[0]);
                    return;
                }

                int isWord = IsWordWidth(regOpDst);
                if (ops[1].Operand is RegisterOperand regOpSrc)
                {
                    if (regOpSrc.Width != regOpDst.Width)
                        this.Error(string.Format("size mismatch between {0} and {1}", regOpSrc.Register, regOpDst.Register));
                    EmitOpcode(0x8A | (isWord & 1), dataWidth);
                    modRm.EmitModRM(reg, regOpSrc);
                    return;
                }

                if (ops[1].Operand is MemoryOperand memOpSrc)
                {
                    EmitOpcode(0x8A | (isWord & 1), dataWidth);
                    EmitModRM(reg, memOpSrc, ops[1].Symbol);
                    return;
                }

                if (ops[1].Operand is ImmediateOperand immOpSrc)
                {
                    EmitOpcode(0xB0 | (isWord << 3) | reg, dataWidth);
                    if (isWord != 0)
                        emitter.EmitLe(dataWidth, immOpSrc.Value.ToInt32());
                    else
                        emitter.EmitByte(immOpSrc.Value.ToInt32());

                    if (ops[1].Symbol != null && isWord != 0)
                    {
                        ReferToSymbol(ops[1].Symbol!, emitter.Position - (int) immOpSrc.Width.Size, immOpSrc.Width);
                    }
                    return;
                }
                throw new ApplicationException("unexpected");
            }

            MemoryOperand memOpDst = (MemoryOperand) ops[0].Operand;
            regOpSrc = ops[1].Operand as RegisterOperand;

            if (ops[1].Operand is RegisterOperand regOpSrc)
            {
                if (IsSegmentRegister(regOpSrc.Register))
                {
                    EmitOpcode(0x8C, PrimitiveType.Word16);
                }
                else
                {
                    EmitOpcode(0x88 | IsWordWidth(ops[1].Operand), dataWidth);
                }
                EmitModRM(RegisterEncoding(regOpSrc.Register), memOpDst, ops[0].Symbol);
            }
            else
            {
                ImmediateOperand immOpSrc = (ImmediateOperand) ops[1].Operand;
                int isWord = (dataWidth != PrimitiveType.Byte) ? 1 : 0;
                EmitOpcode(0xC6 | IsWordWidth(dataWidth), dataWidth);
                EmitModRM(0, memOpDst, ops[0].Symbol);
                emitter.EmitLeImmediate(immOpSrc.Value, dataWidth);
            }
        }

        public static bool IsSegmentRegister(RegisterStorage seg)
        {
            return seg.Domain == Registers.cs.Domain ||
                   seg.Domain == Registers.ds.Domain ||
                   seg.Domain == Registers.es.Domain ||
                   seg.Domain == Registers.fs.Domain ||
                   seg.Domain == Registers.gs.Domain ||
                   seg.Domain == Registers.ss.Domain;
        }

        internal void ProcessMovx(int opcode, ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(ops[1]);
            if (dataWidth is null)
                return;

            if (!(ops[0].Operand is RegisterOperand regDst))
            {
                Error("First operand must be a register");
                return;
            }
            EmitOpcode(0x0F, regDst.Width);
            emitter.EmitByte(opcode | IsWordWidth(dataWidth));
            EmitModRM(RegisterEncoding(regDst.Register), ops[1]);
        }

        public void Mul(ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;

            // Single operand doesn't accept immediate values.
            if (op.Operand is ImmediateOperand)
                Error("Immediate operand not allowed for single-argument multiplication");

            EmitOpcode(0xF6 | IsWordWidth(dataWidth), dataWidth);
            EmitModRM(4, op);
        }

        internal void ProcessPushPop(bool fPop, ParsedOperand op)
        {
            int imm;
            if (op.Operand is ImmediateOperand immOp)
            {
                if (fPop)
                    throw new ApplicationException("Can't pop an immediate value");
                imm = immOp.Value.ToInt32();
                if (IsSignedByte(imm))
                {
                    EmitOpcode(0x6A, PrimitiveType.Byte);
                    emitter.EmitByte(imm);
                }
                else
                {
                    EmitOpcode(0x68, SegmentDataWidth);
                    emitter.EmitLe(SegmentDataWidth, imm);
                }
                return;
            }

            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;

            if (op.Operand is RegisterOperand regOp)
            {
                var rrr = regOp.Register;
                if (IsBaseRegister(rrr))
                {
                    EmitOpcode(0x50 | (fPop ? 8 : 0) | RegisterEncoding(regOp.Register), dataWidth);
                }
                else
                {
                    int mask = (fPop ? 1 : 0);
                    if (regOp.Register == Registers.es) emitter.EmitByte(0x06 | mask);
                    else if (regOp.Register == Registers.cs) emitter.EmitByte(0x0E | mask);
                    else if (regOp.Register == Registers.ss) emitter.EmitByte(0x16 | mask);
                    else if (regOp.Register == Registers.ds) emitter.EmitByte(0x1E | mask);
                    else if (regOp.Register == Registers.fs) { emitter.EmitByte(0x0F); emitter.EmitByte(0xA0 | mask); }
                    else if (regOp.Register == Registers.gs) { emitter.EmitByte(0x0F); emitter.EmitByte(0xA8 | mask); }
                }
                return;
            }

            EmitOpcode(fPop ? 0x8F : 0xFF, dataWidth);
            EmitModRM(fPop ? 0 : 6, op);
        }

        private bool IsBaseRegister(RegisterStorage reg)
        {
            var r = (int)reg.Domain;
            return (int)Registers.eax.Domain <= r && r <= (int)Registers.edi.Domain;
        }

        internal void ProcessSetCc(byte bits, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            if (dataWidth != PrimitiveType.Byte)
                Error("Instruction takes only a byte operand");
            EmitOpcode(0x0F, dataWidth);
            emitter.EmitByte(0x90 | (bits & 0xF));
            EmitModRM(0, op);
        }


        internal void ProcessShiftRotation(byte subOpcode, ParsedOperand dst, ParsedOperand count)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(dst);
            if (dataWidth is null)
                return;
            if (count.Operand is ImmediateOperand immOp)
            {
                int imm = immOp.Value.ToInt32();
                if (imm == 1)
                {
                    EmitOpcode(0xD0 | IsWordWidth(dataWidth), dataWidth);
                    EmitModRM(subOpcode, dst);
                }
                else
                {
                    EmitOpcode(0xC0 | IsWordWidth(dataWidth), dataWidth);
                    EmitModRM(subOpcode, dst, (byte) immOp.Value.ToInt32());
                }
                return;
            }

            if (count.Operand is RegisterOperand regOp &&
                regOp.Register == Registers.cl)
            {
                EmitOpcode(0xD2 | IsWordWidth(dataWidth), dataWidth);
                EmitModRM(subOpcode, dst);
                return;
            }

            throw new ApplicationException("Shift/rotate instructions must be followed by a constant or CL");
        }

        internal void ProcessShortBranch(int cc, string destination)
        {
            EmitOpcode(0x70 | cc, null);
            EmitRelativeTarget(destination, PrimitiveType.Byte);
        }

        internal void ProcessStringInstruction(byte opcode, PrimitiveType width)
        {
            EmitOpcode(opcode | IsWordWidth(width), width);
        }

        internal void ProcessTest(params ParsedOperand[] ops)
        {
            var dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;

            byte isWord = (byte) ((dataWidth != PrimitiveType.Byte) ? 0xFF : 0);

            if (ops[0].Operand is RegisterOperand regOpDst)	//$BUG: what about segment registers?
            {
                byte reg = RegisterEncoding(regOpDst.Register);
                if (ops[1].Operand is RegisterOperand regOpSrc)
                {
                    if (regOpSrc.Width != regOpDst.Width)
                        Error("Operand size mismatch");
                    EmitOpcode(0x84 | (isWord & 1), dataWidth);
                    modRm.EmitModRM(reg, regOpSrc);
                    return;
                }

                if (ops[1].Operand is MemoryOperand memOpSrc)
                {
                    EmitOpcode(0x84 | (isWord & 1), dataWidth);
                    EmitModRM(reg, ops[1]);
                    return;
                }
                else if (ops[1].Operand is ImmediateOperand immOpSrc)
                {
                    EmitOpcode(0xF6 | (isWord & 1), dataWidth);
                    EmitModRM(0, ops[0]);
                    if (isWord != 0)
                        emitter.EmitLe(dataWidth, immOpSrc.Value.ToInt32());
                    else
                        emitter.EmitByte(immOpSrc.Value.ToInt32());

                    var sym = ops[1].Symbol;
                    if (sym != null && isWord != 0)
                    {
                        Debug.Assert(immOpSrc.Value.ToUInt32() == 0);
                        ReferToSymbol(sym, emitter.Position - 2, PrimitiveType.Word16);
                    }
                    return;
                }
                throw new ApplicationException("unexpected");
            }

            ImmediateOperand immOp = (ImmediateOperand) ops[1].Operand;
            EmitOpcode(0xF6 | (isWord & 1), dataWidth);
            EmitModRM(0, ops[0]);
            if (isWord != 0)
                emitter.EmitLeImmediate(immOp.Value, dataWidth);
            else
                emitter.EmitByte(immOp.Value.ToInt32());

            if (ops[1].Symbol != null && isWord != 0)
            {
                ReferToSymbol(ops[1].Symbol!, emitter.Position - 2, PrimitiveType.Word16);
            }
        }

        internal void ProcessUnary(int operation, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            EmitOpcode(0xF6 | IsWordWidth(dataWidth), dataWidth);
            EmitModRM(operation, op);
        }

        private void DefineSymbol(string pstr)
        {
            var sym = symtab.DefineSymbol(pstr, emitter.Position);
            sym.ResolveLe(emitter);
            ResolveSegmentForwardReferences(sym);
            symbolSegments[sym] = currentSegment;
        }

        private void ResolveSegmentForwardReferences(Symbol sym)
        {
            if (symbolSegments.TryGetValue(sym, out AssembledSegment asmSeg))
            {
                currentSegment.Relocations.AddRange(asmSeg.Relocations);
            }
        }

        internal void EmitModRM(int reg, ParsedOperand op)
        {
            switch (op.Operand)
            {
            case RegisterOperand regOp:
                modRm.EmitModRM(reg, regOp);
                return;
            case FpuOperand fpuOp:
                modRm.EmitModRM(reg, fpuOp);
                return;
            case MemoryOperand mem:
                EmitModRM(reg, mem, op.Symbol);
                break;
            default:
                throw new NotImplementedException();
            }
        }

        internal void EmitModRM(int reg, ParsedOperand op, byte b)
        {
            if (op.Operand is RegisterOperand regOp)
            {
                modRm.EmitModRM(reg, regOp);
                emitter.EmitByte(b);
            }
            else
            {
                EmitModRM(reg, (MemoryOperand) op.Operand, b, op.Symbol);
            }
        }

        internal void EmitModRM(int reg, MemoryOperand memOp, Symbol? sym)
        {
            Constant? offset = modRm.EmitModRMPrefix(reg, memOp);
            if (offset is null)
                return;
            int offsetPosition = emitter.Position;
            EmitOffset(offset);
            if (sym != null)
                ReferToSymbol(sym, offsetPosition, offset.DataType);
        }

        internal void EmitModRM(int reg, MemoryOperand memOp, byte b, Symbol? sym)
        {
            Constant? offset = modRm.EmitModRMPrefix(reg, memOp);
            if (offset is null)
                return;
            emitter.EmitByte(b);
            int offsetPosition = emitter.Position;
            EmitOffset(offset);
            if (sym != null)
                ReferToSymbol(sym, emitter.Position, offset.DataType);
        }

        // width of the address of this opcode.
        public PrimitiveType? AddressWidth { get; set; }

        // Default address width for this segment.
        public PrimitiveType SegmentAddressWidth { get; set; }

        // Default data width for this segment.
        public PrimitiveType SegmentDataWidth { get; set; }

        public RegisterStorage SegmentOverride { get; set; }

        private bool IsDataWidthOverridden(PrimitiveType? dataWidth)
        {
            return dataWidth != null &&
                dataWidth.Domain != Domain.Real &&
                dataWidth.Size != 1 &&
                dataWidth != SegmentDataWidth;
        }

		public void EmitOpcode(int b, PrimitiveType? dataWidth)
		{
			if (SegmentOverride != RegisterStorage.None)
			{
				byte bOv;
				if (SegmentOverride == Registers.es) bOv = 0x26; else
				if (SegmentOverride == Registers.cs) bOv = 0x2E; else
				if (SegmentOverride == Registers.ss) bOv = 0x36; else
				if (SegmentOverride == Registers.ds) bOv = 0x3E; else
				if (SegmentOverride == Registers.fs) bOv = 0x64; else
				if (SegmentOverride == Registers.gs) bOv = 0x65; else
				throw new ArgumentOutOfRangeException(string.Format("Invalid segment register {0}." , SegmentOverride));
				emitter.EmitByte(bOv);
				SegmentOverride = RegisterStorage.None;
			}
			if (IsDataWidthOverridden(dataWidth))
			{
				emitter.EmitByte(0x66);
			}
			if (AddressWidth != null && AddressWidth != SegmentAddressWidth)
			{
				emitter.EmitByte(0x67);
			}
			emitter.EmitByte(b);
		}

        private void EmitOffset(Constant v)
        {
            if (v == null)
                return;
            emitter.EmitLe((PrimitiveType) v.DataType, v.ToInt32());
        }

        private Symbol EmitRelativeTarget(string target, PrimitiveType offsetSize)
        {
            int offBytes = (int) offsetSize.Size;
            switch (offBytes)
            {
            case 1: emitter.EmitByte(-(emitter.Position + 1)); break;
            case 2: emitter.EmitLeUInt16(-(emitter.Position + 2)); break;
            case 4: emitter.EmitLeUInt32((uint)-(emitter.Position + 4)); break;
            }
            var sym = symtab.CreateSymbol(target);
            sym.ReferToLe(emitter.Position - offBytes, offsetSize, emitter);
            return sym;
        }

        private void EmitReferenceToSymbolSegment(Symbol sym)
        {
            var seg = GetSymbolSegmentReference(sym);
            seg.Relocations.Add(new AssembledSegment.Relocation(currentSegment, (uint) emitter.Position));
            emitter.EmitLeUInt16(0);            // make space for the segment selector, will be overwritten at relocation time.
        }

        private AssembledSegment GetSymbolSegmentReference(Symbol sym)
        {
            if (symbolSegments.TryGetValue(sym, out AssembledSegment seg))
                return seg;
            seg = new AssembledSegment(emitter, null);
            symbolSegments.Add(sym, seg);
            return seg;
        }

        private PrimitiveType? EnsureValidOperandSizes(ParsedOperand[] ops, int count)
        {
            PrimitiveType? w = ops[0].Operand.Width;
            if (count == 1 && ops[0].Operand.Width == null)
            {
                Error("Width of the first operand is unknown");
                return null;
            }
            if (count == 2)
            {
                if (w is null)
                {
                    w = ops[1].Operand.Width;
                    if (w == null)
                        Error("Width of the first operand is unknown");
                    else
                        ops[0].Operand.Width = w;
                }
                else
                {
                    if (ops[1].Operand.Width == null)
                        ops[1].Operand.Width = w;
                    else if (ops[0].Operand.Width != ops[0].Operand.Width)
                        Error("Operand widths don't match");
                }
            }
            return w;
        }

        private int IsAccumulator(RegisterStorage reg)
        {
            return (reg == Registers.eax || reg == Registers.ax || reg == Registers.al) ? 1 : 0;
        }

        private bool IsSignedByte(int n)
        {
            return -128 <= n && n < 128;
        }


        private int IsWordWidth(MachineOperand op)
        {
            return IsWordWidth(op.Width);
        }

        internal void SetDefaultWordWidth(PrimitiveType width)
        {
            SegmentDataWidth = width;
            SegmentAddressWidth = width;
            modRm = new ModRmBuilder(width, emitter);
            modRm.Error += modRm_Error;
        }

        private void SwitchSegment(AssembledSegment newSegment)
        {
            currentSegment = newSegment;
            emitter = newSegment.Emitter;
            modRm = new ModRmBuilder(defaultWordSize, emitter);
        }


        private int IsWordWidth(PrimitiveType? width)
        {
            if (width is null)
                Error("Operand width is undefined");
            else if (width.Size == 1)
                return 0;
            return 1;
        }

        private bool Error(string pstr)
        {
            throw new ApplicationException(pstr);
        }

        private void ReferToSymbol(Symbol psym, int off, DataType width)
        {
            if (psym.fResolved)
            {
                emitter.PatchLe(off, psym.offset, width);
            }
            else
            {
                psym.AddForwardReference(off, width, 1);
            }
        }

        public static byte RegisterEncoding(RegisterStorage reg)
        {
            return registerEncodings[reg];
        }

        public static Constant IntegralConstant(int i, PrimitiveType? width)
        {
            if (-0x80 <= i && i < 0x80)
                width = PrimitiveType.SByte;
            else if (width == null)
            {
                if (-0x8000 <= i && i < 0x8000)
                    width = PrimitiveType.Word16;
                else
                    width = PrimitiveType.Word32;
            }
            return Constant.Create(width, i);
        }

        public static Constant IntegralConstant(int i)
        {
            PrimitiveType width;
            if (-0x80 <= i && i < 0x80)
                width = PrimitiveType.SByte;
            else if (-0x8000 <= i && i < 0x8000)
                width = PrimitiveType.Word16;
            else
                width = PrimitiveType.Word32;
            return Constant.Create(width, i);
        }


        private void modRm_Error(object sender, ErrorEventArgs args)
        {
            Error(args.Message);
        }

        private static readonly Dictionary<RegisterStorage, byte> registerEncodings = 
            new Dictionary<RegisterStorage, byte>
		{
			{ Registers.eax, 0x00 },
			{ Registers.ecx, 0x01 },
			{ Registers.edx, 0x02 },
			{ Registers.ebx, 0x03 },
			{ Registers.esp, 0x04 },
			{ Registers.ebp, 0x05 },
			{ Registers.esi, 0x06 },
			{ Registers.edi, 0x07 },

			{ Registers.ax, 0x00 },
			{ Registers.cx, 0x01 },
			{ Registers.dx, 0x02 },
			{ Registers.bx, 0x03 },
			{ Registers.sp, 0x04 },
			{ Registers.bp, 0x05 },
			{ Registers.si, 0x06 },
			{ Registers.di, 0x07 },

			{ Registers.al, 0x00 },
			{ Registers.cl, 0x01 },
			{ Registers.dl, 0x02 },
			{ Registers.bl, 0x03 },
			{ Registers.ah, 0x04 },
			{ Registers.ch, 0x05 },
			{ Registers.dh, 0x06 },
			{ Registers.bh, 0x07 },

			{ Registers.es, 0x00 },
			{ Registers.cs, 0x01 },
			{ Registers.ss, 0x02 },
			{ Registers.ds, 0x03 },
			{ Registers.fs, 0x04 },
			{ Registers.gs, 0x05 },
		};
        private Encoding textEncoding;

        public void i386()
        {
            arch = new X86ArchitectureFlat32(arch.Services, "x86-protected-32", new Dictionary<string, object>());
            SetDefaultWordWidth(PrimitiveType.Word32);
        }

        public void i86()
        {
            arch = new X86ArchitectureReal(arch.Services, "x86-real-16", new Dictionary<string, object>());
            SetDefaultWordWidth(PrimitiveType.Word16);
        }

        public void Aaa()
        {
            emitter.EmitByte(0x37);
        }

        public void Aam()
        {
            emitter.EmitByte(0xD4);
            emitter.EmitByte(0x0A);
        }

        public void Call(string destination)
        {
            ProcessCallJmp(false, 0xE8, destination);
        }


        public void Call(ParsedOperand parsedOperand)
        {
            var far = (parsedOperand.Operand is MemoryOperand && parsedOperand.Operand.Width.Size == 4);
            ProcessCallJmp(far, 0x02, parsedOperand);
        }


        public void CallF(string destination)
        {
            ProcessCallJmp(true, 0x9A, destination);
        }


        public void CallF(ParsedOperand parsedOperand)
        {
            ProcessCallJmp(true, 0x03, parsedOperand);
        }

        public void Fadd(ParsedOperand op)
        {
            ProcessFpuCommon(0xD8, 0xD8, 0, false, false, op);
        }

        public void Fiadd(ParsedOperand operand)
        {
            var dataWidth = EnsureValidOperandSize(operand);
            if (dataWidth is null)
                return;
            int opcode;
            switch (dataWidth.Size)
            {
            case 2: opcode = 0xDE; break;
            case 4: opcode = 0xDA; break;
            default: Error(string.Format("Instruction doesn't support {0}-byte operands.", dataWidth.Size)); return;
            }
            EmitOpcode(opcode, dataWidth);
            EmitModRM(0, operand);
        }

        public void Fild(ParsedOperand op)
        {
            var dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;
            int opCode;
            int reg;
            switch (dataWidth.Size)
            {
            case 2: opCode = 0xDF; reg = 0x00; break;
            case 4: opCode = 0xDB; reg = 0x00; break;
            case 8: opCode = 0xDF; reg = 0x05; break;
            default: Error(string.Format("Instruction doesn't support {0}-byte operands", dataWidth.Size)); return;
            }
            EmitOpcode(opCode, dataWidth);
            EmitModRM(reg, op);
        }

        public void Fistp(ParsedOperand src)
        {
            var dataWidth = EnsureValidOperandSize(src);
            if (dataWidth is null)
                return;
            int opCode;
            int reg;
            switch (dataWidth.Size)
            {
            case 2: opCode = 0xDF; reg = 0x03; break;
            case 4: opCode = 0xDB; reg = 0x03; break;
            case 8: opCode = 0xDF; reg = 0x07; break;
            default: Error(string.Format("Instruction doesn't support {0}-byte operands", dataWidth.Size)); return;
            }
            EmitOpcode(opCode, null);
            EmitModRM(reg, src);
        }

        public void Fld1()
        {
            emitter.EmitByte(0xD9);
            emitter.EmitByte(0xE8);
        }

        public void Fldz()
        {
            EmitOpcode(0xD9, null);
            emitter.EmitByte(0xEE);
        }

        public void Fmul(ParsedOperand op)
        {
            ProcessFpuCommon(0xD8, 0xD8, 1, false, false, op);
        }

        public void Fstsw(ParsedOperand dst)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(dst);
            if (dataWidth is null)
                return;
            if (dst.Operand is RegisterOperand regOp)
            {
                if (regOp.Register != Registers.ax)
                    Error("Register operand must be AX");
                EmitOpcode(0xDF, dataWidth);
                emitter.EmitByte(0xE0);
            }
            if (dst.Operand is MemoryOperand)
            {
                if (dataWidth != PrimitiveType.Word16)
                    Error("Destination must be two bytes");
                EmitOpcode(0xDD, dataWidth);
                EmitModRM(0x07, dst);
            }
        }

        public void Fst(ParsedOperand parsedOperand)
        {
            ProcessFst(false, parsedOperand);
        }

        public void Fstp(ParsedOperand parsedOperand)
        {
            ProcessFst(true, parsedOperand);
        }

        public void Ret()
        {
            EmitOpcode(0xC3, null);
        }

        public void Ret(int n)
        {
            if (n == 0)
            {
                Ret();
            }
            else
            {
                EmitOpcode(0xC2, null);
                emitter.EmitLeUInt16(n);
            }
        }

        public void Retf()
        {
            EmitOpcode(0xCB, null);
        }

        public void Retf(int n)
        {
            if (n == 0)
                Retf();
            else
            {
                EmitOpcode(0xCA, null);
                emitter.EmitLeUInt16(n);
            }
        }

        public void Proc(string procName)
        {
            DefineSymbol(procName);
            //$BUG: should be symbols. the ORG directive specifies the start symbol.
            if (entryPoints != null && entryPoints.Count == 0)
            {
                entryPoints.Add(
                    ImageSymbol.Procedure(arch, addrBase + emitter.Position));
            }
        }

        public void Push(ParsedOperand op)
        {
            ProcessPushPop(false, op);
        }

        public void Pusha()
        {
            emitter.EmitByte(0x60);
        }

        public void Pushf()
        {
            emitter.EmitByte(0x9C);
        }

        public void Popf()
        {
            emitter.EmitByte(0x9D);
        }

        public void Adc(ParsedOperand op, int constant)
        {
            Adc(op, new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant))));
        }

        public void Adc(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessBinop(0x02, op1, op2);
        }

        public void Add(RegisterStorage reg, int constant)
        {
            ProcessBinop(
                0x00,
                new ParsedOperand(new RegisterOperand(reg)),
                new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant))));
        }

        public void Add(ParsedOperand op, int constant)
        {
            ProcessBinop(
                0x00,
                op,
                new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant))));
        }


        public void And(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0x04, dst, src);
        }

        public ParsedOperand Imm( uint constant)
        {
            return Imm((int)constant);
        }

        public ParsedOperand Imm(PrimitiveType width, int constant)
        {
            return new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant, width)));
        }

        public ParsedOperand Imm(int constant)
        {
            return new ParsedOperand(new ImmediateOperand(X86Assembler.IntegralConstant(constant)));
        }

        public ParsedOperand WordPtr(int directOffset)
        {
            return new ParsedOperand(new MemoryOperand(
                PrimitiveType.Word16,
                IntegralConstant(directOffset, AddressWidth)));
        }

        public ParsedOperand WordPtr(ParsedOperand reg, int offset)
        {
            return new ParsedOperand(new MemoryOperand(
                PrimitiveType.Word16,
                ((RegisterOperand) reg.Operand).Register,
                IntegralConstant(offset, AddressWidth)));
        }

        public ParsedOperand DwordPtr(ParsedOperand reg, int offset)
        {
            return new ParsedOperand(new MemoryOperand(
                PrimitiveType.Word32,
                ((RegisterOperand)reg.Operand).Register,
                IntegralConstant(offset, AddressWidth)));
        }

        public void Lea(ParsedOperand dst, ParsedOperand addr)
        {
            RegisterOperand ropLhs = (RegisterOperand) dst.Operand;
            EmitOpcode(0x8D, ropLhs.Width);
            EmitModRM(RegisterEncoding(ropLhs.Register), addr);
        }

        public void ProcessCwd(PrimitiveType width)
        {
            EmitOpcode(0x99, width);
        }

        public void Add(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0, dst, src);
        }

        public void Bswap(ParsedOperand op)
        {
            var reg = ((RegisterOperand)op.Operand).Register;
            EmitOpcode(0x0F, op.Operand.Width);
            emitter.EmitByte(0xC8 | RegisterEncoding(reg));
        }

        public void Dec(ParsedOperand op)
        {
            ProcessIncDec(true, op);
        }

        public void Div(ParsedOperand op)
        {
            ProcessDiv(0x06, op);
        }

        public void Idiv(ParsedOperand op)
        {
            ProcessDiv(0x07, op);
        }

        public void Import(string symbolName, string fnName, string dllName)
        {
            DefineSymbol(symbolName);
            AddImport(dllName, fnName, PrimitiveType.Word32);
        }

        public void Imul(ParsedOperand op)
        {
            ProcessImul(op);
        }

        public void Hlt()
        {
            emitter.EmitByte(0xF4);
        }

        public void Int(int serviceVector)
        {
            ProcessInt(Const(serviceVector));
        }

        public void In(ParsedOperand dst, ParsedOperand port)
        {
            ProcessInOut(false, dst, port);
        }

        public void Inc(ParsedOperand op)
        {
            ProcessIncDec(false, op);
        }

        public void Ja(string destination)
        {
            ProcessShortBranch(0x07, destination);
        }

        public void Jc(string destination)
        {
            ProcessShortBranch(0x02, destination);
        }

        public void Jcxz(string destination)
        {
            EmitOpcode(0xE3, null);
            EmitRelativeTarget(destination, PrimitiveType.Byte);
        }

        public void Jns(string destination)
        {
            ProcessShortBranch(0x09, destination);
        }

        public void Jnz(string destination)
        {
            ProcessShortBranch(0x05, destination);
        }

        public void Jpe(string destination)
        {
            ProcessShortBranch(0x0A, destination);
        }

        public void Jpo(string destination)
        {
            ProcessShortBranch(0x0B, destination);
        }

        public void Jz(string destination)
        {
            ProcessShortBranch(0x04, destination);
        }

        public void Jmp(string destination)
        {
            ProcessCallJmp(false, 0xE9, destination);
        }

        public void Jmp(ParsedOperand parsedOperand)
        {
            ProcessCallJmp(false, 0x04, parsedOperand);
        }

        public void JmpF(Address address)
        {
            emitter.EmitByte(0xEA);
            emitter.EmitLeUInt16((ushort)address.Offset);
            emitter.EmitLeUInt16(address.Selector!.Value);
        }

        public X86Assembler Label(string label)
        {
            DefineSymbol(label);
            return this;
        }

        public void Endp(string p)
        {
        }

        public void Ends()
        {
            SwitchSegment(unknownSegment);
        }


        public void Enter(int cbStack, int nLevel)
        {
            EmitOpcode(0xC8, null);
            emitter.EmitLeUInt16(cbStack);
            emitter.EmitByte(nLevel);
        }

        public void Equ(string s, int value)
        {
            symtab.Equates[s] = value;
        }

        internal void Extern(string externSymbol, PrimitiveType size)
        {
            DefineSymbol(externSymbol);
            AddImport(null, externSymbol, size);
        }

        public void Neg(ParsedOperand op)
        {
            ProcessUnary(0x03, op);
        }

        public void Not(ParsedOperand op)
        {
            ProcessUnary(0x02, op);
        }

        public void Or(ParsedOperand opDst, ParsedOperand opSrc)
        {
            ProcessBinop(0x01, opDst, opSrc);
        }

        public void Out(ParsedOperand op1, ParsedOperand op2)
        {
            ProcessInOut(true, op1, op2);
        }

        public void Pop(ParsedOperand op)
        {
            ProcessPushPop(true, op);
        }

        internal void ProcessBinop(int binop, params ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;
            if (ops[1].Operand is ImmediateOperand immOp)
            {
                int imm = immOp.Value.ToInt32();
                if (ops[0].Operand is RegisterOperand regOpDst && IsAccumulator(regOpDst.Register) != 0)
                {
                    EmitOpcode((binop << 3) | 0x04 | IsWordWidth(ops[0].Operand), dataWidth);
                    emitter.EmitLeImmediate(immOp.Value, dataWidth);
                    return;
                }

                switch (dataWidth.Size)
                {
                default:
                    Error("Must specify operand width");
                    return;
                case 1:
                    EmitOpcode(0x80, dataWidth);
                    EmitModRM(binop, ops[0]);
                    emitter.EmitByte(imm);
                    break;
                case 2:
                case 4:
                    if (IsSignedByte(imm))
                    {
                        EmitOpcode(0x83, dataWidth);
                        EmitModRM(binop, ops[0]);
                        emitter.EmitByte(imm);
                    }
                    else
                    {
                        EmitOpcode(0x81, dataWidth);
                        EmitModRM(binop, ops[0]);
                        emitter.EmitLeImmediate(immOp.Value, dataWidth);
                    }
                    break;
                }
                return;
            }

            if (ops[0].Operand is MemoryOperand)
            {
                RegisterOperand regOpSrc = (RegisterOperand) ops[1].Operand;
                EmitOpcode((binop << 3) | 0x00 | IsWordWidth(ops[1].Operand), dataWidth);
                EmitModRM(RegisterEncoding(regOpSrc.Register), ops[0]);
            }
            else
            {
                RegisterOperand regOpDst = (RegisterOperand) ops[0].Operand;
                EmitOpcode((binop << 3) | 0x02 | IsWordWidth(regOpDst), dataWidth);
                EmitModRM(RegisterEncoding(regOpDst.Register), ops[1]);
            }
        }

        internal void ProcessBitOp(ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(ops[0]);
            if (dataWidth is null)
                return;

            if (ops[1].Operand is ImmediateOperand imm2)
            {
                EmitOpcode(0x0F, dataWidth);
                emitter.EmitByte(0xBA);
                EmitModRM(0x04, ops[0]);
                emitter.EmitByte(imm2.Value.ToInt32());
            }
            else
            {
                EmitOpcode(0x0F, dataWidth);
                emitter.EmitByte(0xA3);
                EmitModRM(RegisterEncoding(((RegisterOperand) ops[1].Operand).Register), ops[0]);
            }
        }

        internal void ProcessBitScan(byte opCode, ParsedOperand dst, ParsedOperand src)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(src);
            if (dataWidth is null)
                return;

            if (!(dst.Operand is RegisterOperand regDst))
            {
                Error("First operand of bit scan instruction must be a register");
                return;
            }
            EmitOpcode(0x0F, dataWidth);
            emitter.EmitByte(opCode);
            EmitModRM(RegisterEncoding(regDst.Register), src);
        }

        internal void ProcessCallJmp(bool far, int direct, string destination)
        {
            EmitOpcode(direct, null);
            if (far)
            {
                var sym = symtab.CreateSymbol(destination);
                sym.ReferToLe(emitter.Position, SegmentAddressWidth, emitter);

                emitter.EmitLe(SegmentAddressWidth, 0);

                EmitReferenceToSymbolSegment(sym);
            }
            else
            {
                EmitRelativeTarget(destination, SegmentAddressWidth);
            }
        }

        internal void ProcessCallJmp(bool far, int indirect, ParsedOperand op)
        {
            if (far) indirect |= 1;
            EmitOpcode(0xFF, SegmentDataWidth);
            EmitModRM(indirect, op);
        }

        internal void ProcessDiv(int operation, ParsedOperand op)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op);
            if (dataWidth is null)
                return;

            EmitOpcode(0xF6 | IsWordWidth(dataWidth), dataWidth);
            EmitModRM(operation, op);
        }

        internal void ProcessDoubleShift(byte bits, ParsedOperand op0, ParsedOperand op1, ParsedOperand count)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSize(op0);
            if (dataWidth is null)
                return;

            if (!(op1.Operand is RegisterOperand regSrc))
            {
                Error("Second operand of SHLD/SHRD must be a register");
                return;
            }
            if (count.Operand is RegisterOperand regShift && regShift.Register == Registers.cl)
            {
                bits |= 0x01;
            }
            else if (immShift is null)
            {
                Error("SHLD/SHRD instruction must be followed by a constant or CL");
            }

            EmitOpcode(0x0F, dataWidth);
            emitter.EmitByte(0xA4 | bits);
            EmitModRM(RegisterEncoding(regSrc.Register), op0);

            if (count.Operand is ImmediateOperand immShift)
                emitter.EmitByte((byte) immShift.Value.ToUInt32());
        }

        public void AddImport(string? moduleName, string fnName,  PrimitiveType size)
        {
            Address u =  (addrBase + emitter.Position);
            ImportReferences.Add(u, new NamedImportReference(u, Path.GetFileNameWithoutExtension(moduleName), fnName, SymbolType.ExternalProcedure));
            emitter.EmitLe(size, 0);
        }

        internal OperandParser CreateOperandParser(Lexer lexer)
        {
            return new OperandParser(lexer, symtab, addrBase, SegmentDataWidth, SegmentAddressWidth);
        }


        internal void DefineWord(PrimitiveType width, string symbolText)
        {
            Symbol sym = symtab.CreateSymbol(symbolText);
            emitter.EmitLe(width, (int)addrBase.Offset);
            ReferToSymbol(sym, emitter.Position - (int) width.Size, SegmentAddressWidth);
        }

        internal void DefineWord(PrimitiveType width, int value)
        {
            emitter.EmitLe(width, value);
        }

        internal void ReportUnresolvedSymbols()
        {
            Symbol[] s = symtab.GetUndefinedSymbols();
            if (s.Length > 0)
            {
                StringWriter writer = new StringWriter();
                writer.WriteLine("The following symbols were undefined:");
                for (int i = 0; i < s.Length; ++i)
                {
                    writer.WriteLine("  {0}", s[i].ToString());
                }
                throw new ApplicationException(writer.ToString());
            }
        }

        public void Bsr(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBitScan(0xBD, dst, src);
        }

        public void Clc()
        {
            EmitOpcode(0xF8, null);
        }

        public void Cld()
        {
            EmitOpcode(0xFC, null);
        }

        public void Cmc()
        {
            EmitOpcode(0xF5, null);
        }

        public void Cmp(ParsedOperand dst, int src)
        {
            ProcessBinop(0x7, dst, Imm(src));
        }

        public void Cmp(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0x7, dst, src);
        }

        public void Db(params byte[] bytes)
        {
            for (int i = 0; i < bytes.Length; ++i)
            {
                emitter.EmitByte(bytes[i]);
            }
        }

        public void Db(int b)
        {
            emitter.EmitByte(b);
        }

        internal void Dstring(string str)
        {
            emitter.EmitString(str, textEncoding);
        }

        public void Dw(int w)
        {
            emitter.EmitByte(w & 0xFF);
            emitter.EmitByte(w >> 8);
        }

        public void Dw(string symbolText)
        {
            DefineWord(PrimitiveType.Word16, symbolText);
        }

        public void Dd(params string[] symbols)
        {
            foreach (string sym in symbols)
            {
                DefineWord(PrimitiveType.Word32, sym);
            }
        }

        public void Dd(params int[] values)
        {
            foreach (int n in values)
            {
                DefineWord(PrimitiveType.Word32, n);
            }
        }

        public void Repeat(int count, Action<X86Assembler> action)
        {
            for (int i = 0; i < count; ++i)
                action(this);
        }

        internal void Leave()
        {
            EmitOpcode(0xC9, null);
        }

        public void Les(ParsedOperand dst, ParsedOperand src)
        {
            ProcessLxs(-1, 0xC4, dst, src);
        }

        public void Loop(string target)
        {
            ProcessLoop(2, target);
        }

        public void Loope(string target)
        {
            ProcessLoop(1, target);
        }

        public void Loopne(string target)
        {
            ProcessLoop(0, target);
        }

        public void Rep()
        {
            emitter.EmitByte(0xF3);
        }

        public void Repne()
        {
            emitter.EmitByte(0xF2);
        }

        public void Lodsb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Load, PrimitiveType.Byte);
        }
        public void Lodsw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Load, PrimitiveType.Word16);
        }
        public void Lodsd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Load, PrimitiveType.Word32);
        }

        public void Stosb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Store, PrimitiveType.Byte);
        }
        public void Stosw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Store, PrimitiveType.Word16);
        }
        public void Stosd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Store, PrimitiveType.Word32);
        }

        public void Movsb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Move, PrimitiveType.Byte);
        }
        public void Movsw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Move, PrimitiveType.Word16);
        }
        public void Movsd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Move, PrimitiveType.Word32);
        }

        public void Scasb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Scan, PrimitiveType.Byte);
        }
        public void Scasw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Scan, PrimitiveType.Word16);
        }
        public void Scasd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Scan, PrimitiveType.Word32);
        }

        public void Cmpsb()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Compare, PrimitiveType.Byte);
        }
        public void Cmpsw()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Compare, PrimitiveType.Word16);
        }
        public void Cmpsd()
        {
            ProcessStringInstruction((byte)StringInstructionBaseOps.Compare, PrimitiveType.Word32);
        }

        public ParsedOperand St(int n)
        {
            return new ParsedOperand(new FpuOperand(n));
        }

        public void Stc()
        {
            EmitOpcode(0xF9, null);
        }

        public void Std()
        {
            EmitOpcode(0xFD, null);
        }

        public void Fcompp()
        {
            emitter.EmitByte(0xDE);
            emitter.EmitByte(0xD9);
        }


        internal void DbDup(int by, int count)
        {
            emitter.EmitBytes((byte) by, count);
        }

        internal void Xchg(ParsedOperand[] ops)
        {
            PrimitiveType? dataWidth = EnsureValidOperandSizes(ops, 2);
            if (dataWidth is null)
                return;
            ParsedOperand otherOp = ops[1];
            if (!(ops[0].Operand is RegisterOperand regOp))
            {
                if (!(ops[1].Operand is RegisterOperand regOp2))
                {
                    Error("One operand must be a register.");
                    return;
                }
                regOp = regOp2;
                otherOp = ops[0];
            }
            EmitOpcode(0x86 | IsWordWidth(regOp), dataWidth);
            EmitModRM(RegisterEncoding(regOp.Register), otherOp);
        }

        public void Xor(ParsedOperand dst, ParsedOperand src)
        {
            ProcessBinop(0x06, dst, src);
        }

        public ParsedOperand ax
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ax)); }
        }

        public ParsedOperand bx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bx)); }
        }

        public ParsedOperand cx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.cx)); }
        }

        public ParsedOperand dx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.dx)); }
        }

        public ParsedOperand si
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.si)); }
        }

        public ParsedOperand di
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.di)); }
        }

        public ParsedOperand sp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.sp)); }
        }

        public ParsedOperand bp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bp)); }
        }

        public ParsedOperand al
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.al)); }
        }

        public ParsedOperand cl
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.cl)); }
        }

        public ParsedOperand dl
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.dl)); }
        }

        public ParsedOperand bl
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bl)); }
        }

        public ParsedOperand ah
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ah)); }
        }

        public ParsedOperand bh
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.bh)); }
        }

        public ParsedOperand eax
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.eax)); }
        }

        public ParsedOperand ebx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ebx)); }
        }

        public ParsedOperand ecx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ecx)); }
        }

        public ParsedOperand edx
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.edx)); }
        }

        public ParsedOperand ebp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ebp)); }
        }

        public ParsedOperand esp
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.esp)); }
        }

        public ParsedOperand esi
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.esi)); }
        }

        public ParsedOperand edi
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.edi)); }
        }

        public ParsedOperand cs
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.cs)); }
        }

        public ParsedOperand ds
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.ds)); }
        }

        public ParsedOperand es
        {
            get { return new ParsedOperand(new RegisterOperand(Registers.es)); }
        }

        public ParsedOperand Const(int n)
        {
            return new ParsedOperand(new ImmediateOperand(IntegralConstant(n, this.defaultWordSize)));
        }

        public ParsedOperand MemW(RegisterStorage seg, RegisterStorage @base, int offset)
        {
            var mem = new MemoryOperand(PrimitiveType.Word16);
            mem.Base = @base;
            mem.Offset = IntegralConstant(offset);
            mem.SegOverride = seg;
            return new ParsedOperand(mem);
        }


        public ParsedOperand MemDw(RegisterStorage @base, int scale, string offset)
        {
            return Mem(PrimitiveType.Word32, null, @base, null, scale, offset);
        }

        public ParsedOperand MemDw(RegisterStorage @base, RegisterStorage index, int scale, string offset)
        {
            return Mem(PrimitiveType.Word32, null, @base, index, scale, offset);
        }

        public ParsedOperand MemDw(string offset)
        {
            return Mem(PrimitiveType.Word32, null, null, null, 1, offset);
        }

        public ParsedOperand MemDw(object @base, string offset)
        {
            RegisterStorage reg = ExpectRegister(@base);
            return Mem(PrimitiveType.Word32, null, reg, null, 1, offset);
        }

        private static RegisterStorage ExpectRegister(object @base)
        {
            var reg = @base as RegisterStorage;
            if (reg == null)
            {
                var op = (ParsedOperand)@base;
                reg = ((RegisterOperand)op.Operand).Register;
            }
            return reg;
        }

        public ParsedOperand MemW(RegisterStorage @base, string offset)
        {
            return Mem(PrimitiveType.Word16, null, @base, null, 1, offset);
        }

        public ParsedOperand MemB(RegisterStorage @base, string offset)
        {
            return Mem(PrimitiveType.Byte, null, @base, null, 1, offset);
        }

        public ParsedOperand MemW(RegisterStorage seg, RegisterStorage @base, string offset)
        {
            return Mem(PrimitiveType.Word16, seg, @base, null, 1, offset);
        }

        public ParsedOperand MemDw(object @base, int offset)
        {
            return Mem(PrimitiveType.Word32, ExpectRegister(@base), offset);
        }

        public ParsedOperand MemW(RegisterStorage @base, int offset)
        {
            return Mem(PrimitiveType.Word16, @base, offset);
        }

        public ParsedOperand MemB(RegisterStorage @base, int offset)
        {
            return Mem(PrimitiveType.Byte, @base, offset);
        }

        public ParsedOperand MemB(int offset)
        {
            return Mem(PrimitiveType.Byte, RegisterStorage.None, offset);
        }

        private ParsedOperand Mem(
            PrimitiveType width, 
            RegisterStorage? seg, 
            RegisterStorage? @base,  
            RegisterStorage? index, 
            int scale, 
            string offset)
        {
            MemoryOperand mem;
            Symbol? sym = null;
            if (offset != null)
            {
                if (symtab.Equates.TryGetValue(offset, out int val))
                {
                    mem = new MemoryOperand(width, @base ?? RegisterStorage.None, IntegralConstant(val, @base!.DataType));
                    sym = null;
                }
                else
                {
                    sym = symtab.CreateSymbol(offset);
                    val = (int)this.addrBase.Offset;
                    Constant off = Constant.Create(@base == null
                        ? seg != null ? PrimitiveType.Word16 : PrimitiveType.Word32
                        : @base.DataType,
                        val);
                    mem = new MemoryOperand(width, @base ?? RegisterStorage.None, off);
                }
            }
            else
            {
                mem = new MemoryOperand(width)
                {
                };
            }
            if (seg != null)
            {
                mem.SegOverride = seg;
                this.SegmentOverride = seg;
            }
            mem.Scale = (byte)scale;
            if (scale > 1)
            {
                if (index is null)
                {
                    mem.Index = mem.Base;
                    mem.Base = RegisterStorage.None;
                }
                else
                {
                    mem.Index = index;
                    mem.Base = @base!;
                }
            }
            return new ParsedOperand(mem, sym);
        }

        private ParsedOperand Mem(PrimitiveType width, RegisterStorage @base, int offset)
        {
            return new ParsedOperand(
                new MemoryOperand(width, @base, IntegralConstant(offset)));
        }

        public void Segment(string segmentName)
        {
            AssembledSegment seg;
            if (!mpNameToSegment.TryGetValue(segmentName, out seg))
            {
                var sym = symtab.DefineSymbol(segmentName, 0);
                seg = new AssembledSegment(new Emitter(), sym);
                segments.Add(seg);
            }
            SwitchSegment(seg);
        }

        public void Xlat()
        {
            emitter.EmitByte(0xD7);
        }
    }
}


---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(21,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(307,17): error CS0841: Cannot use local variable 'mop' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(308,17): error CS0841: Cannot use local variable 'mop' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(318,21): error CS0841: Cannot use local variable 'fop1' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(326,21): error CS0841: Cannot use local variable 'fop1' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(329,63): error CS0841: Cannot use local variable 'fop1' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(547,59): error CS0136: A local or parameter named 'regOpSrc' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(565,55): error CS0136: A local or parameter named 'regOpSrc' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(577,55): error CS0128: A local variable or function named 'regOpSrc' is already defined in this scope,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(611,13): error CS0841: Cannot use local variable 'regOpSrc' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(579,25): error CS0165: Use of unassigned local variable 'regOpSrc',D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(1789,22): error CS0841: Cannot use local variable 'immShift' before it is declared,D:\a\1\s\src\Arch\X86\Assembler\X86Assembler.cs(21,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 14 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core;
using Reko.Core.Expressions;
using Reko.Core.Machine;
using Reko.Core.Memory;
using Reko.Core.Operators;
using Reko.Core.Rtl;
using Reko.Core.Serialization;
using Reko.Core.Types;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Reko.Arch.Z80
{
    public class Z80Rewriter : IEnumerable<RtlInstructionCluster>
    {
        private readonly Z80ProcessorArchitecture arch;
        private readonly IStorageBinder binder;
        private readonly IRewriterHost host;
        private readonly IEnumerator<Z80Instruction> dasm;
        private InstrClass iclass;
        private RtlEmitter m;

#nullable disable
        public Z80Rewriter(Z80ProcessorArchitecture arch, EndianImageReader rdr, ProcessorState state, IStorageBinder binder, IRewriterHost host)
        {
            this.arch = arch;
            this.binder = binder;
            this.host = host;
            this.dasm = new Z80Disassembler(arch, rdr).GetEnumerator();
        }
#nullable enable

        public IEnumerator<RtlInstructionCluster> GetEnumerator()
        {
            while (dasm.MoveNext())
            {
                var addr = dasm.Current.Address;
                var len = dasm.Current.Length;
                this.iclass = dasm.Current.InstructionClass;
                var rtlInstructions = new List<RtlInstruction>();
                m = new RtlEmitter(rtlInstructions);
                switch (dasm.Current.Mnemonic)
                {
                default:
                    host.Error(
               dasm.Current.Address,
               "Z80 instruction '{0}' is not supported yet.",
               dasm.Current.Mnemonic);
                    goto case Mnemonic.illegal;
                case Mnemonic.illegal: m.Invalid(); break;
                case Mnemonic.adc: RewriteAdc(); break;
                case Mnemonic.add: RewriteAdd(); break;
                case Mnemonic.and: RewriteAnd(); break;
                case Mnemonic.bit: RewriteBit(); break;
                case Mnemonic.call: RewriteCall(dasm.Current); break;
                case Mnemonic.ccf: RewriteCcf(); break;
                case Mnemonic.cp: RewriteCp(); break;
                case Mnemonic.cpd: RewriteCp(m.ISub, false); break;
                case Mnemonic.cpdr: RewriteCp(m.ISub, true); break;
                case Mnemonic.cpi: RewriteCp(m.IAdd, false); break;
                case Mnemonic.cpir: RewriteCp(m.IAdd, true); break;
                case Mnemonic.cpl: RewriteCpl(); break;
                case Mnemonic.di: RewriteDi(); break;
                case Mnemonic.daa: RewriteDaa(); break;
                case Mnemonic.dec: RewriteDec(); break;
                case Mnemonic.djnz: RewriteDjnz(dasm.Current.Operands[0]); break;
                case Mnemonic.ei: RewriteEi(); break;
                case Mnemonic.ex: RewriteEx(); break;
                case Mnemonic.ex_af: RewriteExAf(); break;
                case Mnemonic.exx: RewriteExx(); break;
                case Mnemonic.hlt: RewriteHlt(); break;
                case Mnemonic.@in: RewriteIn(); break;
                case Mnemonic.ind: RewriteIn(m.ISub, false); break;
                case Mnemonic.indr: RewriteIn(m.ISub, true); break;
                case Mnemonic.ini: RewriteIn(m.IAdd, false); break;
                case Mnemonic.inir: RewriteIn(m.IAdd, true); break;
                case Mnemonic.im:
                    m.SideEffect(host.Intrinsic("__im", false, VoidType.Instance, RewriteOp(dasm.Current.Operands[0])));
                    break;
                case Mnemonic.inc: RewriteInc(); break;
                case Mnemonic.jp: RewriteJp(dasm.Current); break;
                case Mnemonic.jr: RewriteJr(); break;
                case Mnemonic.ld: RewriteLd(); break;
                case Mnemonic.rl: RewriteRotation(IntrinsicProcedure.RolC, true); break;
                case Mnemonic.rla: RewriteRotation(IntrinsicProcedure.RolC, true); break;
                case Mnemonic.rlc: RewriteRotation(IntrinsicProcedure.Rol, false); break;
                case Mnemonic.rlca: RewriteRotation(IntrinsicProcedure.Rol, false); break;
                case Mnemonic.rr: RewriteRotation(IntrinsicProcedure.RorC, true); break;
                case Mnemonic.rra: RewriteRotation(IntrinsicProcedure.RorC, true); break;
                case Mnemonic.rrc: RewriteRotation(IntrinsicProcedure.Ror, true); break;
                case Mnemonic.rrca: RewriteRotation(IntrinsicProcedure.Ror, true); break;
                case Mnemonic.ldd: RewriteBlockInstruction(m.ISub, false); break;
                case Mnemonic.lddr: RewriteBlockInstruction(m.ISub, true); break;
                case Mnemonic.ldi: RewriteBlockInstruction(m.IAdd, false); break;
                case Mnemonic.ldir: RewriteBlockInstruction(m.IAdd, true); break;
                case Mnemonic.neg: RewriteNeg(); break;
                case Mnemonic.nop: m.Nop(); break;
                case Mnemonic.or: RewriteOr(); break;
                case Mnemonic.@out: RewriteOut(); break;
                case Mnemonic.otdr: RewriteOutInstruction(-1, true); break;
                case Mnemonic.otir: RewriteOutInstruction(1, true); break;
                case Mnemonic.outd: RewriteOutInstruction(-1, false); break;
                case Mnemonic.outi: RewriteOutInstruction(1, false); break;
                case Mnemonic.pop: RewritePop(); break;
                case Mnemonic.push: RewritePush(dasm.Current); break;
                case Mnemonic.res: RewriteResSet("__res"); break;
                case Mnemonic.ret: RewriteRet(); break;
                case Mnemonic.rst: RewriteRst(); break;
                case Mnemonic.sbc: RewriteSbc(); break;
                case Mnemonic.scf: RewriteScf(); break;
                case Mnemonic.set: RewriteResSet("__set"); break;
                case Mnemonic.sla: RewriteShift(dasm.Current, m.Shl); break;
                case Mnemonic.sra: RewriteShift(dasm.Current, m.Sar); break;
                case Mnemonic.srl: RewriteShift(dasm.Current, m.Shr); break;
                case Mnemonic.sll: RewriteShift(dasm.Current, m.Shl); break;
                case Mnemonic.sub: RewriteSub(); break;
                case Mnemonic.xor: RewriteXor(); break;

                //$TODO: Not implemented yet; feel free to implement these!
                case Mnemonic.reti: goto default;
                case Mnemonic.retn: goto default;
                case Mnemonic.rld: goto default;
                case Mnemonic.rrd: goto default;
                }
                yield return m.MakeCluster(addr, len, iclass);
            }
        }

        private void RewriteAdc()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.IAdd(m.IAdd(dst, src), FlagGroup(Registers.C)));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteAdd()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.IAdd(dst, src));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteAnd()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.And(dst, src));
            AssignCond(Registers.SZ, dst);
            m.Assign(FlagGroup(Registers.C), Constant.False());
        }

        private void RewriteBlockInstruction(Func<Expression, Expression, Expression> incdec, bool repeat)
        {
            var bc = binder.EnsureRegister(Registers.bc);
            var de = binder.EnsureRegister(Registers.de);
            var hl = binder.EnsureRegister(Registers.hl);
            var V =  FlagGroup(Registers.P);
            m.Assign(m.Mem8(de), m.Mem8(hl));
            m.Assign(hl, incdec(hl, Constant.Int16(1)));
            m.Assign(de, incdec(de, Constant.Int16(1)));
            m.Assign(bc, m.ISub(bc, 1));
            if (repeat)
            {
                m.BranchInMiddleOfInstruction(m.Ne0(bc), dasm.Current.Address, InstrClass.Transfer);
            }
            m.Assign(V, m.Const(PrimitiveType.Bool, 0));
        }

        private void RewriteNeg()
        {
            var a = binder.EnsureRegister(Registers.a);
            m.Assign(a, m.Neg(a));
            AssignCond(Registers.SZPC, a);
        }

        private void RewriteOr()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.Or(dst, src));
            AssignCond(Registers.SZ, dst);
            m.Assign(FlagGroup(Registers.C), Constant.False());
        }

        private void RewriteSbc()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.ISub(m.ISub(dst, src), FlagGroup(Registers.C)));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteRotation(string pseudoOp, bool useCarry)
        {
            Expression reg;
            if (dasm.Current.Operands.Length > 0)
            {
                reg = RewriteOp(dasm.Current.Operands[0]);
            }
            else
            {
                reg = binder.EnsureRegister(Registers.a);
            }
            var C = FlagGroup(Registers.C);
            var one = m.Byte(1);
            Expression src;
            if (useCarry)
            {
                src = host.Intrinsic(pseudoOp, true, reg.DataType, reg, one, C);
            }
            else 
            {
                src = host.Intrinsic(pseudoOp, true, reg.DataType, reg, one);
            }
            m.Assign(reg, src);
            m.Assign(C, m.Cond(reg));
        }

        private void RewriteScf()
        {
            AssignCond(Registers.C, Constant.True());
        }

        private void RewriteSub()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.ISub(dst, src));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteXor()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.Xor(dst, src));
            AssignCond(Registers.SZ, dst);
            m.Assign(FlagGroup(Registers.C), Constant.False());
        }

        private void AssignCond(FlagGroupStorage flags, Expression dst)
        {
            m.Assign(FlagGroup(flags), m.Cond(dst));
        }

        public Identifier FlagGroup(FlagGroupStorage flags)
        {
            return binder.EnsureFlagGroup(flags);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        private void EmitBranch(ConditionOperand cOp, Address dst)
        {
            m.Branch(
                GenerateTestExpression(cOp, false),
                dst,
                InstrClass.ConditionalTransfer);
        }

        private TestCondition GenerateTestExpression(ConditionOperand cOp, bool invert)
        {
            ConditionCode cc = ConditionCode.ALWAYS;
            FlagGroupStorage? flags = null;
            switch (cOp.Code)
            {
            case CondCode.nz:  cc = invert ? ConditionCode.EQ : ConditionCode.NE; flags = Registers.Z;  break;
            case CondCode.z: cc = invert ? ConditionCode.NE : ConditionCode.EQ; flags = Registers.Z;    break;
            case CondCode.nc: cc = invert ? ConditionCode.ULT : ConditionCode.UGE; flags = Registers.C; break;
            case CondCode.c: cc = invert ? ConditionCode.UGE : ConditionCode.ULT; flags = Registers.C;  break;
            case CondCode.po: cc = invert ? ConditionCode.PE : ConditionCode.PO; flags = Registers.P;  break;
            case CondCode.pe: cc = invert ? ConditionCode.PO : ConditionCode.PE; flags = Registers.P;    break;
            case CondCode.p: cc = invert ? ConditionCode.SG : ConditionCode.NS; flags =  Registers.S;    break;
            case CondCode.m: cc = invert ? ConditionCode.NS : ConditionCode.SG; flags =  Registers.S;    break;
            }
            return m.Test(
                cc,
                FlagGroup(flags!));
        }

        private void RewriteCall(Z80Instruction instr)
        {
            if (instr.Operands[0] is ConditionOperand cOp)
            {
                m.BranchInMiddleOfInstruction(
                    GenerateTestExpression(cOp, true),
                    instr.Address + instr.Length,
                    InstrClass.ConditionalTransfer);
                m.Call(((AddressOperand)instr.Operands[1]).Address, 2);
            }
            else
            {
                m.Call(((AddressOperand)instr.Operands[0]).Address, 2);
            }
        }

        private void RewriteCcf()
        {
            AssignCond(Registers.C, Constant.False());
        }

        private void RewriteCp()
        {
            var a = this.RewriteOp(dasm.Current.Operands[0]);
            var b = this.RewriteOp(dasm.Current.Operands[1]);
            m.Assign(
                FlagGroup(Registers.SZPC),
                m.Cond(m.ISub(a, b)));
        }

        private void RewriteCp(Func<Expression , Expression, Expression> incDec, bool repeat)
        {
            var addr = dasm.Current.Address;
            var a = binder.EnsureRegister(Registers.a);
            var bc = binder.EnsureRegister(Registers.bc);
            var hl = binder.EnsureRegister(Registers.hl);
            var z = FlagGroup(Registers.Z);
            m.Assign(z, m.Cond(m.ISub(a, m.Mem8(hl))));
            m.Assign(hl, incDec(hl, m.Int16(1)));
            m.Assign(bc, m.ISub(bc, 1));
            if (repeat)
            {
                m.BranchInMiddleOfInstruction(m.Eq0(bc), addr + dasm.Current.Length, InstrClass.ConditionalTransfer);
                m.Branch(m.Test(ConditionCode.NE, z), addr, InstrClass.ConditionalTransfer);
            }
        }

        private void RewriteCpl()
        {
            var a = binder.EnsureRegister(Registers.a);
            m.Assign(a, m.Comp(a));
        }

        private void RewriteDaa()
        {
            var a = binder.EnsureRegister(Registers.a);
            m.Assign(
                a,
                host.Intrinsic("__daa", true, PrimitiveType.Byte, a));
            AssignCond(Registers.SZPC, a);
        }

        private void RewriteDec()
        {
            var src = RewriteOp(dasm.Current.Operands[0]);
            var dst = RewriteOp(dasm.Current.Operands[0]);
            m.Assign(dst, m.ISub(src, 1));
            AssignCond(Registers.SZP, dst);
        }

        private void RewriteDjnz(MachineOperand dst)
        {
            var b = binder.EnsureRegister(Registers.b);
            m.Assign(b, m.ISub(b, 1));
            m.Branch(m.Ne0(b), ((AddressOperand)dst).Address, InstrClass.Transfer);
        }

        private void RewriteDi()
        {
            m.SideEffect(host.Intrinsic("__di",false,VoidType.Instance));
        }

        private void RewriteEi()
        {
            m.SideEffect(host.Intrinsic("__ei", false, VoidType.Instance));
        }

        private void RewriteEx()
        {
            var t = binder.CreateTemporary(dasm.Current.Operands[0].Width);
            m.Assign(t, RewriteOp(dasm.Current.Operands[0]));
            m.Assign(RewriteOp(dasm.Current.Operands[0]), RewriteOp(dasm.Current.Operands[1]));
            m.Assign(RewriteOp(dasm.Current.Operands[1]), t);
        }

        private void RewriteExAf()
        {
            var t = binder.CreateTemporary(Registers.af.DataType);
            var af = binder.EnsureRegister(Registers.af);
            var af_ = binder.EnsureRegister(Registers.af_);
            m.Assign(t, af);
            m.Assign(af, af_);
            m.Assign(af_, t);
        }

        private void RewriteExx()
        {
            foreach (var r in new[] { "bc", "de", "hl" })
            {
                var t = binder.CreateTemporary(PrimitiveType.Word16);
                var reg = binder.EnsureRegister(arch.GetRegister(r));
                var reg_ = binder.EnsureRegister(arch.GetRegister(r + "'"));
                m.Assign(t, reg);
                m.Assign(reg, reg_);
                m.Assign(reg_, t);
            }
        }

        private void RewriteHlt()
        {
            var c = new ProcedureCharacteristics
            {
                Terminates = true,
            };
            m.SideEffect(host.Intrinsic("__hlt", false, c, VoidType.Instance));
        }

        private void RewriteInc()
        {
            var src = RewriteOp(dasm.Current.Operands[0]);
            var dst = RewriteOp(dasm.Current.Operands[0]);
            m.Assign(dst, m.IAdd(src, 1));
            AssignCond(Registers.SZP, dst);
        }

        private void RewriteJp(Z80Instruction instr)
        {
            switch (instr.Operands[0])
            {
            case ConditionOperand cOp:
                EmitBranch(cOp, ((AddressOperand)instr.Operands[1]).Address);
                break;
            case AddressOperand target:
                m.Goto(target.Address);
                break;
            case MemoryOperand mTarget:
                m.Goto(binder.EnsureRegister(mTarget.Base!));
                break;
            }
        }

        private void RewriteJr()
        {
            var op = dasm.Current.Operands[0];
            var cop = op as ConditionOperand;
            if (cop != null)
            {
                op = dasm.Current.Operands[1];
            }
            var target = (AddressOperand)op;
            if (cop != null)
            {
                ConditionCode cc;
                FlagGroupStorage cr;
                switch (cop.Code)
                {
                case CondCode.c: cc = ConditionCode.ULT; cr = Registers.C; break;
                case CondCode.nz: cc = ConditionCode.NE; cr = Registers.Z; break;
                case CondCode.nc: cc = ConditionCode.UGE; cr = Registers.C; break;
                case CondCode.z: cc = ConditionCode.EQ; cr = Registers.Z; break;
                default: throw new NotImplementedException();
                }
                m.Branch(
                    m.Test(
                        cc,
                        binder.EnsureFlagGroup(cr)),
                    target.Address,
                    iclass);
            }
            else
            {
                m.Goto(target.Address);
            }
        }

        private void RewriteLd()
        {
            m.Assign(
                RewriteOp(dasm.Current.Operands[0]),
                RewriteOp(dasm.Current.Operands[1]));
        }

        private Expression RewriteOp(MachineOperand op)
        {
            switch (op)
            {
            case RegisterOperand rOp:
                return binder.EnsureRegister(rOp.Register);
            case ImmediateOperand immOp:
                return immOp.Value;
            case MemoryOperand memOp:
                {
                    Identifier? bReg = null;
                    if (memOp.Base != null)
                        bReg = binder.EnsureRegister(memOp.Base);
                    if (memOp.Offset is null)
                    {
                        return m.Mem(memOp.Width, bReg!);
                    }
                    else if (bReg == null)
                    {
                        return m.Mem(memOp.Width, memOp.Offset);
                    }
                    else
                    {
                        int s = memOp.Offset.ToInt32();
                        return m.Mem(memOp.Width, m.AddSubSignedInt(bReg, s));
                        }
                        }
            default:
                throw new NotImplementedException(string.Format("Rewriting of Z80 operand type {0} is not implemented yet.", op.GetType().FullName));
            }
        }

        private void RewriteIn()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, host.Intrinsic("__in", false, PrimitiveType.Byte, src));
        }

        private void RewriteIn(Func<Expression,Expression,Expression> incDec, bool repeat)
        {
            var hl = binder.EnsureRegister(Registers.hl);
            var c = binder.EnsureRegister(Registers.c);
            var b = binder.EnsureRegister(Registers.b);
            var Z = binder.EnsureFlagGroup(arch.GetFlagGroup("Z"));
            m.Assign(
                m.Mem8(hl),
                host.Intrinsic("__in", false, PrimitiveType.Byte, c));
            m.Assign(hl, incDec(hl, m.Int16(1)));
            m.Assign(b, m.ISub(b, 1));
            m.Assign(Z, m.Cond(b));
            if (repeat)
            {
                m.Branch(m.Ne0(b), dasm.Current.Address, InstrClass.ConditionalTransfer);
            }
        }

        private void RewriteOut()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.SideEffect(host.Intrinsic("__out", false, PrimitiveType.Byte, dst, src));
        }

        private void RewriteOutInstruction(int increment, bool repeat)
        {
            var hl = binder.EnsureRegister(Registers.hl);
            var c = binder.EnsureRegister(Registers.c);
            var tmp = binder.CreateTemporary(PrimitiveType.Byte);
            m.Assign(tmp, m.Mem8(hl));
            m.SideEffect(host.Intrinsic("__out", false, VoidType.Instance, c, tmp));
            m.Assign(hl, m.AddSubSignedInt(hl, increment));
            if (repeat)
            {
                var b = binder.EnsureRegister(Registers.b);
                m.Assign(b, m.ISub(b, 1));
                m.Branch(m.Ne0(b), dasm.Current.Address);
            }
        }

        private void RewritePop()
        {
            var sp = binder.EnsureRegister(Registers.sp);
            var op = RewriteOp(dasm.Current.Operands[0]);
            m.Assign(op, m.Mem(PrimitiveType.Word16, sp));
            m.Assign(sp, m.IAdd(sp, op.DataType.Size));
        }

        private void RewritePush(Z80Instruction instr)
        {
            var sp = binder.EnsureRegister(Registers.sp);
            var op = RewriteOp(instr.Operands[0]);
            m.Assign(sp, m.ISub(sp, op.DataType.Size));
            m.Assign(m.Mem(PrimitiveType.Word16, sp), op);
        }

        private void RewriteBit()
        {
            var bit = RewriteOp(dasm.Current.Operands[0]);
            var op = RewriteOp(dasm.Current.Operands[1]);
            AssignCond(Registers.Z, host.Intrinsic("__bit", true, PrimitiveType.Bool, op, bit));
        }

        private void RewriteResSet(string pseudocode)
        {
            var bit = RewriteOp(dasm.Current.Operands[0]);
            var op = RewriteOp(dasm.Current.Operands[1]);
            Expression dst;
            if (op is MemoryAccess)
                dst = binder.CreateTemporary(op.DataType);
            else
                dst = op;
            m.Assign(dst, host.Intrinsic(pseudocode, false, dst.DataType, op, bit));
            if (dst != op)
            {
                m.Assign(op, dst);
            }
        }

        private void RewriteRet()
        {
            m.Return(2, 0);
        }

        private void RewriteRst()
        {
            m.Call(
                Address.Ptr16(
                    ((ImmediateOperand)dasm.Current.Operands[0]).Value.ToUInt16()),
                2);
        }

        private void RewriteShift(Z80Instruction instr, Func<Expression, Expression, Expression> op)
        {
            var reg = RewriteOp(instr.Operands[0]);
            var sh = m.Byte(1);
            m.Assign(reg, op(reg, sh));
            AssignCond(Registers.SZPC, reg);
        }
    }
}

---- Transformed Tree ----
using Reko.Core;
using Reko.Core.Expressions;
using Reko.Core.Machine;
using Reko.Core.Memory;
using Reko.Core.Operators;
using Reko.Core.Rtl;
using Reko.Core.Serialization;
using Reko.Core.Types;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Reko.Arch.Z80
{
    public class Z80Rewriter : IEnumerable<RtlInstructionCluster>
    {
        private readonly Z80ProcessorArchitecture arch;
        private readonly IStorageBinder binder;
        private readonly IRewriterHost host;
        private readonly IEnumerator<Z80Instruction> dasm;
        private InstrClass iclass;
        private RtlEmitter m;

#nullable disable
        public Z80Rewriter(Z80ProcessorArchitecture arch, EndianImageReader rdr, ProcessorState state, IStorageBinder binder, IRewriterHost host)
        {
            this.arch = arch;
            this.binder = binder;
            this.host = host;
            this.dasm = new Z80Disassembler(arch, rdr).GetEnumerator();
        }
#nullable enable

        public IEnumerator<RtlInstructionCluster> GetEnumerator()
        {
            while (dasm.MoveNext())
            {
                var addr = dasm.Current.Address;
                var len = dasm.Current.Length;
                this.iclass = dasm.Current.InstructionClass;
                var rtlInstructions = new List<RtlInstruction>();
                m = new RtlEmitter(rtlInstructions);
                switch (dasm.Current.Mnemonic)
                {
                default:
                    host.Error(
               dasm.Current.Address,
               "Z80 instruction '{0}' is not supported yet.",
               dasm.Current.Mnemonic);
                    goto case Mnemonic.illegal;
                case Mnemonic.illegal: m.Invalid(); break;
                case Mnemonic.adc: RewriteAdc(); break;
                case Mnemonic.add: RewriteAdd(); break;
                case Mnemonic.and: RewriteAnd(); break;
                case Mnemonic.bit: RewriteBit(); break;
                case Mnemonic.call: RewriteCall(dasm.Current); break;
                case Mnemonic.ccf: RewriteCcf(); break;
                case Mnemonic.cp: RewriteCp(); break;
                case Mnemonic.cpd: RewriteCp(m.ISub, false); break;
                case Mnemonic.cpdr: RewriteCp(m.ISub, true); break;
                case Mnemonic.cpi: RewriteCp(m.IAdd, false); break;
                case Mnemonic.cpir: RewriteCp(m.IAdd, true); break;
                case Mnemonic.cpl: RewriteCpl(); break;
                case Mnemonic.di: RewriteDi(); break;
                case Mnemonic.daa: RewriteDaa(); break;
                case Mnemonic.dec: RewriteDec(); break;
                case Mnemonic.djnz: RewriteDjnz(dasm.Current.Operands[0]); break;
                case Mnemonic.ei: RewriteEi(); break;
                case Mnemonic.ex: RewriteEx(); break;
                case Mnemonic.ex_af: RewriteExAf(); break;
                case Mnemonic.exx: RewriteExx(); break;
                case Mnemonic.hlt: RewriteHlt(); break;
                case Mnemonic.@in: RewriteIn(); break;
                case Mnemonic.ind: RewriteIn(m.ISub, false); break;
                case Mnemonic.indr: RewriteIn(m.ISub, true); break;
                case Mnemonic.ini: RewriteIn(m.IAdd, false); break;
                case Mnemonic.inir: RewriteIn(m.IAdd, true); break;
                case Mnemonic.im:
                    m.SideEffect(host.Intrinsic("__im", false, VoidType.Instance, RewriteOp(dasm.Current.Operands[0])));
                    break;
                case Mnemonic.inc: RewriteInc(); break;
                case Mnemonic.jp: RewriteJp(dasm.Current); break;
                case Mnemonic.jr: RewriteJr(); break;
                case Mnemonic.ld: RewriteLd(); break;
                case Mnemonic.rl: RewriteRotation(IntrinsicProcedure.RolC, true); break;
                case Mnemonic.rla: RewriteRotation(IntrinsicProcedure.RolC, true); break;
                case Mnemonic.rlc: RewriteRotation(IntrinsicProcedure.Rol, false); break;
                case Mnemonic.rlca: RewriteRotation(IntrinsicProcedure.Rol, false); break;
                case Mnemonic.rr: RewriteRotation(IntrinsicProcedure.RorC, true); break;
                case Mnemonic.rra: RewriteRotation(IntrinsicProcedure.RorC, true); break;
                case Mnemonic.rrc: RewriteRotation(IntrinsicProcedure.Ror, true); break;
                case Mnemonic.rrca: RewriteRotation(IntrinsicProcedure.Ror, true); break;
                case Mnemonic.ldd: RewriteBlockInstruction(m.ISub, false); break;
                case Mnemonic.lddr: RewriteBlockInstruction(m.ISub, true); break;
                case Mnemonic.ldi: RewriteBlockInstruction(m.IAdd, false); break;
                case Mnemonic.ldir: RewriteBlockInstruction(m.IAdd, true); break;
                case Mnemonic.neg: RewriteNeg(); break;
                case Mnemonic.nop: m.Nop(); break;
                case Mnemonic.or: RewriteOr(); break;
                case Mnemonic.@out: RewriteOut(); break;
                case Mnemonic.otdr: RewriteOutInstruction(-1, true); break;
                case Mnemonic.otir: RewriteOutInstruction(1, true); break;
                case Mnemonic.outd: RewriteOutInstruction(-1, false); break;
                case Mnemonic.outi: RewriteOutInstruction(1, false); break;
                case Mnemonic.pop: RewritePop(); break;
                case Mnemonic.push: RewritePush(dasm.Current); break;
                case Mnemonic.res: RewriteResSet("__res"); break;
                case Mnemonic.ret: RewriteRet(); break;
                case Mnemonic.rst: RewriteRst(); break;
                case Mnemonic.sbc: RewriteSbc(); break;
                case Mnemonic.scf: RewriteScf(); break;
                case Mnemonic.set: RewriteResSet("__set"); break;
                case Mnemonic.sla: RewriteShift(dasm.Current, m.Shl); break;
                case Mnemonic.sra: RewriteShift(dasm.Current, m.Sar); break;
                case Mnemonic.srl: RewriteShift(dasm.Current, m.Shr); break;
                case Mnemonic.sll: RewriteShift(dasm.Current, m.Shl); break;
                case Mnemonic.sub: RewriteSub(); break;
                case Mnemonic.xor: RewriteXor(); break;

                //$TODO: Not implemented yet; feel free to implement these!
                case Mnemonic.reti: goto default;
                case Mnemonic.retn: goto default;
                case Mnemonic.rld: goto default;
                case Mnemonic.rrd: goto default;
                }
                yield return m.MakeCluster(addr, len, iclass);
            }
        }

        private void RewriteAdc()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.IAdd(m.IAdd(dst, src), FlagGroup(Registers.C)));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteAdd()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.IAdd(dst, src));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteAnd()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.And(dst, src));
            AssignCond(Registers.SZ, dst);
            m.Assign(FlagGroup(Registers.C), Constant.False());
        }

        private void RewriteBlockInstruction(Func<Expression, Expression, Expression> incdec, bool repeat)
        {
            var bc = binder.EnsureRegister(Registers.bc);
            var de = binder.EnsureRegister(Registers.de);
            var hl = binder.EnsureRegister(Registers.hl);
            var V =  FlagGroup(Registers.P);
            m.Assign(m.Mem8(de), m.Mem8(hl));
            m.Assign(hl, incdec(hl, Constant.Int16(1)));
            m.Assign(de, incdec(de, Constant.Int16(1)));
            m.Assign(bc, m.ISub(bc, 1));
            if (repeat)
            {
                m.BranchInMiddleOfInstruction(m.Ne0(bc), dasm.Current.Address, InstrClass.Transfer);
            }
            m.Assign(V, m.Const(PrimitiveType.Bool, 0));
        }

        private void RewriteNeg()
        {
            var a = binder.EnsureRegister(Registers.a);
            m.Assign(a, m.Neg(a));
            AssignCond(Registers.SZPC, a);
        }

        private void RewriteOr()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.Or(dst, src));
            AssignCond(Registers.SZ, dst);
            m.Assign(FlagGroup(Registers.C), Constant.False());
        }

        private void RewriteSbc()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.ISub(m.ISub(dst, src), FlagGroup(Registers.C)));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteRotation(string pseudoOp, bool useCarry)
        {
            Expression reg;
            if (dasm.Current.Operands.Length > 0)
            {
                reg = RewriteOp(dasm.Current.Operands[0]);
            }
            else
            {
                reg = binder.EnsureRegister(Registers.a);
            }
            var C = FlagGroup(Registers.C);
            var one = m.Byte(1);
            Expression src;
            if (useCarry)
            {
                src = host.Intrinsic(pseudoOp, true, reg.DataType, reg, one, C);
            }
            else 
            {
                src = host.Intrinsic(pseudoOp, true, reg.DataType, reg, one);
            }
            m.Assign(reg, src);
            m.Assign(C, m.Cond(reg));
        }

        private void RewriteScf()
        {
            AssignCond(Registers.C, Constant.True());
        }

        private void RewriteSub()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.ISub(dst, src));
            AssignCond(Registers.SZPC, dst);
        }

        private void RewriteXor()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, m.Xor(dst, src));
            AssignCond(Registers.SZ, dst);
            m.Assign(FlagGroup(Registers.C), Constant.False());
        }

        private void AssignCond(FlagGroupStorage flags, Expression dst)
        {
            m.Assign(FlagGroup(flags), m.Cond(dst));
        }

        public Identifier FlagGroup(FlagGroupStorage flags)
        {
            return binder.EnsureFlagGroup(flags);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        private void EmitBranch(ConditionOperand cOp, Address dst)
        {
            m.Branch(
                GenerateTestExpression(cOp, false),
                dst,
                InstrClass.ConditionalTransfer);
        }

        private TestCondition GenerateTestExpression(ConditionOperand cOp, bool invert)
        {
            ConditionCode cc = ConditionCode.ALWAYS;
            FlagGroupStorage? flags = null;
            switch (cOp.Code)
            {
            case CondCode.nz:  cc = invert ? ConditionCode.EQ : ConditionCode.NE; flags = Registers.Z;  break;
            case CondCode.z: cc = invert ? ConditionCode.NE : ConditionCode.EQ; flags = Registers.Z;    break;
            case CondCode.nc: cc = invert ? ConditionCode.ULT : ConditionCode.UGE; flags = Registers.C; break;
            case CondCode.c: cc = invert ? ConditionCode.UGE : ConditionCode.ULT; flags = Registers.C;  break;
            case CondCode.po: cc = invert ? ConditionCode.PE : ConditionCode.PO; flags = Registers.P;  break;
            case CondCode.pe: cc = invert ? ConditionCode.PO : ConditionCode.PE; flags = Registers.P;    break;
            case CondCode.p: cc = invert ? ConditionCode.SG : ConditionCode.NS; flags =  Registers.S;    break;
            case CondCode.m: cc = invert ? ConditionCode.NS : ConditionCode.SG; flags =  Registers.S;    break;
            }
            return m.Test(
                cc,
                FlagGroup(flags!));
        }

        private void RewriteCall(Z80Instruction instr)
        {
            if (instr.Operands[0] is ConditionOperand cOp)
            {
                m.BranchInMiddleOfInstruction(
                    GenerateTestExpression(cOp, true),
                    instr.Address + instr.Length,
                    InstrClass.ConditionalTransfer);
                m.Call(((AddressOperand)instr.Operands[1]).Address, 2);
            }
            else
            {
                m.Call(((AddressOperand)instr.Operands[0]).Address, 2);
            }
        }

        private void RewriteCcf()
        {
            AssignCond(Registers.C, Constant.False());
        }

        private void RewriteCp()
        {
            var a = this.RewriteOp(dasm.Current.Operands[0]);
            var b = this.RewriteOp(dasm.Current.Operands[1]);
            m.Assign(
                FlagGroup(Registers.SZPC),
                m.Cond(m.ISub(a, b)));
        }

        private void RewriteCp(Func<Expression , Expression, Expression> incDec, bool repeat)
        {
            var addr = dasm.Current.Address;
            var a = binder.EnsureRegister(Registers.a);
            var bc = binder.EnsureRegister(Registers.bc);
            var hl = binder.EnsureRegister(Registers.hl);
            var z = FlagGroup(Registers.Z);
            m.Assign(z, m.Cond(m.ISub(a, m.Mem8(hl))));
            m.Assign(hl, incDec(hl, m.Int16(1)));
            m.Assign(bc, m.ISub(bc, 1));
            if (repeat)
            {
                m.BranchInMiddleOfInstruction(m.Eq0(bc), addr + dasm.Current.Length, InstrClass.ConditionalTransfer);
                m.Branch(m.Test(ConditionCode.NE, z), addr, InstrClass.ConditionalTransfer);
            }
        }

        private void RewriteCpl()
        {
            var a = binder.EnsureRegister(Registers.a);
            m.Assign(a, m.Comp(a));
        }

        private void RewriteDaa()
        {
            var a = binder.EnsureRegister(Registers.a);
            m.Assign(
                a,
                host.Intrinsic("__daa", true, PrimitiveType.Byte, a));
            AssignCond(Registers.SZPC, a);
        }

        private void RewriteDec()
        {
            var src = RewriteOp(dasm.Current.Operands[0]);
            var dst = RewriteOp(dasm.Current.Operands[0]);
            m.Assign(dst, m.ISub(src, 1));
            AssignCond(Registers.SZP, dst);
        }

        private void RewriteDjnz(MachineOperand dst)
        {
            var b = binder.EnsureRegister(Registers.b);
            m.Assign(b, m.ISub(b, 1));
            m.Branch(m.Ne0(b), ((AddressOperand)dst).Address, InstrClass.Transfer);
        }

        private void RewriteDi()
        {
            m.SideEffect(host.Intrinsic("__di",false,VoidType.Instance));
        }

        private void RewriteEi()
        {
            m.SideEffect(host.Intrinsic("__ei", false, VoidType.Instance));
        }

        private void RewriteEx()
        {
            var t = binder.CreateTemporary(dasm.Current.Operands[0].Width);
            m.Assign(t, RewriteOp(dasm.Current.Operands[0]));
            m.Assign(RewriteOp(dasm.Current.Operands[0]), RewriteOp(dasm.Current.Operands[1]));
            m.Assign(RewriteOp(dasm.Current.Operands[1]), t);
        }

        private void RewriteExAf()
        {
            var t = binder.CreateTemporary(Registers.af.DataType);
            var af = binder.EnsureRegister(Registers.af);
            var af_ = binder.EnsureRegister(Registers.af_);
            m.Assign(t, af);
            m.Assign(af, af_);
            m.Assign(af_, t);
        }

        private void RewriteExx()
        {
            foreach (var r in new[] { "bc", "de", "hl" })
            {
                var t = binder.CreateTemporary(PrimitiveType.Word16);
                var reg = binder.EnsureRegister(arch.GetRegister(r));
                var reg_ = binder.EnsureRegister(arch.GetRegister(r + "'"));
                m.Assign(t, reg);
                m.Assign(reg, reg_);
                m.Assign(reg_, t);
            }
        }

        private void RewriteHlt()
        {
            var c = new ProcedureCharacteristics
            {
                Terminates = true,
            };
            m.SideEffect(host.Intrinsic("__hlt", false, c, VoidType.Instance));
        }

        private void RewriteInc()
        {
            var src = RewriteOp(dasm.Current.Operands[0]);
            var dst = RewriteOp(dasm.Current.Operands[0]);
            m.Assign(dst, m.IAdd(src, 1));
            AssignCond(Registers.SZP, dst);
        }

        private void RewriteJp(Z80Instruction instr)
        {
            switch (instr.Operands[0])
            {
            case ConditionOperand cOp:
                EmitBranch(cOp, ((AddressOperand)instr.Operands[1]).Address);
                break;
            case AddressOperand target:
                m.Goto(target.Address);
                break;
            case MemoryOperand mTarget:
                m.Goto(binder.EnsureRegister(mTarget.Base!));
                break;
            }
        }

        private void RewriteJr()
        {
            var op = dasm.Current.Operands[0];

            if (op is ConditionOperand cop)
            {
                op = dasm.Current.Operands[1];
            }
            var target = (AddressOperand)op;

            if (op is ConditionOperand cop)
            {
                ConditionCode cc;
                FlagGroupStorage cr;
                switch (cop.Code)
                {
                case CondCode.c: cc = ConditionCode.ULT; cr = Registers.C; break;
                case CondCode.nz: cc = ConditionCode.NE; cr = Registers.Z; break;
                case CondCode.nc: cc = ConditionCode.UGE; cr = Registers.C; break;
                case CondCode.z: cc = ConditionCode.EQ; cr = Registers.Z; break;
                default: throw new NotImplementedException();
                }
                m.Branch(
                    m.Test(
                        cc,
                        binder.EnsureFlagGroup(cr)),
                    target.Address,
                    iclass);
            }
            else
            {
                m.Goto(target.Address);
            }
        }

        private void RewriteLd()
        {
            m.Assign(
                RewriteOp(dasm.Current.Operands[0]),
                RewriteOp(dasm.Current.Operands[1]));
        }

        private Expression RewriteOp(MachineOperand op)
        {
            switch (op)
            {
            case RegisterOperand rOp:
                return binder.EnsureRegister(rOp.Register);
            case ImmediateOperand immOp:
                return immOp.Value;
            case MemoryOperand memOp:
                {
                    Identifier? bReg = null;
                    if (memOp.Base != null)
                        bReg = binder.EnsureRegister(memOp.Base);
                    if (memOp.Offset is null)
                    {
                        return m.Mem(memOp.Width, bReg!);
                    }
                    else if (bReg == null)
                    {
                        return m.Mem(memOp.Width, memOp.Offset);
                    }
                    else
                    {
                        int s = memOp.Offset.ToInt32();
                        return m.Mem(memOp.Width, m.AddSubSignedInt(bReg, s));
                        }
                        }
            default:
                throw new NotImplementedException(string.Format("Rewriting of Z80 operand type {0} is not implemented yet.", op.GetType().FullName));
            }
        }

        private void RewriteIn()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.Assign(dst, host.Intrinsic("__in", false, PrimitiveType.Byte, src));
        }

        private void RewriteIn(Func<Expression,Expression,Expression> incDec, bool repeat)
        {
            var hl = binder.EnsureRegister(Registers.hl);
            var c = binder.EnsureRegister(Registers.c);
            var b = binder.EnsureRegister(Registers.b);
            var Z = binder.EnsureFlagGroup(arch.GetFlagGroup("Z"));
            m.Assign(
                m.Mem8(hl),
                host.Intrinsic("__in", false, PrimitiveType.Byte, c));
            m.Assign(hl, incDec(hl, m.Int16(1)));
            m.Assign(b, m.ISub(b, 1));
            m.Assign(Z, m.Cond(b));
            if (repeat)
            {
                m.Branch(m.Ne0(b), dasm.Current.Address, InstrClass.ConditionalTransfer);
            }
        }

        private void RewriteOut()
        {
            var dst = RewriteOp(dasm.Current.Operands[0]);
            var src = RewriteOp(dasm.Current.Operands[1]);
            m.SideEffect(host.Intrinsic("__out", false, PrimitiveType.Byte, dst, src));
        }

        private void RewriteOutInstruction(int increment, bool repeat)
        {
            var hl = binder.EnsureRegister(Registers.hl);
            var c = binder.EnsureRegister(Registers.c);
            var tmp = binder.CreateTemporary(PrimitiveType.Byte);
            m.Assign(tmp, m.Mem8(hl));
            m.SideEffect(host.Intrinsic("__out", false, VoidType.Instance, c, tmp));
            m.Assign(hl, m.AddSubSignedInt(hl, increment));
            if (repeat)
            {
                var b = binder.EnsureRegister(Registers.b);
                m.Assign(b, m.ISub(b, 1));
                m.Branch(m.Ne0(b), dasm.Current.Address);
            }
        }

        private void RewritePop()
        {
            var sp = binder.EnsureRegister(Registers.sp);
            var op = RewriteOp(dasm.Current.Operands[0]);
            m.Assign(op, m.Mem(PrimitiveType.Word16, sp));
            m.Assign(sp, m.IAdd(sp, op.DataType.Size));
        }

        private void RewritePush(Z80Instruction instr)
        {
            var sp = binder.EnsureRegister(Registers.sp);
            var op = RewriteOp(instr.Operands[0]);
            m.Assign(sp, m.ISub(sp, op.DataType.Size));
            m.Assign(m.Mem(PrimitiveType.Word16, sp), op);
        }

        private void RewriteBit()
        {
            var bit = RewriteOp(dasm.Current.Operands[0]);
            var op = RewriteOp(dasm.Current.Operands[1]);
            AssignCond(Registers.Z, host.Intrinsic("__bit", true, PrimitiveType.Bool, op, bit));
        }

        private void RewriteResSet(string pseudocode)
        {
            var bit = RewriteOp(dasm.Current.Operands[0]);
            var op = RewriteOp(dasm.Current.Operands[1]);
            Expression dst;
            if (op is MemoryAccess)
                dst = binder.CreateTemporary(op.DataType);
            else
                dst = op;
            m.Assign(dst, host.Intrinsic(pseudocode, false, dst.DataType, op, bit));
            if (dst != op)
            {
                m.Assign(op, dst);
            }
        }

        private void RewriteRet()
        {
            m.Return(2, 0);
        }

        private void RewriteRst()
        {
            m.Call(
                Address.Ptr16(
                    ((ImmediateOperand)dasm.Current.Operands[0]).Value.ToUInt16()),
                2);
        }

        private void RewriteShift(Z80Instruction instr, Func<Expression, Expression, Expression> op)
        {
            var reg = RewriteOp(instr.Operands[0]);
            var sh = m.Byte(1);
            m.Assign(reg, op(reg, sh));
            AssignCond(Registers.SZPC, reg);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(25,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(470,40): error CS0128: A local variable or function named 'cop' is already defined in this scope,D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(474,25): error CS0165: Use of unassigned local variable 'cop',D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Arch\Z80\Z80Rewriter.cs(25,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 15 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\UserInterfaces\WindowsForms\LowLevelViewInteractor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Reko.Core;
using Reko.Core.Machine;
using Reko.Core.Memory;
using Reko.Core.Output;
using Reko.Core.Services;
using Reko.Core.Types;
using Reko.Gui;
using Reko.Gui.Forms;
using Reko.Gui.Visualizers;
using Reko.UserInterfaces.WindowsForms.Controls;
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace Reko.UserInterfaces.WindowsForms
{
    /// <summary>
    /// This class manages user interaction with the LowLevelView control.
    /// </summary>
    public class LowLevelViewInteractor : IWindowPane, ICommandTarget
    {
        public event EventHandler<SelectionChangedEventArgs> SelectionChanged;

        private IServiceProvider services;
        private LowLevelView control;
        private TypeMarker typeMarker;
        private Program program;
        private bool ignoreAddressChange;
        private NavigationInteractor<Address> navInteractor;

        public LowLevelView Control { get { return control; } }
        public IWindowFrame Frame { get; set; }

        public Program Program
        {
            get { return program; }
            set
            {
                program = value;
                OnProgramChanged(value);
            }
        }

        private void OnProgramChanged(Program value)
        {
            if (value != null)
            {
                control.MemoryView.ImageMap = value.ImageMap;
                control.MemoryView.SegmentMap = value.SegmentMap;
                control.MemoryView.Architecture = value.Architecture;
                control.DisassemblyView.Program = value;
                var seg = program.SegmentMap.Segments.Values.FirstOrDefault();
                if (seg == null)
                    return;
                control.DisassemblyView.Program = value;
                control.DisassemblyView.Model = new DisassemblyTextModel(value, seg);
                control.ImageMapView.ImageMap = value.ImageMap;
                control.ImageMapView.SegmentMap = value.SegmentMap;
                control.ImageMapView.Granularity = value.SegmentMap.GetExtent();
                control.VisualizerControl.Program = value;
            }
            return;
        }

        public virtual Address SelectedAddress
        {
            get { return control.MemoryView.SelectedAddress; }
            set
            {
                control.CurrentAddress = value;
            }
        }

        public object CreateControl()
        {
            var uiService = services.RequireService<IDecompilerShellUiService>();
            this.control = new LowLevelView();
            this.Control.Font = new Font("Lucida Console", 10F); //$TODO: use user preference
            this.Control.CurrentAddressChanged += LowLevelView_CurrentAddressChanged;

            this.Control.ImageMapView.SelectedAddressChanged += ImageMapView_SelectedAddressChanged;

            this.Control.MemoryView.SelectionChanged += MemoryView_SelectionChanged;
            uiService.SetContextMenu(this.Control.MemoryView, MenuIds.CtxMemoryControl);
            this.control.MemoryView.Services = this.services;

            this.Control.DisassemblyView.StyleClass = UiStyles.Disassembler;
            this.Control.DisassemblyView.SelectedObjectChanged += DisassemblyView_SelectedObjectChanged;
            uiService.SetContextMenu(this.Control.DisassemblyView, MenuIds.CtxDisassembler);
            this.Control.DisassemblyView.Services = this.services;
            this.Control.DisassemblyView.Navigate += DisassemblyControl_Navigate;

            this.Control.VisualizerControl.Services = services;
            PopulateVisualizers();
            this.Control.VisualizerList.SelectedIndexChanged += VisualizerList_SelectedIndexChanged;
            this.control.VisualizerList.SelectedIndex = 0;

            this.Control.ToolBarGoButton.Click += ToolBarGoButton_Click;
            this.Control.ToolBarAddressTextbox.KeyDown += ToolBarAddressTextbox_KeyDown;

            this.navInteractor = new NavigationInteractor<Address>();
            this.navInteractor.Attach(this.Control);

            typeMarker = new TypeMarker(control.MemoryView);

            return control;
        }


        public void SetSite(IServiceProvider sp)
        {
            services = sp;
        }

        public void Close()
        {
        }

        private void NavigateToToolbarAddress()
        {
            var txtAddr = Control.ToolBarAddressTextbox.Text;
            if (txtAddr[0] == 0xFEFF)
            {
                // Get rid of UTF-16 BOM Windows insists on prepending
                 txtAddr = txtAddr.Substring(1);
            }
            txtAddr = txtAddr.Trim();
            if (txtAddr.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
                txtAddr = txtAddr.Substring(2);
            if (!program.Architecture.TryParseAddress(txtAddr, out Address addr))
                return;
            UserNavigateToAddress(Control.MemoryView.TopAddress, addr);
        }

        private void PopulateVisualizers()
        {
            //$REVIEW: load the visualizers from a config file?
            this.Control.VisualizerList.Items.Add(
                new ListOption("ASCII strings", new AsciiStringVisualizer()));
            this.control.VisualizerList.Items.Add(
                new ListOption("Code and data", new CodeDataVisualizer()));
            this.Control.VisualizerList.Items.Add(
                new ListOption("Heat map", new HeatmapVisualizer()));
        }

        private void UserNavigateToAddress(Address addrFrom, Address addrTo)
        {
            if (!program.SegmentMap.IsValidAddress(addrTo))
                return;
            navInteractor.RememberAddress(addrFrom);
            control.CurrentAddress = addrTo;        // ...and move to the new position.
        }

        public bool QueryStatus(CommandID cmdId, CommandStatus status, CommandText text)
        {
            if (Control.MemoryView.Focused)
            {
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.ViewGoToAddress:
                    case CmdIds.ActionMarkType:
                    case CmdIds.ViewFindWhatPointsHere:
                    case CmdIds.ActionMarkProcedure:
                    case CmdIds.TextEncodingChoose:
                        status.Status = MenuStatus.Visible | MenuStatus.Enabled; return true;
                    case CmdIds.EditCopy:
                    case CmdIds.ViewFindPattern:
                        status.Status = ValidSelection()
                            ? MenuStatus.Visible | MenuStatus.Enabled
                            : MenuStatus.Visible;
                        return true;
                    }
                }
            }
            else if (Control.DisassemblyView.Focused)
            {
                var selAddress = Control.DisassemblyView.SelectedObject as Address;
                var instr = Control.DisassemblyView.SelectedObject as MachineInstruction;
                
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.EditCopy:
                        status.Status = ValidDisassemblerSelection()
                            ? MenuStatus.Visible | MenuStatus.Enabled
                            : MenuStatus.Visible;
                        return true;
                    case CmdIds.OpenLink:
                    case CmdIds.OpenLinkInNewWindow:
                        status.Status = selAddress != null ? MenuStatus.Visible | MenuStatus.Enabled : 0;
                        return true;
                    case CmdIds.EditAnnotation:
                    case CmdIds.EditRegisterValues:
                        status.Status = instr != null ? MenuStatus.Visible | MenuStatus.Enabled : 0;
                        return true;
                    case CmdIds.ActionCallTerminates:
                        if (instr != null)
                        {
                            if ((instr.InstructionClass &  InstrClass.Call) != 0)
                            {
                                status.Status = MenuStatus.Visible | MenuStatus.Enabled;
                            }
                            else
                            {
                                status.Status = MenuStatus.Visible;
                            }
                        }
                        else
                        {
                            status.Status = 0;
                        }
                        return true;
                    case CmdIds.ViewPcRelative:
                        status.Status = MenuStatus.Visible | MenuStatus.Enabled |
                            (control.DisassemblyView.ShowPcRelative ? MenuStatus.Checked : 0);
                        return true;
                    case CmdIds.TextEncodingChoose:
                        return true;
                    }
                }
            }
            return false;
        }

        public bool Execute(CommandID cmdId)
        {
            if (Control.MemoryView.Focused)
            {
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.EditCopy: return CopySelectionToClipboard();
                    case CmdIds.ViewGoToAddress: GotoAddress(); return true;
                    case CmdIds.ActionMarkType: return MarkType();
                    case CmdIds.ActionMarkProcedure: MarkAndScanProcedure(); return true;
                    case CmdIds.ViewFindWhatPointsHere: return ViewWhatPointsHere();
                    case CmdIds.ViewFindPattern: return ViewFindPattern();
                    case CmdIds.TextEncodingChoose: return ChooseTextEncoding();
                    }
                }
            }
            else if (Control.DisassemblyView.Focused)
            {
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.EditCopy: return CopyDisassemblerSelectionToClipboard();
                    case CmdIds.EditAnnotation: return EditDasmAnnotation();
                    case CmdIds.EditRegisterValues: return EditRegisterValues();
                    case CmdIds.TextEncodingChoose: return ChooseTextEncoding();
                    case CmdIds.ActionCallTerminates: return EditCallSite();
                    case CmdIds.ViewPcRelative: return ToggleShowPcRelative();
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns the range of address that are selected in the memory view.
        /// </summary>
        /// <returns></returns>
        public virtual AddressRange GetSelectedAddressRange()
        {
            return control.MemoryView.GetAddressRange();
        }

        public void GotoAddress()
        {
            AddressRange addrRange = GetSelectedAddressRange();
            if (addrRange == null)
                return;
            var rdr = program.CreateImageReader(program.Architecture, addrRange.Begin);
            if (!rdr.TryRead(program.Platform.PointerType, out var addrDst))
                return;
            var txt = control.ToolBarAddressTextbox;
            txt.Text = addrDst.ToString();
            txt.SelectAll();
            txt.Focus();
        }

        public void InvalidateControl()
        {
            control.Invalidate();
        }

        public void MarkAndScanProcedure()
        {
            if (!TryGetSelectedAddressRange(out var addrRange))
                return;
            var address = new ProgramAddress(program, addrRange.Begin);
            services.RequireService<ICommandFactory>().MarkProcedure(address).Do();
        }

        private bool TryGetSelectedAddressRange(out AddressRange addrRange)
        {
            addrRange = null;
            if (control.MemoryView.Focused)
            {
                addrRange = control.MemoryView.GetAddressRange();
                if (!addrRange.IsValid)
                    return false;
            }
            else if (control.DisassemblyView.Focused)
            {
                var addr = control.DisassemblyView.SelectedObject as Address;
                if (addr == null)
                    return false;
                addrRange = new AddressRange(addr, addr);
                return true;
            }
            return true;
        }

        /// <summary>
        /// Copies the selected range of bytes into the clipboard.
        /// </summary>
        /// <returns></returns>
        private bool CopySelectionToClipboard()
        {
            if (!TryGetSelectedAddressRange(out var range))
                return true;
            if (control.MemoryView.Focused)
            {
                var decompiler = services.GetService<IDecompilerService>().Decompiler;
                var dumper = new Dumper(decompiler.Project.Programs.First());
                var sb = new StringWriter();
                dumper.DumpData(control.MemoryView.SegmentMap, program.Architecture, range, new TextFormatter(sb));
                var text = sb.ToString();
                if (text.Length > 0)
                {
                    Clipboard.SetText(text);       //$TODO: abstract this.
                }
            }
            return true;
        }

        private bool CopyDisassemblerSelectionToClipboard()
        {
            var ms = new MemoryStream();
            control.DisassemblyView.Selection.Save(ms, DataFormats.UnicodeText);
            var text = new string(Encoding.Unicode.GetChars(ms.ToArray()));
            Clipboard.SetData(DataFormats.UnicodeText, text);
            return true;
        }

        public bool MarkType()
        {
            var addrRange = control.MemoryView.GetAddressRange();
            if (addrRange.IsValid)
            {
                typeMarker.Show(
                    control.MemoryView.AddressToPoint(addrRange.Begin),
                    typeMarker_TextAccepted);
            }
            return true;
        }

        private void typeMarker_TextAccepted(string text)
        {
            var item = SetTypeAtAddressRange(GetSelectedAddressRange().Begin, text);
            if (item == null)
                return;
            // Advance selection to beyond item.
            this.SelectedAddress = item.Address + item.Size;
        }

        private bool ValidSelection()
        {
            if (control.MemoryView.Focused)
            {
                var addrRange = control.MemoryView.GetAddressRange();
                if (addrRange.IsValid)
                    return true;
            }
            return false;
        }

        private bool ValidDisassemblerSelection()
        { 
            return !control.DisassemblyView.Selection.IsEmpty;
        }

        public ImageMapItem SetTypeAtAddressRange(Address address, string userText)
        {
            var dataType = HungarianParser.Parse(userText);
            if (dataType == null)
                return null;
            if (dataType is ArrayType arr && arr.ElementType.Size != 0)
            {
                var range = control.MemoryView.GetAddressRange();
                if (range.IsValid)
                {
                    long size = (range.End - range.Begin) + 1;
                    int nElems = (int)(size / arr.ElementType.Size);
                    arr.Length = nElems;
                }
            }
            var arch = program.Architecture;
            var item = program.AddUserGlobalItem(arch, address, dataType);
            control.MemoryView.Invalidate();
            return item;
        }

        public bool ViewWhatPointsHere()
        {
            AddressRange addrRange = control.MemoryView.GetAddressRange();
            if (!addrRange.IsValid)
                return true;
            if (program == null)
                return true;
            services.RequireService<ICommandFactory>().ViewWhatPointsHere(program, addrRange.Begin).Do();
            return true;
        }

        public bool ViewFindPattern()
        {
            AddressRange addrRange = control.MemoryView.GetAddressRange();
            if (!addrRange.IsValid || program == null)
                return true;
            var dlgFactory = services.RequireService<IDialogFactory>();
            var uiSvc = services.RequireService<IDecompilerShellUiService>();
            var srSvc = services.RequireService<ISearchResultService>();

            using (ISearchDialog dlg = dlgFactory.CreateSearchDialog())
            {
                dlg.InitialPattern = SelectionToHex(addrRange);
                if (uiSvc.ShowModalDialog(dlg) == Gui.DialogResult.OK)
                {
                    var re = Core.Dfa.Automaton.CreateFromPattern(dlg.Patterns.Text);
                    var hits =
                        //$BUG: wrong result
                        program.SegmentMap.Segments.Values
                        .SelectMany(s => GetMatches(s, re))
                        .Select(offset => new AddressSearchHit(
                            program,
                            program.ImageMap.BaseAddress + offset,
                            1));
                    srSvc.ShowAddressSearchResults(hits, new CodeSearchDetails());
                }
            }
            return true;
        }

        private IEnumerable<int> GetMatches(ImageSegment s, Core.Dfa.Automaton re)
        {
            var mem = (ByteMemoryArea) s.MemoryArea;
            return re.GetMatches(mem.Bytes, 0);
        }

        public bool ChooseTextEncoding()
        {
            var dlgFactory = services.RequireService<IDialogFactory>();
            var uiSvc = services.RequireService<IDecompilerShellUiService>();
            using (ITextEncodingDialog dlg = dlgFactory.CreateTextEncodingDialog())
            {
                if (uiSvc.ShowModalDialog(dlg) == Gui.DialogResult.OK)
                {
                    var enc = dlg.GetSelectedTextEncoding();
                    this.control.MemoryView.Encoding = enc;
                    program.User.TextEncoding = enc;
                    this.control.DisassemblyView.RecomputeLayout();
                }
            }
            return true;
        }

        public bool ToggleShowPcRelative()
        {
            var show = control.DisassemblyView.ShowPcRelative;
            control.DisassemblyView.ShowPcRelative = !show;
            control.DisassemblyView.RecomputeLayout();
            return true;
        }

        public bool EditDasmAnnotation()
        {
            return true;
        }

        public bool EditRegisterValues()
        {
            if (Control.DisassemblyView.SelectedObject is MachineInstruction instr)
            {
                if (!program.User.RegisterValues.TryGetValue(instr.Address, out var regValues))
                {
                    regValues = new List<UserRegisterValue>();
                }
                var dlgFactory = services.RequireService<IDialogFactory>();
                var uiSvc = services.RequireService<IDecompilerShellUiService>();
                using (var dlg = dlgFactory.CreateRegisterValuesDialog(this.program.Architecture, regValues))
                {
                    if (Gui.DialogResult.OK == uiSvc.ShowModalDialog(dlg))
                    {
                        regValues = dlg.RegisterValues;
                        program.User.RegisterValues[instr.Address] = regValues;
                    }
                }
            }
            return true;
        }

        public bool EditCallSite()
        {
            var instr = (MachineInstruction)Control.DisassemblyView.SelectedObject;
            var dlgFactory = services.RequireService<IDialogFactory>();
            var uiSvc = services.RequireService<IDecompilerShellUiService>();
            var ucd = GetUserCallDataFromAddress(instr.Address);
            using (var dlg = dlgFactory.CreateCallSiteDialog(this.program, ucd))
            {
                if (Gui.DialogResult.OK == uiSvc.ShowModalDialog(dlg))
                {
                    ucd = dlg.GetUserCallData(null);
                    SetUserCallData(ucd);
                }
            }
            return true;
        }

        private UserCallData GetUserCallDataFromAddress(Address addr)
        {
            if (!program.User.Calls.TryGetValue(addr, out UserCallData ucd))
            {
                ucd = new UserCallData { Address = addr };
            }
            return ucd;
        }

        private void SetUserCallData(UserCallData ucd)
        {
            program.User.Calls[ucd.Address] = ucd;
        }

        private string SelectionToHex(AddressRange addr)
        {
            var sb = new StringBuilder();
            var rdr = program.CreateImageReader(program.Architecture, addr.Begin);
            var sep = "";
            while (rdr.Address <= addr.End)
            {
                sb.Append(sep);
                sep = " ";
                sb.AppendFormat("{0:X2}", (uint)rdr.ReadByte());
            }
            return sb.ToString();
        }

        void ImageMapView_SelectedAddressChanged(object sender, EventArgs e)
        {
            if (ignoreAddressChange)
                return;
            var addr = Control.ImageMapView.SelectedAddress; 
            this.ignoreAddressChange = true;
            this.Control.MemoryView.SelectedAddress = addr;
            this.Control.MemoryView.TopAddress = addr;

            if (program.SegmentMap.TryFindSegment(addr, out ImageSegment seg))
            {
                this.Control.DisassemblyView.Model = new DisassemblyTextModel(program, seg);
                this.Control.DisassemblyView.SelectedObject = addr;
                this.control.DisassemblyView.TopAddress = addr;
            }
            this.SelectionChanged.Fire(this, new SelectionChangedEventArgs(new AddressRange(addr, addr)));
            UserNavigateToAddress(Control.MemoryView.TopAddress, addr);
            this.ignoreAddressChange = false;
        }

        private void MemoryView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (ignoreAddressChange)
                return;
            this.ignoreAddressChange = true;
            this.Control.DisassemblyView.SelectedObject = e.AddressRange.Begin;
            this.Control.DisassemblyView.TopAddress = e.AddressRange.Begin;
            this.SelectionChanged.Fire(this, e);
            this.ignoreAddressChange = false;
        }

        void DisassemblyView_SelectedObjectChanged(object sender, EventArgs e)
        {
            var selectedAddr = Control.DisassemblyView.SelectedObject as Address;
            if (ignoreAddressChange || selectedAddr == null)
                return;
            this.ignoreAddressChange = true;
            this.Control.MemoryView.SelectedAddress = selectedAddr;
            this.Control.MemoryView.TopAddress = selectedAddr;
            this.ignoreAddressChange = false;
        }

        void LowLevelView_CurrentAddressChanged(object sender, EventArgs e)
        {
            ignoreAddressChange = true;
            var value = Control.CurrentAddress;
            if (value != null)
            {
                var addrTop = value - ((int)value.ToLinear() & 0x0F);
                control.MemoryView.SelectedAddress = value;
                control.MemoryView.TopAddress = addrTop;
                control.DisassemblyView.TopAddress = value;
            }
            ignoreAddressChange = false;
        }

        void ToolBarAddressTextbox_KeyDown(object sender, Gui.Controls.KeyEventArgs e)
        {
            if (e.KeyData != Gui.Controls.Keys.Return)
                return;
            e.Handled = true;
            e.SuppressKeyPress = true;
            NavigateToToolbarAddress();
        }

        void ToolBarGoButton_Click(object sender, EventArgs e)
        {
            if (ignoreAddressChange)
                return;
            NavigateToToolbarAddress();
        }

        private void DisassemblyControl_Navigate(object sender, EditorNavigationArgs e)
        {
            var addr = e.Destination as Address;
            if (addr == null)
                return;
            UserNavigateToAddress(Control.DisassemblyView.TopAddress, addr);
        }

        private void VisualizerList_SelectedIndexChanged(object sender, EventArgs e)
        {
            var item = (ListOption) this.control.VisualizerList.SelectedItem;
            if (item == null)
                return;
            this.Control.VisualizerControl.Visualizer = (Visualizer)item.Value;
        }

    }
}

---- Transformed Tree ----
using Reko.Core;
using Reko.Core.Machine;
using Reko.Core.Memory;
using Reko.Core.Output;
using Reko.Core.Services;
using Reko.Core.Types;
using Reko.Gui;
using Reko.Gui.Forms;
using Reko.Gui.Visualizers;
using Reko.UserInterfaces.WindowsForms.Controls;
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace Reko.UserInterfaces.WindowsForms
{
    /// <summary>
    /// This class manages user interaction with the LowLevelView control.
    /// </summary>
    public class LowLevelViewInteractor : IWindowPane, ICommandTarget
    {
        public event EventHandler<SelectionChangedEventArgs> SelectionChanged;

        private IServiceProvider services;
        private LowLevelView control;
        private TypeMarker typeMarker;
        private Program program;
        private bool ignoreAddressChange;
        private NavigationInteractor<Address> navInteractor;

        public LowLevelView Control { get { return control; } }
        public IWindowFrame Frame { get; set; }

        public Program Program
        {
            get { return program; }
            set
            {
                program = value;
                OnProgramChanged(value);
            }
        }

        private void OnProgramChanged(Program value)
        {
            if (value != null)
            {
                control.MemoryView.ImageMap = value.ImageMap;
                control.MemoryView.SegmentMap = value.SegmentMap;
                control.MemoryView.Architecture = value.Architecture;
                control.DisassemblyView.Program = value;
                var seg = program.SegmentMap.Segments.Values.FirstOrDefault();
                if (seg == null)
                    return;
                control.DisassemblyView.Program = value;
                control.DisassemblyView.Model = new DisassemblyTextModel(value, seg);
                control.ImageMapView.ImageMap = value.ImageMap;
                control.ImageMapView.SegmentMap = value.SegmentMap;
                control.ImageMapView.Granularity = value.SegmentMap.GetExtent();
                control.VisualizerControl.Program = value;
            }
            return;
        }

        public virtual Address SelectedAddress
        {
            get { return control.MemoryView.SelectedAddress; }
            set
            {
                control.CurrentAddress = value;
            }
        }

        public object CreateControl()
        {
            var uiService = services.RequireService<IDecompilerShellUiService>();
            this.control = new LowLevelView();
            this.Control.Font = new Font("Lucida Console", 10F); //$TODO: use user preference
            this.Control.CurrentAddressChanged += LowLevelView_CurrentAddressChanged;

            this.Control.ImageMapView.SelectedAddressChanged += ImageMapView_SelectedAddressChanged;

            this.Control.MemoryView.SelectionChanged += MemoryView_SelectionChanged;
            uiService.SetContextMenu(this.Control.MemoryView, MenuIds.CtxMemoryControl);
            this.control.MemoryView.Services = this.services;

            this.Control.DisassemblyView.StyleClass = UiStyles.Disassembler;
            this.Control.DisassemblyView.SelectedObjectChanged += DisassemblyView_SelectedObjectChanged;
            uiService.SetContextMenu(this.Control.DisassemblyView, MenuIds.CtxDisassembler);
            this.Control.DisassemblyView.Services = this.services;
            this.Control.DisassemblyView.Navigate += DisassemblyControl_Navigate;

            this.Control.VisualizerControl.Services = services;
            PopulateVisualizers();
            this.Control.VisualizerList.SelectedIndexChanged += VisualizerList_SelectedIndexChanged;
            this.control.VisualizerList.SelectedIndex = 0;

            this.Control.ToolBarGoButton.Click += ToolBarGoButton_Click;
            this.Control.ToolBarAddressTextbox.KeyDown += ToolBarAddressTextbox_KeyDown;

            this.navInteractor = new NavigationInteractor<Address>();
            this.navInteractor.Attach(this.Control);

            typeMarker = new TypeMarker(control.MemoryView);

            return control;
        }


        public void SetSite(IServiceProvider sp)
        {
            services = sp;
        }

        public void Close()
        {
        }

        private void NavigateToToolbarAddress()
        {
            var txtAddr = Control.ToolBarAddressTextbox.Text;
            if (txtAddr[0] == 0xFEFF)
            {
                // Get rid of UTF-16 BOM Windows insists on prepending
                 txtAddr = txtAddr.Substring(1);
            }
            txtAddr = txtAddr.Trim();
            if (txtAddr.StartsWith("0x", StringComparison.InvariantCultureIgnoreCase))
                txtAddr = txtAddr.Substring(2);
            if (!program.Architecture.TryParseAddress(txtAddr, out Address addr))
                return;
            UserNavigateToAddress(Control.MemoryView.TopAddress, addr);
        }

        private void PopulateVisualizers()
        {
            //$REVIEW: load the visualizers from a config file?
            this.Control.VisualizerList.Items.Add(
                new ListOption("ASCII strings", new AsciiStringVisualizer()));
            this.control.VisualizerList.Items.Add(
                new ListOption("Code and data", new CodeDataVisualizer()));
            this.Control.VisualizerList.Items.Add(
                new ListOption("Heat map", new HeatmapVisualizer()));
        }

        private void UserNavigateToAddress(Address addrFrom, Address addrTo)
        {
            if (!program.SegmentMap.IsValidAddress(addrTo))
                return;
            navInteractor.RememberAddress(addrFrom);
            control.CurrentAddress = addrTo;        // ...and move to the new position.
        }

        public bool QueryStatus(CommandID cmdId, CommandStatus status, CommandText text)
        {
            if (Control.MemoryView.Focused)
            {
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.ViewGoToAddress:
                    case CmdIds.ActionMarkType:
                    case CmdIds.ViewFindWhatPointsHere:
                    case CmdIds.ActionMarkProcedure:
                    case CmdIds.TextEncodingChoose:
                        status.Status = MenuStatus.Visible | MenuStatus.Enabled; return true;
                    case CmdIds.EditCopy:
                    case CmdIds.ViewFindPattern:
                        status.Status = ValidSelection()
                            ? MenuStatus.Visible | MenuStatus.Enabled
                            : MenuStatus.Visible;
                        return true;
                    }
                }
            }
            else if (Control.DisassemblyView.Focused)
            {
                
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.EditCopy:
                        status.Status = ValidDisassemblerSelection()
                            ? MenuStatus.Visible | MenuStatus.Enabled
                            : MenuStatus.Visible;
                        return true;
                    case CmdIds.OpenLink:
                    case CmdIds.OpenLinkInNewWindow:
                        status.Status = Control.DisassemblyView.SelectedObject is Address selAddress ? MenuStatus.Visible | MenuStatus.Enabled : 0;
                        return true;
                    case CmdIds.EditAnnotation:
                    case CmdIds.EditRegisterValues:
                        status.Status = Control.DisassemblyView.SelectedObject is MachineInstruction instr ? MenuStatus.Visible | MenuStatus.Enabled : 0;
                        return true;
                    case CmdIds.ActionCallTerminates:

                        if (Control.DisassemblyView.SelectedObject is MachineInstruction instr)
                        {
                            if ((instr.InstructionClass &  InstrClass.Call) != 0)
                            {
                                status.Status = MenuStatus.Visible | MenuStatus.Enabled;
                            }
                            else
                            {
                                status.Status = MenuStatus.Visible;
                            }
                        }
                        else
                        {
                            status.Status = 0;
                        }
                        return true;
                    case CmdIds.ViewPcRelative:
                        status.Status = MenuStatus.Visible | MenuStatus.Enabled |
                            (control.DisassemblyView.ShowPcRelative ? MenuStatus.Checked : 0);
                        return true;
                    case CmdIds.TextEncodingChoose:
                        return true;
                    }
                }
            }
            return false;
        }

        public bool Execute(CommandID cmdId)
        {
            if (Control.MemoryView.Focused)
            {
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.EditCopy: return CopySelectionToClipboard();
                    case CmdIds.ViewGoToAddress: GotoAddress(); return true;
                    case CmdIds.ActionMarkType: return MarkType();
                    case CmdIds.ActionMarkProcedure: MarkAndScanProcedure(); return true;
                    case CmdIds.ViewFindWhatPointsHere: return ViewWhatPointsHere();
                    case CmdIds.ViewFindPattern: return ViewFindPattern();
                    case CmdIds.TextEncodingChoose: return ChooseTextEncoding();
                    }
                }
            }
            else if (Control.DisassemblyView.Focused)
            {
                if (cmdId.Guid == CmdSets.GuidReko)
                {
                    switch (cmdId.ID)
                    {
                    case CmdIds.EditCopy: return CopyDisassemblerSelectionToClipboard();
                    case CmdIds.EditAnnotation: return EditDasmAnnotation();
                    case CmdIds.EditRegisterValues: return EditRegisterValues();
                    case CmdIds.TextEncodingChoose: return ChooseTextEncoding();
                    case CmdIds.ActionCallTerminates: return EditCallSite();
                    case CmdIds.ViewPcRelative: return ToggleShowPcRelative();
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns the range of address that are selected in the memory view.
        /// </summary>
        /// <returns></returns>
        public virtual AddressRange GetSelectedAddressRange()
        {
            return control.MemoryView.GetAddressRange();
        }

        public void GotoAddress()
        {
            AddressRange addrRange = GetSelectedAddressRange();
            if (addrRange == null)
                return;
            var rdr = program.CreateImageReader(program.Architecture, addrRange.Begin);
            if (!rdr.TryRead(program.Platform.PointerType, out var addrDst))
                return;
            var txt = control.ToolBarAddressTextbox;
            txt.Text = addrDst.ToString();
            txt.SelectAll();
            txt.Focus();
        }

        public void InvalidateControl()
        {
            control.Invalidate();
        }

        public void MarkAndScanProcedure()
        {
            if (!TryGetSelectedAddressRange(out var addrRange))
                return;
            var address = new ProgramAddress(program, addrRange.Begin);
            services.RequireService<ICommandFactory>().MarkProcedure(address).Do();
        }

        private bool TryGetSelectedAddressRange(out AddressRange addrRange)
        {
            addrRange = null;
            if (control.MemoryView.Focused)
            {
                addrRange = control.MemoryView.GetAddressRange();
                if (!addrRange.IsValid)
                    return false;
            }
            else if (control.DisassemblyView.Focused)
            {
                var addr = control.DisassemblyView.SelectedObject as Address;
                if (addr == null)
                    return false;
                addrRange = new AddressRange(addr, addr);
                return true;
            }
            return true;
        }

        /// <summary>
        /// Copies the selected range of bytes into the clipboard.
        /// </summary>
        /// <returns></returns>
        private bool CopySelectionToClipboard()
        {
            if (!TryGetSelectedAddressRange(out var range))
                return true;
            if (control.MemoryView.Focused)
            {
                var decompiler = services.GetService<IDecompilerService>().Decompiler;
                var dumper = new Dumper(decompiler.Project.Programs.First());
                var sb = new StringWriter();
                dumper.DumpData(control.MemoryView.SegmentMap, program.Architecture, range, new TextFormatter(sb));
                var text = sb.ToString();
                if (text.Length > 0)
                {
                    Clipboard.SetText(text);       //$TODO: abstract this.
                }
            }
            return true;
        }

        private bool CopyDisassemblerSelectionToClipboard()
        {
            var ms = new MemoryStream();
            control.DisassemblyView.Selection.Save(ms, DataFormats.UnicodeText);
            var text = new string(Encoding.Unicode.GetChars(ms.ToArray()));
            Clipboard.SetData(DataFormats.UnicodeText, text);
            return true;
        }

        public bool MarkType()
        {
            var addrRange = control.MemoryView.GetAddressRange();
            if (addrRange.IsValid)
            {
                typeMarker.Show(
                    control.MemoryView.AddressToPoint(addrRange.Begin),
                    typeMarker_TextAccepted);
            }
            return true;
        }

        private void typeMarker_TextAccepted(string text)
        {
            var item = SetTypeAtAddressRange(GetSelectedAddressRange().Begin, text);
            if (item == null)
                return;
            // Advance selection to beyond item.
            this.SelectedAddress = item.Address + item.Size;
        }

        private bool ValidSelection()
        {
            if (control.MemoryView.Focused)
            {
                var addrRange = control.MemoryView.GetAddressRange();
                if (addrRange.IsValid)
                    return true;
            }
            return false;
        }

        private bool ValidDisassemblerSelection()
        { 
            return !control.DisassemblyView.Selection.IsEmpty;
        }

        public ImageMapItem SetTypeAtAddressRange(Address address, string userText)
        {
            var dataType = HungarianParser.Parse(userText);
            if (dataType == null)
                return null;
            if (dataType is ArrayType arr && arr.ElementType.Size != 0)
            {
                var range = control.MemoryView.GetAddressRange();
                if (range.IsValid)
                {
                    long size = (range.End - range.Begin) + 1;
                    int nElems = (int)(size / arr.ElementType.Size);
                    arr.Length = nElems;
                }
            }
            var arch = program.Architecture;
            var item = program.AddUserGlobalItem(arch, address, dataType);
            control.MemoryView.Invalidate();
            return item;
        }

        public bool ViewWhatPointsHere()
        {
            AddressRange addrRange = control.MemoryView.GetAddressRange();
            if (!addrRange.IsValid)
                return true;
            if (program == null)
                return true;
            services.RequireService<ICommandFactory>().ViewWhatPointsHere(program, addrRange.Begin).Do();
            return true;
        }

        public bool ViewFindPattern()
        {
            AddressRange addrRange = control.MemoryView.GetAddressRange();
            if (!addrRange.IsValid || program == null)
                return true;
            var dlgFactory = services.RequireService<IDialogFactory>();
            var uiSvc = services.RequireService<IDecompilerShellUiService>();
            var srSvc = services.RequireService<ISearchResultService>();

            using (ISearchDialog dlg = dlgFactory.CreateSearchDialog())
            {
                dlg.InitialPattern = SelectionToHex(addrRange);
                if (uiSvc.ShowModalDialog(dlg) == Gui.DialogResult.OK)
                {
                    var re = Core.Dfa.Automaton.CreateFromPattern(dlg.Patterns.Text);
                    var hits =
                        //$BUG: wrong result
                        program.SegmentMap.Segments.Values
                        .SelectMany(s => GetMatches(s, re))
                        .Select(offset => new AddressSearchHit(
                            program,
                            program.ImageMap.BaseAddress + offset,
                            1));
                    srSvc.ShowAddressSearchResults(hits, new CodeSearchDetails());
                }
            }
            return true;
        }

        private IEnumerable<int> GetMatches(ImageSegment s, Core.Dfa.Automaton re)
        {
            var mem = (ByteMemoryArea) s.MemoryArea;
            return re.GetMatches(mem.Bytes, 0);
        }

        public bool ChooseTextEncoding()
        {
            var dlgFactory = services.RequireService<IDialogFactory>();
            var uiSvc = services.RequireService<IDecompilerShellUiService>();
            using (ITextEncodingDialog dlg = dlgFactory.CreateTextEncodingDialog())
            {
                if (uiSvc.ShowModalDialog(dlg) == Gui.DialogResult.OK)
                {
                    var enc = dlg.GetSelectedTextEncoding();
                    this.control.MemoryView.Encoding = enc;
                    program.User.TextEncoding = enc;
                    this.control.DisassemblyView.RecomputeLayout();
                }
            }
            return true;
        }

        public bool ToggleShowPcRelative()
        {
            var show = control.DisassemblyView.ShowPcRelative;
            control.DisassemblyView.ShowPcRelative = !show;
            control.DisassemblyView.RecomputeLayout();
            return true;
        }

        public bool EditDasmAnnotation()
        {
            return true;
        }

        public bool EditRegisterValues()
        {
            if (Control.DisassemblyView.SelectedObject is MachineInstruction instr)
            {
                if (!program.User.RegisterValues.TryGetValue(instr.Address, out var regValues))
                {
                    regValues = new List<UserRegisterValue>();
                }
                var dlgFactory = services.RequireService<IDialogFactory>();
                var uiSvc = services.RequireService<IDecompilerShellUiService>();
                using (var dlg = dlgFactory.CreateRegisterValuesDialog(this.program.Architecture, regValues))
                {
                    if (Gui.DialogResult.OK == uiSvc.ShowModalDialog(dlg))
                    {
                        regValues = dlg.RegisterValues;
                        program.User.RegisterValues[instr.Address] = regValues;
                    }
                }
            }
            return true;
        }

        public bool EditCallSite()
        {
            var instr = (MachineInstruction)Control.DisassemblyView.SelectedObject;
            var dlgFactory = services.RequireService<IDialogFactory>();
            var uiSvc = services.RequireService<IDecompilerShellUiService>();
            var ucd = GetUserCallDataFromAddress(instr.Address);
            using (var dlg = dlgFactory.CreateCallSiteDialog(this.program, ucd))
            {
                if (Gui.DialogResult.OK == uiSvc.ShowModalDialog(dlg))
                {
                    ucd = dlg.GetUserCallData(null);
                    SetUserCallData(ucd);
                }
            }
            return true;
        }

        private UserCallData GetUserCallDataFromAddress(Address addr)
        {
            if (!program.User.Calls.TryGetValue(addr, out UserCallData ucd))
            {
                ucd = new UserCallData { Address = addr };
            }
            return ucd;
        }

        private void SetUserCallData(UserCallData ucd)
        {
            program.User.Calls[ucd.Address] = ucd;
        }

        private string SelectionToHex(AddressRange addr)
        {
            var sb = new StringBuilder();
            var rdr = program.CreateImageReader(program.Architecture, addr.Begin);
            var sep = "";
            while (rdr.Address <= addr.End)
            {
                sb.Append(sep);
                sep = " ";
                sb.AppendFormat("{0:X2}", (uint)rdr.ReadByte());
            }
            return sb.ToString();
        }

        void ImageMapView_SelectedAddressChanged(object sender, EventArgs e)
        {
            if (ignoreAddressChange)
                return;
            var addr = Control.ImageMapView.SelectedAddress; 
            this.ignoreAddressChange = true;
            this.Control.MemoryView.SelectedAddress = addr;
            this.Control.MemoryView.TopAddress = addr;

            if (program.SegmentMap.TryFindSegment(addr, out ImageSegment seg))
            {
                this.Control.DisassemblyView.Model = new DisassemblyTextModel(program, seg);
                this.Control.DisassemblyView.SelectedObject = addr;
                this.control.DisassemblyView.TopAddress = addr;
            }
            this.SelectionChanged.Fire(this, new SelectionChangedEventArgs(new AddressRange(addr, addr)));
            UserNavigateToAddress(Control.MemoryView.TopAddress, addr);
            this.ignoreAddressChange = false;
        }

        private void MemoryView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (ignoreAddressChange)
                return;
            this.ignoreAddressChange = true;
            this.Control.DisassemblyView.SelectedObject = e.AddressRange.Begin;
            this.Control.DisassemblyView.TopAddress = e.AddressRange.Begin;
            this.SelectionChanged.Fire(this, e);
            this.ignoreAddressChange = false;
        }

        void DisassemblyView_SelectedObjectChanged(object sender, EventArgs e)
        {
            var selectedAddr = Control.DisassemblyView.SelectedObject as Address;
            if (ignoreAddressChange || selectedAddr == null)
                return;
            this.ignoreAddressChange = true;
            this.Control.MemoryView.SelectedAddress = selectedAddr;
            this.Control.MemoryView.TopAddress = selectedAddr;
            this.ignoreAddressChange = false;
        }

        void LowLevelView_CurrentAddressChanged(object sender, EventArgs e)
        {
            ignoreAddressChange = true;
            var value = Control.CurrentAddress;
            if (value != null)
            {
                var addrTop = value - ((int)value.ToLinear() & 0x0F);
                control.MemoryView.SelectedAddress = value;
                control.MemoryView.TopAddress = addrTop;
                control.DisassemblyView.TopAddress = value;
            }
            ignoreAddressChange = false;
        }

        void ToolBarAddressTextbox_KeyDown(object sender, Gui.Controls.KeyEventArgs e)
        {
            if (e.KeyData != Gui.Controls.Keys.Return)
                return;
            e.Handled = true;
            e.SuppressKeyPress = true;
            NavigateToToolbarAddress();
        }

        void ToolBarGoButton_Click(object sender, EventArgs e)
        {
            if (ignoreAddressChange)
                return;
            NavigateToToolbarAddress();
        }

        private void DisassemblyControl_Navigate(object sender, EditorNavigationArgs e)
        {
            var addr = e.Destination as Address;
            if (addr == null)
                return;
            UserNavigateToAddress(Control.DisassemblyView.TopAddress, addr);
        }

        private void VisualizerList_SelectedIndexChanged(object sender, EventArgs e)
        {
            var item = (ListOption) this.control.VisualizerList.SelectedItem;
            if (item == null)
                return;
            this.Control.VisualizerControl.Visualizer = (Visualizer)item.Value;
        }

    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\UserInterfaces\WindowsForms\LowLevelViewInteractor.cs(224,90): error CS0128: A local variable or function named 'instr' is already defined in this scope,D:\a\1\s\src\UserInterfaces\WindowsForms\LowLevelViewInteractor.cs(226,34): error CS0165: Use of unassigned local variable 'instr'
######################################################################


